/*  bcd.h

    BCD Number Library - Include File
    class bcd:  declarations for decimal numbers.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __cplusplus
#error Must use C++ for the type bcd.
#endif

#if !defined(__BCD_H)
#define __BCD_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(__IOSTREAM_H)
#include <iostream.h>
#endif

#if !defined(__MATH_H)
#include <math.h>
#endif

#pragma option -Vo-
#if defined(__BCOPT__) && !defined(_RTL_ALLOW_po)
#pragma option -po-
#endif

#define _BcdMaxDecimals     5000

_CLASSDEF(bcd)

class _CLASSTYPE bcd {

public:
    // constructors
    _Cdecl bcd();
    _Cdecl bcd(int x);
    _Cdecl bcd(unsigned int x);
    _Cdecl bcd(long x);
    _Cdecl bcd(unsigned long x);
    _Cdecl bcd(double x, int decimals = _BcdMaxDecimals);
    _Cdecl bcd(long double x, int decimals = _BcdMaxDecimals);

    // bcd manipulations
    friend long double _Cdecl real(bcd _FAR &);   // Return the real part

    // Overloaded ANSI C math functions
    friend bcd _Cdecl _FARFUNC abs(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC acos(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC asin(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC atan(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC cos(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC cosh(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC exp(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC log(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC log10(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC pow(bcd _FAR & base, bcd _FAR & expon);
    friend bcd _Cdecl _FARFUNC sin(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC sinh(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC sqrt(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC tan(bcd _FAR &);
    friend bcd _Cdecl _FARFUNC tanh(bcd _FAR &);

    // Binary Operator Functions
    friend bcd _Cdecl _FARFUNC operator+(bcd _FAR &, bcd _FAR &);
    friend bcd _Cdecl _FARFUNC operator+(long double, bcd _FAR &);
    friend bcd _Cdecl _FARFUNC operator+(bcd _FAR &, long double);
    friend bcd _Cdecl _FARFUNC operator-(bcd _FAR &, bcd _FAR &);
    friend bcd _Cdecl _FARFUNC operator-(long double, bcd _FAR &);
    friend bcd _Cdecl _FARFUNC operator-(bcd _FAR &, long double);
    friend bcd _Cdecl _FARFUNC operator*(bcd _FAR &, bcd _FAR &);
    friend bcd _Cdecl _FARFUNC operator*(bcd _FAR &, long double);
    friend bcd _Cdecl _FARFUNC operator*(long double, bcd _FAR &);
    friend bcd _Cdecl _FARFUNC operator/(bcd _FAR &, bcd _FAR &);
    friend bcd _Cdecl _FARFUNC operator/(bcd _FAR &, long double);
    friend bcd _Cdecl _FARFUNC operator/(long double, bcd _FAR &);
    friend int _Cdecl _FARFUNC operator==(bcd _FAR &, bcd _FAR &);
    friend int _Cdecl _FARFUNC operator!=(bcd _FAR &, bcd _FAR &);
    friend int _Cdecl _FARFUNC operator>=(bcd _FAR &, bcd _FAR &);
    friend int _Cdecl _FARFUNC operator<=(bcd _FAR &, bcd _FAR &);
    friend int _Cdecl _FARFUNC operator>(bcd _FAR &, bcd _FAR &);
    friend int _Cdecl _FARFUNC operator<(bcd _FAR &, bcd _FAR &);
    bcd _FAR & _Cdecl operator+=(bcd _FAR &);
    bcd _FAR & _Cdecl operator+=(long double);
    bcd _FAR & _Cdecl operator-=(bcd _FAR &);
    bcd _FAR & _Cdecl operator-=(long double);
    bcd _FAR & _Cdecl operator*=(bcd _FAR &);
    bcd _FAR & _Cdecl operator*=(long double);
    bcd _FAR & _Cdecl operator/=(bcd _FAR &);
    bcd _FAR & _Cdecl operator/=(long double);
    bcd  _Cdecl operator+();
    bcd  _Cdecl operator-();

// Implementation
private:
    long mantissa[2];
    int expo;
};

// const bcd bcd_zero(0);

enum bcdexpo {
    ExpoZero,
    ExpoInf,
    ExpoNan,
};

extern "C" {
long double pascal _FARFUNC __bcd_tobinary(const bcd far *p);
void pascal _FARFUNC __bcd_todecimal(long double x, int decimals, bcd far *p);
long double pascal _FARFUNC __bcd_log10(bcd far *p);
void pascal _FARFUNC __bcd_pow10(int n, bcd far *p);
}

inline _Cdecl bcd::bcd()
{
/* if you want zero ...
    mantissa[0] = 0;
    mantissa[1] = 0;
    expo = ExpoZero;
*/
}

inline _Cdecl bcd::bcd(long double x, int decimals)
{
    __bcd_todecimal(x,decimals,this);
}

inline _Cdecl bcd::bcd(double x, int decimals)
{
    __bcd_todecimal(x,decimals,this);
}

inline _Cdecl bcd::bcd(int x)
{
    mantissa[0] = x;
    mantissa[1] = x >= 0 ? 0 : -1;
    expo = 0;
}

inline _Cdecl bcd::bcd(unsigned int x)
{
    mantissa[0] = x;
    mantissa[1] = 0;
    expo = 0;
}

inline _Cdecl bcd::bcd(long x)
{
    mantissa[0] = x;
    mantissa[1] = x >= 0 ? 0 : -1;
    expo = 0;
}

inline _Cdecl bcd::bcd(unsigned long x)
{
    mantissa[0] = x;
    mantissa[1] = 0;
    expo = 0;
}

inline long double _Cdecl real(bcd& z)
{
    return __bcd_tobinary(&z);
}

// Definitions of compound-assignment operator member functions

inline bcd& _Cdecl bcd::operator+=(bcd& b)
{
    __bcd_todecimal(real(*this)+real(b),_BcdMaxDecimals,this);
    return *this;
}

inline bcd& _Cdecl bcd::operator+=(long double b)
{
    __bcd_todecimal(real(*this)+b,_BcdMaxDecimals,this);
    return *this;
}

inline bcd& _Cdecl bcd::operator-=(bcd& b)
{
    __bcd_todecimal(real(*this)-real(b),_BcdMaxDecimals,this);
    return *this;
}

inline bcd& _Cdecl bcd::operator-=(long double b)
{
    __bcd_todecimal(real(*this)-b,_BcdMaxDecimals,this);
    return *this;
}

inline bcd& _Cdecl bcd::operator*=(bcd& b)
{
    __bcd_todecimal(real(*this)*real(b),_BcdMaxDecimals,this);
    return *this;
}

inline bcd& _Cdecl bcd::operator*=(long double b)
{
    __bcd_todecimal(real(*this)*b,_BcdMaxDecimals,this);
    return *this;
}

inline bcd& _Cdecl bcd::operator/=(bcd& b)
{
    __bcd_todecimal(real(*this)/real(b),_BcdMaxDecimals,this);
    return *this;
}

inline bcd& _Cdecl bcd::operator/=(long double b)
{
    __bcd_todecimal(real(*this)/b,_BcdMaxDecimals,this);
    return *this;
}


// Definitions of non-member binary operator functions

inline bcd _Cdecl operator+(bcd& a, bcd& b)
{
    return bcd(real(a) + real(b));
}

inline bcd _Cdecl operator+(long double a, bcd& b)
{
    return bcd(a + real(b));
}

inline bcd _Cdecl operator+(bcd& a, long double b)
{
    return bcd(real(a) + b);
}

inline bcd _Cdecl operator-(bcd& a, bcd& b)
{
    return bcd(real(a) - real(b));
}

inline bcd _Cdecl operator-(long double a, bcd& b)
{
    return bcd(a - real(b));
}

inline bcd _Cdecl operator-(bcd& a, long double b)
{
    return bcd(real(a) - b);
}

inline bcd _Cdecl operator*(bcd& a, bcd& b)
{
    return bcd(real(a) * real(b));
}

inline bcd _Cdecl operator*(bcd& a, long double b)
{
    return bcd(real(a) * b);
}

inline bcd _Cdecl operator*(long double a, bcd& b)
{
    return bcd(a * real(b));
}

inline bcd _Cdecl operator/(bcd& a, bcd& b)
{
    return bcd(real(a) / real(b));
}

inline bcd _Cdecl operator/(long double a, bcd& b)
{
    return bcd(a / real(b));
}

inline bcd _Cdecl operator/(bcd& a, long double b)
{
    return bcd(real(a) / b);
}

inline int _Cdecl operator==(bcd& a, bcd& b)
{
    return real(a) == real(b);
}

inline int _Cdecl operator!=(bcd& a, bcd& b)
{
    return real(a) != real(b);
}

inline int _Cdecl operator>=(bcd& a, bcd& b)
{
    return real(a) >= real(b);
}

inline int _Cdecl operator<=(bcd& a, bcd& b)
{
    return real(a) <= real(b);
}

inline int _Cdecl operator>(bcd& a, bcd& b)
{
    return real(a) > real(b);
}

inline int _Cdecl operator<(bcd& a, bcd& b)
{
    return real(a) < real(b);
}

inline bcd _Cdecl bcd::operator+()
{
    return *this;
}

inline bcd _Cdecl bcd::operator-()
{
//  return bcd(-real(this));

// 1's comp
    mantissa[0] = - ++ mantissa[0];
    mantissa[1] = - ++ mantissa[1];
// inc
    if (++mantissa[0] == 0) ++mantissa[1];
    return *this;
}

inline bcd _Cdecl abs(bcd& a)   { return bcd(fabs(real(a)));}
inline bcd _Cdecl acos(bcd& a)  { return bcd(acos(real(a)));}
inline bcd _Cdecl asin(bcd& a)  { return bcd(asin(real(a)));}
inline bcd _Cdecl atan(bcd& a)  { return bcd(atan(real(a)));}
inline bcd _Cdecl cos(bcd& a)   { return bcd(cos(real(a)));}
inline bcd _Cdecl cosh(bcd& a)  { return bcd(cosh(real(a)));}
inline bcd _Cdecl exp(bcd& a)   { return bcd(exp(real(a)));}
inline bcd _Cdecl log(bcd& a)   { return bcd(log(real(a)));}
inline bcd _Cdecl log10(bcd& a) { return bcd(__bcd_log10(&a));}
inline bcd _Cdecl sin(bcd& a)   { return bcd(sin(real(a)));}
inline bcd _Cdecl sinh(bcd& a)  { return bcd(sinh(real(a)));}
inline bcd _Cdecl sqrt(bcd& a)  { return bcd(sqrt(real(a)));}
inline bcd _Cdecl tan(bcd& a)   { return bcd(tan(real(a)));}
inline bcd _Cdecl tanh(bcd& a)  { return bcd(tanh(real(a)));}

inline bcd _Cdecl pow(bcd& a, bcd& b)   { return bcd(pow(real(a),real(b)));}
inline void _Cdecl pow10(int n, bcd& a) { __bcd_pow10(n,&a);}


// bcd stream I/O

ostream _FAR & pascal _FARFUNC operator<<(ostream _FAR &, bcd _FAR &);
istream _FAR & pascal _FARFUNC operator>>(istream _FAR &, bcd _FAR &);

#pragma option -Vo.
#if defined(__BCOPT__)
#pragma option -po.
#endif

#endif  // __BCD_H
/*  utime.h

    Definitions for utime() function.

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef  _TIME_T
#define  _TIME_T
typedef long time_t;
#endif

/* Structure passed to utime containing file times
 */
struct utimbuf
{
        time_t  actime;         /* access time (not used on DOS) */
        time_t  modtime;        /* modification time */
};

#ifdef __cplusplus
extern "C" {
#endif

int    _Cdecl _FARFUNC utime(char _FAR *__path, struct utimbuf _FAR *__times);

#ifdef __cplusplus
}
#endif
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
\*****************************************************************************/

#ifndef __SHELLAPI_H    /* prevent multiple includes */
#define __SHELLAPI_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define HDROP       HANDLE
#define HINSTANCE   HANDLE
#define WINAPI      FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#else
DECLARE_HANDLE(HDROP);
#endif  /* WIN3.0 */

/* return codes from Registration functions */
#define ERROR_SUCCESS           0L
#define ERROR_BADDB             1L
#define ERROR_BADKEY            2L
#define ERROR_CANTOPEN          3L
#define ERROR_CANTREAD          4L
#define ERROR_CANTWRITE         5L
#define ERROR_OUTOFMEMORY       6L
#define ERROR_INVALID_PARAMETER 7L
#define ERROR_ACCESS_DENIED     8L

#define REG_SZ                  1           /* string type */

#define HKEY_CLASSES_ROOT       1

typedef DWORD HKEY;
typedef HKEY FAR* PHKEY;

LONG WINAPI RegOpenKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCreateKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCloseKey(HKEY);
LONG WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

UINT WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL WINAPI DragQueryPoint(HDROP, POINT FAR*);
void WINAPI DragFinish(HDROP);
void WINAPI DragAcceptFiles(HWND, BOOL);

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);
HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __SHELLAPI_H */
/*  limits.h

    Defines implementation specific limits on type values.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __LIMITS_H
#define __LIMITS_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#define CHAR_BIT            8

#if ('\x80' < 0)
#define CHAR_MAX            127
#define CHAR_MIN            (-128)
#else
#define CHAR_MAX            255
#define CHAR_MIN            0
#endif

#define SCHAR_MAX           127
#define SCHAR_MIN           (-128)
#define UCHAR_MAX           255

#define SHRT_MAX            0x7FFF
#define SHRT_MIN            ((int)0x8000)
#define USHRT_MAX           0xFFFFU

#define INT_MAX             0x7FFF
#define INT_MIN             ((int)0x8000)
#define UINT_MAX            0xFFFFU

#define LONG_MAX            0x7FFFFFFFL
#define LONG_MIN            ((long)0x80000000L)
#define ULONG_MAX           0xFFFFFFFFUL

#define MB_LEN_MAX          1

#endif
PKBGI Stroked Font V1.1 - Jun 5, 1989
Copyright (c) 1987,1988 Borland International
 GOTHF                             +             : ^ r  
>ZvdF@"|Jx	

jN
Jd>`t|p6
>>~FVF.n6.6X v  f!!H"""#n###n$$%&&4'''H((4))**2++\,,,-p--...///$080L00:1l1|11246666667 7,7<7L7Z7h7r7|77777777778 848@8\8n8~88888888899r99
:@::;v;;2<<<V==>> ???D@@A4AVAjA~AAA B$BdB~BBBB,C	
		#
	         
                     		   

   }   

                              
   	   	      }            
            	               
         	                     

                    

   
        	      		     	   z{                   z      	            	      zz            	                                          zz                       y}       	   	   	   	   	   {y}   	   	   	                        	
   
                   |z      	   ~        ~   

   {
   	                      
              
                  		  		~~~~     		  		  		  		}}}}}}}}   											}}}}}}}}}}}}         y
         
         
   
   

   
      
   
   y            y
      
   
      yy
      
   y   
   

   y
   y   

   
   
         y
      y                        


       
   
      
      x       
	|      	         ~   	                     y   
                       	        /*  direct.h


    Defines structures, macros, and functions for dealing with
    directories and pathnames.

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#include <dir.h>

/* Prototypes for MSC functions */

#ifdef __cplusplus
extern "C" {
#endif

int    _Cdecl _chdrive(int __drive);
char _FAR * _Cdecl _FARFUNC _getdcwd(int __drive, char _FAR *__buf, int __len);
int    _Cdecl _getdrive(void);

#ifdef __cplusplus
}
#endif
PKBGI Stroked Font V1.1 - Jun 5, 1989
Copyright (c) 1987,1988 Borland International
 SANS4                             +  
                                                $ ( , 0 4 8 < @ D p   @<| NdRXNXt~RlDn		D	h				
J


8R0>RftPbh"f*Bjh(H(J6&`,^:.zpZF0 ~   !Z!!!!!"$
''&':'N'`'r'''''''''((&(.(:(J(Z(j(z(((((((()),):)H)V)b)r))))"*L*v**+>+V+x+++,>,,-^--0....
/0/T/x///0n00001<1d1                              



		                                                         
                        

   }    
                                      	                            
         
    
      
                               

                            y   y   y                                    

               



   

               
                                          z                                 {z                                                                                                      |                                         
                   
                                             		  		}}}}     		  		  		  		}}}}}}   						}}}}}}}}}}}}						             	                    	          	     	     		     
          
   

               y	      	   	   		   	   	   	   	y   
   	   	y   yy   		   
            	   
                          
   	                                                          |              	                                   
                                           /*  alloc.h

    memory management functions and variables.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__ALLOC_H)
#define __ALLOC_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef NULL
#include <_null.h>
#endif

#define _HEAPEMPTY      1
#define _HEAPOK         2
#define _FREEENTRY      3
#define _USEDENTRY      4
#define _HEAPEND        5
#define _HEAPCORRUPT    -1
#define _BADNODE        -2
#define _BADVALUE       -3

#ifndef _STDDEF
#define _STDDEF
#ifndef _PTRDIFF_T
#define _PTRDIFF_T
#if defined(__LARGE__) || defined(__HUGE__) || defined(__COMPACT__)
typedef long  ptrdiff_t;
#else
typedef int ptrdiff_t;
#endif
#endif
#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif
#endif

#if !__STDC__
struct farheapinfo
  {
  void huge *ptr;
  unsigned long size;
  int in_use;
  };
#endif

#if defined(__TINY__) || defined(__SMALL__) || defined(__MEDIUM__)
struct heapinfo
  {
  void _FAR *ptr;
  unsigned int size;
  int in_use;
  };
#else
#define heapinfo farheapinfo
#endif

#ifdef __cplusplus
extern "C" {
#endif

void  _FAR *_Cdecl calloc(size_t __nitems, size_t __size);
void        _Cdecl free(void _FAR *__block);
void  _FAR *_Cdecl malloc(size_t __size);
void  _FAR *_Cdecl realloc(void _FAR *__block, size_t __size);

#if !defined(_Windows)

int         _Cdecl brk(void *__addr);
void       *_Cdecl sbrk(int __incr);

int         _Cdecl heapcheck(void);
int         _Cdecl heapfillfree(unsigned int __fillvalue);
int         _Cdecl heapcheckfree(unsigned int __fillvalue);

#if defined(__COMPACT__) || defined(__LARGE__) || defined(__HUGE__)

unsigned long _Cdecl coreleft (void);

#if !__STDC__
int         _Cdecl heapchecknode(void far *__node);
int         _Cdecl heapwalk(struct farheapinfo far *__hi);
#endif

#else

unsigned    _Cdecl coreleft(void);
int         _Cdecl heapchecknode(void *__node);
int         _Cdecl heapwalk(struct heapinfo *__hi);

#endif

#endif  /* WINDOWS */

#if !defined(__STDC__)
void far  * _Cdecl farcalloc(unsigned long __nunits, unsigned long __unitsz);
unsigned long _Cdecl farcoreleft(void);
void        _Cdecl farfree(void far *__block);
void far  * _Cdecl farmalloc(unsigned long __nbytes);
void far  * _Cdecl farrealloc(void far *__oldblock, unsigned long __nbytes);
int         _Cdecl farheapcheck(void);
int         _Cdecl farheapchecknode(void far *__node);
int         _Cdecl farheapfillfree(unsigned int __fillvalue);
int         _Cdecl farheapcheckfree(unsigned int __fillvalue);
int         _Cdecl farheapwalk(struct farheapinfo *__hi);
#endif

#ifdef __cplusplus
}
#endif

#endif  /* __ALLOC_H */
/* complex.h

    Complex Number Library - Include File
    class complex:  declarations for complex numbers.

    Copyright (c) 1990, 1992 by Borland International
    All Rights Reserved.

All function names, member names, and operators have been borrowed
from AT&T C++, except for the addition of:

    friend complex _Cdecl acos(complex _FAR &);
    friend complex _Cdecl asin(complex _FAR &);
    friend complex _Cdecl atan(complex _FAR &);
    friend complex _Cdecl log10(complex _FAR &);
    friend complex _Cdecl tan(complex _FAR &);
    friend complex _Cdecl tanh(complex _FAR &);
    complex _Cdecl operator+();
    complex _Cdecl operator-();
*/

#ifndef __cplusplus
#error Must use C++ for the type complex.
#endif

#if !defined(__COMPLEX_H)
#define __COMPLEX_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(__IOSTREAM_H)
#include <iostream.h>
#endif

#if !defined(__MATH_H)
#include <math.h>
#endif

#pragma option -Vo-
#if defined(__BCOPT__) && !defined(_RTL_ALLOW_po)
#pragma option -po-
#endif

_CLASSDEF(complex)

class _CLASSTYPE complex {

public:
    // constructors
    complex(double __re_val, double __im_val=0);
    complex();

    // complex manipulations
    friend double _Cdecl _FARFUNC real(complex _FAR &);   // the real part
    friend double _Cdecl _FARFUNC imag(complex _FAR &);   // the imaginary part
    friend complex _Cdecl _FARFUNC conj(complex _FAR &);  // the complex conjugate
    friend double _Cdecl _FARFUNC norm(complex _FAR &);   // the square of the magnitude
    friend double _Cdecl _FARFUNC arg(complex _FAR &);    // the angle in the plane

    // Create a complex object given polar coordinates
    friend complex _Cdecl polar(double __mag, double __angle=0);

    // Overloaded ANSI C math functions
    friend double  _Cdecl _FARFUNC abs(complex _FAR &);
    friend complex _Cdecl _FARFUNC acos(complex _FAR &);
    friend complex _Cdecl _FARFUNC asin(complex _FAR &);
    friend complex _Cdecl _FARFUNC atan(complex _FAR &);
    friend complex _Cdecl _FARFUNC cos(complex _FAR &);
    friend complex _Cdecl _FARFUNC cosh(complex _FAR &);
    friend complex _Cdecl _FARFUNC exp(complex _FAR &);
    friend complex _Cdecl _FARFUNC log(complex _FAR &);
    friend complex _Cdecl _FARFUNC log10(complex _FAR &);
    friend complex _Cdecl _FARFUNC pow(complex _FAR & __base, double __expon);
    friend complex _Cdecl _FARFUNC pow(double __base, complex _FAR & __expon);
    friend complex _Cdecl _FARFUNC pow(complex _FAR & __base, complex _FAR & __expon);
    friend complex _Cdecl _FARFUNC sin(complex _FAR &);
    friend complex _Cdecl _FARFUNC sinh(complex _FAR &);
    friend complex _Cdecl _FARFUNC sqrt(complex _FAR &);
    friend complex _Cdecl _FARFUNC tan(complex _FAR &);
    friend complex _Cdecl _FARFUNC tanh(complex _FAR &);

    // Binary Operator Functions
    friend complex _Cdecl _FARFUNC operator+(complex _FAR &, complex _FAR &);
    friend complex _Cdecl _FARFUNC operator+(double, complex _FAR &);
    friend complex _Cdecl _FARFUNC operator+(complex _FAR &, double);
    friend complex _Cdecl _FARFUNC operator-(complex _FAR &, complex _FAR &);
    friend complex _Cdecl _FARFUNC operator-(double, complex _FAR &);
    friend complex _Cdecl _FARFUNC operator-(complex _FAR &, double);
    friend complex _Cdecl _FARFUNC operator*(complex _FAR &, complex _FAR &);
    friend complex _Cdecl _FARFUNC operator*(complex _FAR &, double);
    friend complex _Cdecl _FARFUNC operator*(double, complex _FAR &);
    friend complex _Cdecl _FARFUNC operator/(complex _FAR &, complex _FAR &);
    friend complex _Cdecl _FARFUNC operator/(complex _FAR &, double);
    friend complex _Cdecl _FARFUNC operator/(double, complex _FAR &);
    friend int _Cdecl _FARFUNC operator==(complex _FAR &, complex _FAR &);
    friend int _Cdecl _FARFUNC operator!=(complex _FAR &, complex _FAR &);
    complex _FAR & _Cdecl operator+=(complex _FAR &);
    complex _FAR & _Cdecl operator+=(double);
    complex _FAR & _Cdecl operator-=(complex _FAR &);
    complex _FAR & _Cdecl operator-=(double);
    complex _FAR & _Cdecl operator*=(complex _FAR &);
    complex _FAR & _Cdecl operator*=(double);
    complex _FAR & _Cdecl operator/=(complex _FAR &);
    complex _FAR & _Cdecl operator/=(double);
    complex _Cdecl operator+();
    complex _Cdecl operator-();

// Implementation
private:
        double re, im;
};


// Inline complex functions

inline complex::complex(double __re_val, double __im_val)
{
    re = __re_val;
    im = __im_val;
}

inline complex::complex()
{
/* if you want your complex numbers initialized ...
    re = im = 0;
*/
}

inline complex _Cdecl complex::operator+()
{
    return *this;
}

inline complex _Cdecl complex::operator-()
{
    return complex(-re, -im);
}


// Definitions of compound-assignment operator member functions

inline complex _FAR & _Cdecl complex::operator+=(complex _FAR & __z2)
{
    re += __z2.re;
    im += __z2.im;
    return *this;
}

inline complex _FAR & _Cdecl complex::operator+=(double __re_val2)
{
    re += __re_val2;
    return *this;
}

inline complex _FAR & _Cdecl complex::operator-=(complex _FAR & __z2)
{
    re -= __z2.re;
    im -= __z2.im;
    return *this;
}

inline complex _FAR & _Cdecl complex::operator-=(double __re_val2)
{
    re -= __re_val2;
    return *this;
}

inline complex _FAR & _Cdecl complex::operator*=(double __re_val2)
{
    re *= __re_val2;
    im *= __re_val2;
    return *this;
}

inline complex _FAR & _Cdecl complex::operator/=(double __re_val2)
{
    re /= __re_val2;
    im /= __re_val2;
    return *this;
}


// Definitions of non-member complex functions

inline double _Cdecl real(complex _FAR & __z)
{
    return __z.re;
}

inline double _Cdecl imag(complex _FAR & __z)
{
    return __z.im;
}

inline complex _Cdecl conj(complex _FAR & __z)
{
    return complex(__z.re, -__z.im);
}

inline complex _Cdecl polar(double __mag, double __angle)
{
    return complex(__mag*cos(__angle), __mag*sin(__angle));
}


// Definitions of non-member binary operator functions

inline complex _Cdecl operator+(complex _FAR & __z1, complex _FAR & __z2)
{
    return complex(__z1.re + __z2.re, __z1.im + __z2.im);
}

inline complex _Cdecl operator+(double __re_val1, complex _FAR & __z2)
{
    return complex(__re_val1 + __z2.re, __z2.im);
}

inline complex _Cdecl operator+(complex _FAR & __z1, double __re_val2)
{
    return complex(__z1.re + __re_val2, __z1.im);
}

inline complex _Cdecl operator-(complex _FAR & __z1, complex _FAR & __z2)
{
    return complex(__z1.re - __z2.re, __z1.im - __z2.im);
}

inline complex _Cdecl operator-(double __re_val1, complex _FAR & __z2)
{
    return complex(__re_val1 - __z2.re, -__z2.im);
}

inline complex _Cdecl operator-(complex _FAR & __z1, double __re_val2)
{
    return complex(__z1.re - __re_val2, __z1.im);
}

inline complex _Cdecl operator*(complex _FAR & __z1, double __re_val2)
{
    return complex(__z1.re*__re_val2, __z1.im*__re_val2);
}

inline complex _Cdecl operator*(double __re_val1, complex _FAR & __z2)
{
    return complex(__z2.re*__re_val1, __z2.im*__re_val1);
}

inline complex _Cdecl operator/(complex _FAR & __z1, double __re_val2)
{
    return complex(__z1.re/__re_val2, __z1.im/__re_val2);
}

inline int _Cdecl operator==(complex _FAR & __z1, complex _FAR & __z2)
{
    return __z1.re == __z2.re && __z1.im == __z2.im;
}

inline int _Cdecl operator!=(complex _FAR & __z1, complex _FAR & __z2)
{
    return __z1.re != __z2.re || __z1.im != __z2.im;
}


// Complex stream I/O

ostream _FAR & _Cdecl _FARFUNC operator<<(ostream _FAR &, complex _FAR &);
istream _FAR & _Cdecl _FARFUNC operator>>(istream _FAR &, complex _FAR &);

#pragma option -Vo.
#if defined(__BCOPT__)
#pragma option -po.
#endif

#endif  // __COMPLEX_H
/*  conio.h

    Direct MSDOS console input/output.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__CONIO_H)
#define __CONIO_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(_Windows)

#define _NOCURSOR      0
#define _SOLIDCURSOR   1
#define _NORMALCURSOR  2

struct text_info {
    unsigned char winleft;
    unsigned char wintop;
    unsigned char winright;
    unsigned char winbottom;
    unsigned char attribute;
    unsigned char normattr;
    unsigned char currmode;
    unsigned char screenheight;
    unsigned char screenwidth;
    unsigned char curx;
    unsigned char cury;
};

enum text_modes { LASTMODE=-1, BW40=0, C40, BW80, C80, MONO=7, C4350=64 };

#if !defined(__COLORS)
#define __COLORS

enum COLORS {
    BLACK,          /* dark colors */
    BLUE,
    GREEN,
    CYAN,
    RED,
    MAGENTA,
    BROWN,
    LIGHTGRAY,
    DARKGRAY,       /* light colors */
    LIGHTBLUE,
    LIGHTGREEN,
    LIGHTCYAN,
    LIGHTRED,
    LIGHTMAGENTA,
    YELLOW,
    WHITE
};
#endif

#define BLINK       128 /* blink bit */

extern   int _Cdecl directvideo;
extern   int _Cdecl _wscroll;

#endif   /* !_Windows */

#ifdef __cplusplus
extern "C" {
#endif

void        _Cdecl clreol( void );
void        _Cdecl clrscr( void );
void        _Cdecl gotoxy( int __x, int __y );
int         _Cdecl wherex( void );
int         _Cdecl wherey( void );
int         _Cdecl getch( void );
int         _Cdecl getche( void );
int         _Cdecl kbhit( void );
int         _Cdecl putch( int __c );

#ifndef _PORT_DEFS
unsigned char   _Cdecl inportb( unsigned __portid );
unsigned        _Cdecl inport ( unsigned __portid );
int             _Cdecl inp( unsigned __portid );
unsigned        _Cdecl inpw( unsigned __portid );
void            _Cdecl outportb( unsigned __portid, unsigned char __value );
void            _Cdecl outport ( unsigned __portid, unsigned __value );
int             _Cdecl outp( unsigned __portid, int __value );
unsigned        _Cdecl outpw( unsigned __portid, unsigned __value );
#endif  /* !_PORT_DEFS */

#if !defined(_Windows)

void        _Cdecl delline( void );
int         _Cdecl gettext( int __left, int __top,
                            int __right, int __bottom,
                            void *__destin);
void        _Cdecl gettextinfo (struct text_info *__r );
void        _Cdecl highvideo( void );
void        _Cdecl insline( void );
void        _Cdecl lowvideo( void );
int         _Cdecl movetext( int __left, int __top,
                             int __right, int __bottom,
                             int __destleft, int __desttop );
void        _Cdecl normvideo( void );
int         _Cdecl puttext( int __left, int __top,
                            int __right, int __bottom,
                            void *__source );
void        _Cdecl textattr( int __newattr );
void        _Cdecl textbackground( int __newcolor );
void        _Cdecl textcolor( int __newcolor );
void        _Cdecl textmode( int __newmode );
void        _Cdecl window( int __left, int __top, int __right, int __bottom);

void        _Cdecl _setcursortype( int __cur_t );
char * _Cdecl cgets( char *__str );
int         _Cdecl cprintf( const char *__format, ... );
int         _Cdecl cputs( const char *__str );
int         _Cdecl cscanf( const char *__format, ... );
char * _Cdecl getpass( const char *__prompt );
int         _Cdecl ungetch( int __ch );

#endif  /* !_Windows */

#ifndef _PORT_DEFS
#define _PORT_DEFS

    /* These are in-line functions.  These prototypes just clean up
       some syntax checks and code generation.
     */
unsigned char   _Cdecl  __inportb__ (unsigned __portid);
unsigned        _Cdecl  __inportw__ (unsigned __portid);
unsigned char   _Cdecl  __outportb__(unsigned __portid, unsigned char __value);
unsigned        _Cdecl  __outportw__(unsigned __portid, unsigned __value);

#define inportb(__portid)           __inportb__(__portid)
#define outportb(__portid, __value) ((void) __outportb__(__portid, __value))
#define inport(__portid)            __inportw__(__portid)
#define outport(__portid, __value)  ((void) __outportw__(__portid, __value))

/* MSC-compatible macros for port I/O */
#define inp(__portid)               __inportb__ (__portid)
#define outp(__portid, __value)     __outportb__(__portid, (unsigned char)__value)
#define inpw(__portid)              __inportw__ (__portid)
#define outpw(__portid, __value)    __outportw__(__portid, __value)

#endif  /* _PORT_DEFS */

#ifdef __cplusplus
}
#endif


#endif  /* __CONIO_H */
pkBGI Device Driver (EGAVGA) 2.00 - Mar 21 1988
Copyright (c) 1987,1988 Borland International
                         EGAVGA               U ]CB      _=      ,R{?     r                 ï         ø 2˴ . .  $.X f&CC&CC<s
2"tW2e"y@t2ۈ>Y2Ê2ʸð                                <u &GC72W ؊2sêuQ YË&^؋`Ë?P!ZË>  t!  89:;<=>?                    ?<t  > t  U"t<t> t                          640 x 200 EGA 640 x 350 EGA 640 x 480 VGA 640 X 350 EGA MONO     (#X  ]](#XF  (#X'  ]](#XF#-;4&$YUs2>Y22۴3}<ur<u>Ut2tÀtu
r 2@r  U2pX %>u%VáZ\Z\QRȋӇZ\ ZYË6V>W<r,2ྐ7 <t27           >cuK&"t*SQZ\Y[^>cu\KZC"x-b&c ^ `SQV.Y[ x<t
2؋    ]      (   .>(t߱..ú (  +  ]]
`	 P <u? <t<u@  &$`u> 2á&  .> tS<r2.[PRBJZXR2.> t Z.>X tPRZXÖV>RQSP 
U BFJBv
+vyFF
FFFFދFVʀB^+^x{;rGA++ފ*.s
#y*P̃ 
sG* A++.s%#yȃ Pz;rFA++ފ*.s
#y*Pă 
sO*.A++.s%#y PHJB*]   ;r;rڋ7+BSދQY+[PVQS^[Êz[Êr]WSW _[?r7>uͺSߊ I Y"ي"&"2&Gð:uQW2_Y&G?@            @8px<iZ-KB$$B3333     "  "                              8l  ||    |~  x00000x |     ||  || x`0x 000000 | l8  l8l f< 0` <00000< `0 <<  8l           00       |~~    |~ ~v   |~ 0|0000   ~v|  8<  8 8<         ||     ~v  np```   || 00|000   ~   l8   l   l8l   v|  0` &"uÈ"u- - ;|>+>;s;|>+>;sSQf _^.V...WP X_.>uE.un&^  .=Àt%"yGuNu<0uO2<Ar<{r2<r#  |  &&Wt n  > tA&F &^&N&V ֖MuڽS	ؠ 	&2Ë> t	&&[&CS>U uWU]_& 	6	 		W.> u&$FP_GMuXXô2==&$"u=FP                                                     @                      ++B5QS_[H.zQRV; ^ZYu.6.5uSU[ìଊ#t	&%GJ"&%G  +B5Sދ+â@[PVQS^[ .z[ .r ]SQUW  _]Y[u.>.5u݋S[SM2#t".>u&%&G嬊Mض."*:Z}%R.>u&%&ZG2"ں.>u&%&ÃRPXZ  SR.2.Z[S2.[ 
R&&Zñ*˺2&="
}> t tÀtNyO> ty׋ںӻ013
xo&
  RMMF +MMF   MMv 	 `MM~ Z&"u2([N EEu&
Ë~ EEv EE^ EESP  Xtu>	 u s9 ' r/ F 뉡@;uH9~@9áH;t2á9s+>;t>2;6t &"u׊&;6tpFu2G> t׋ںӻ6,)V&"u<׊&;6},Fu2G> t׋ںӻ"u
 N6&= tÀ> uCR$ 3ɡW&= u;sGA_t 2ZRB> tZR&= u;6s G
 uݺB+&&%-&&%UVB+͋-͋͋^]ðRZ);6rmFu2G> tgŁt &"tu28*t80t8/t
	&ŀu׊׊Ћں&"%ӻurMMF MMv MM~ MMN _
]&= u9RB&= u;sG> t
 uްJZÉ6>Ë6>> ttà<tzQR+3ҋ5A2ڋW>uՊ+-2;1u;3u/
&*"2ЈCuZY> t RWV*"GGG+s Cu^_ZÀ>t>s]>s  - ++RBB
> tZRPBX> t ZRBZôR
 uBZÀuSQP252
C"u2XY[#if !defined( __WINDOWS_H )
#define __WINDOWS_H

/****************************************************************************/
/*                                                                          */
/*  WINDOWS.H -                                                             */
/*                                                                          */
/*      Include file for Windows 3.0 applications                           */
/*                                                                          */
/****************************************************************************/

#ifndef RC_INVOKED
#pragma option -a-
#pragma warn -bbf
#endif

#if defined( __cplusplus )
extern "C" {
#endif  /* __cplusplus */

/*  If defined, the following flags inhibit definition
 *     of the indicated items.
 *
 *  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_
 *  NOVIRTUALKEYCODES - VK_*
 *  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*
 *  NOWINSTYLES       - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
 *  NOSYSMETRICS      - SM_*
 *  NOMENUS           - MF_*
 *  NOICONS           - IDI_*
 *  NOKEYSTATES       - MK_*
 *  NOSYSCOMMANDS     - SC_*
 *  NORASTEROPS       - Binary and Tertiary raster ops
 *  NOSHOWWINDOW      - SW_*
 *  OEMRESOURCE       - OEM Resource values
 *  NOATOM            - Atom Manager routines
 *  NOCLIPBOARD       - Clipboard routines
 *  NOCOLOR           - Screen colors
 *  NOCTLMGR          - Control and Dialog routines
 *  NODRAWTEXT        - DrawText() and DT_*
 *  NOGDI             - All GDI defines and routines
 *  NOKERNEL          - All KERNEL defines and routines
 *  NOUSER            - All USER defines and routines
 *  NOMB              - MB_* and MessageBox()
 *  NOMEMMGR          - GMEM_*, LMEM_*, GHND, LHND, associated routines
 *  NOMETAFILE        - typedef METAFILEPICT
 *  NOMINMAX          - Macros min(a,b) and max(a,b)
 *  NOMSG             - typedef MSG and associated routines
 *  NOOPENFILE        - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
 *  NOSCROLL          - SB_* and scrolling routines
 *  NOSOUND           - Sound driver routines
 *  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines
 *  NOWH              - SetWindowsHook and WH_*
 *  NOWINOFFSETS      - GWL_*, GCL_*, associated routines
 *  NOCOMM            - COMM driver routines
 *  NOKANJI           - Kanji support stuff.
 *  NOHELP            - Help engine interface.
 *  NOPROFILER        - Profiler interface.
 *  NODEFERWINDOWPOS  - DeferWindowPos routines
 */

#ifdef RC_INVOKED

/* Turn off a bunch of stuff to ensure that RC files compile OK. */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI

#endif /* RC_INVOKED */


/*--------------------------------------------------------------------------*/
/*  General Purpose Defines                                                 */
/*--------------------------------------------------------------------------*/

#ifndef NULL
#if defined(__TINY__) || defined(__SMALL__) || defined(__MEDIUM__)
#define NULL  0
#else
#define NULL  0L
#endif
#endif

#define FALSE               0
#define TRUE                1

#define FAR                 far
#define NEAR                near
#define LONG                long
#define VOID                void
#define PASCAL              pascal

#if !defined( NOMINMAX ) && !defined( __cplusplus )

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif  /* NOMINMAX */

#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | (((DWORD)((WORD)(b))) << 16)))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)((DWORD)(l) >> 16))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)((WORD)(w) >> 8))

typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned int        WORD;
typedef unsigned long       DWORD;
typedef char near           *PSTR;
typedef char near           *NPSTR;
typedef char far            *LPSTR;
typedef BYTE near           *PBYTE;
typedef BYTE far            *LPBYTE;
typedef int near            *PINT;
typedef int far             *LPINT;
typedef WORD near           *PWORD;
typedef WORD far            *LPWORD;
typedef long near           *PLONG;
typedef long far            *LPLONG;
typedef DWORD near          *PDWORD;
typedef DWORD far           *LPDWORD;
typedef void far            *LPVOID;

#ifndef WIN_INTERNAL
typedef WORD                HANDLE;
typedef HANDLE              HWND;
#endif

typedef HANDLE              *PHANDLE;
typedef HANDLE NEAR         *SPHANDLE;
typedef HANDLE FAR          *LPHANDLE;
typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;
typedef int (FAR PASCAL *FARPROC)();
typedef int (NEAR PASCAL *NEARPROC)();

typedef HANDLE              HSTR;
typedef HANDLE              HICON;
typedef HANDLE              HDC;
typedef HANDLE              HMENU;
typedef HANDLE              HPEN;
typedef HANDLE              HFONT;
typedef HANDLE              HBRUSH;
typedef HANDLE              HBITMAP;
typedef HANDLE              HCURSOR;
typedef HANDLE              HRGN;
typedef HANDLE              HPALETTE;

typedef DWORD               COLORREF;

#ifndef WIN_INTERNAL
typedef struct tagRECT
  {
    int         left;
    int         top;
    int         right;
    int         bottom;
  } RECT;
#endif

typedef RECT                *PRECT;
typedef RECT NEAR           *NPRECT;
typedef RECT FAR            *LPRECT;

typedef struct tagPOINT
  {
    int         x;
    int         y;
  } POINT;
typedef POINT               *PPOINT;
typedef POINT NEAR          *NPPOINT;
typedef POINT FAR           *LPPOINT;


/*--------------------------------------------------------------------------*/
/*  KERNEL Section                                                          */
/*--------------------------------------------------------------------------*/

#ifndef NOKERNEL

/* Loader Routines */
WORD    FAR PASCAL GetVersion(void);
WORD    FAR PASCAL GetNumTasks(void);
HANDLE  FAR PASCAL GetCodeHandle(FARPROC);
void    FAR PASCAL GetCodeInfo(FARPROC lpProc, LPVOID lpSegInfo);
HANDLE  FAR PASCAL GetModuleHandle(LPSTR);
int     FAR PASCAL GetModuleUsage(HANDLE);
int     FAR PASCAL GetModuleFileName(HANDLE, LPSTR, int);
int     FAR PASCAL GetInstanceData(HANDLE, NPSTR, int);
FARPROC FAR PASCAL GetProcAddress(HANDLE, LPSTR);
FARPROC FAR PASCAL MakeProcInstance(FARPROC, HANDLE);
void    FAR PASCAL FreeProcInstance(FARPROC);
HANDLE  FAR PASCAL LoadLibrary(LPSTR);
HANDLE  FAR PASCAL LoadModule(LPSTR, LPVOID);
BOOL    FAR PASCAL FreeModule(HANDLE);
void    FAR PASCAL FreeLibrary(HANDLE);
DWORD   FAR PASCAL GetFreeSpace(WORD);
WORD    FAR PASCAL WinExec(LPSTR, WORD);
void    FAR PASCAL DebugBreak(void);
void    FAR PASCAL OutputDebugString(LPSTR);
void    FAR PASCAL SwitchStackBack(void);
void    FAR PASCAL SwitchStackTo(WORD, WORD, WORD);
WORD    FAR PASCAL GetCurrentPDB(void);

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
  {
    BYTE        cBytes;
    BYTE        fFixedDisk;
    WORD        nErrCode;
    BYTE        reserved[4];
    BYTE        szPathName[128];
  } OFSTRUCT;
typedef OFSTRUCT            *POFSTRUCT;
typedef OFSTRUCT NEAR       *NPOFSTRUCT;
typedef OFSTRUCT FAR        *LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

int  FAR PASCAL OpenFile(LPSTR, LPOFSTRUCT, WORD);

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE       (BYTE)0x80

BYTE FAR PASCAL GetTempDrive(BYTE);
int  FAR PASCAL GetTempFileName(BYTE, LPSTR, WORD, LPSTR);
WORD FAR PASCAL SetHandleCount(WORD);

WORD FAR PASCAL GetDriveType(int);
/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4

#endif /* NOOPENFILE */

#ifndef NOMEMMGR

/* Global Memory Flags */
#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h) GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HANDLE FAR PASCAL GlobalAlloc(WORD, DWORD);
DWORD  FAR PASCAL GlobalCompact(DWORD);
HANDLE FAR PASCAL GlobalFree(HANDLE);
DWORD  FAR PASCAL GlobalHandle(WORD);
LPSTR  FAR PASCAL GlobalLock(HANDLE);
HANDLE FAR PASCAL GlobalReAlloc(HANDLE, DWORD, WORD);
DWORD  FAR PASCAL GlobalSize(HANDLE);
BOOL   FAR PASCAL GlobalUnlock(HANDLE);
WORD   FAR PASCAL GlobalFlags(HANDLE);
LPSTR  FAR PASCAL GlobalWire(HANDLE);
BOOL   FAR PASCAL GlobalUnWire(HANDLE);
BOOL   FAR PASCAL GlobalUnlock(HANDLE);
HANDLE FAR PASCAL GlobalLRUNewest(HANDLE);
HANDLE FAR PASCAL GlobalLRUOldest(HANDLE);
VOID   FAR PASCAL GlobalNotify(FARPROC);
WORD   FAR PASCAL GlobalPageLock(HANDLE);
WORD   FAR PASCAL GlobalPageUnlock(HANDLE);
VOID   FAR PASCAL GlobalFix(HANDLE);
BOOL   FAR PASCAL GlobalUnfix(HANDLE);
DWORD  FAR PASCAL GlobalDosAlloc(DWORD);
WORD   FAR PASCAL GlobalDosFree(WORD);

/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED      0x4000
#define GMEM_LOCKCOUNT      0x00FF

#define LockData(dummy)     LockSegment(0xFFFF)
#define UnlockData(dummy)   UnlockSegment(0xFFFF)

HANDLE FAR PASCAL LockSegment(WORD);
HANDLE FAR PASCAL UnlockSegment(WORD);

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

#define LNOTIFY_OUTOFMEM    0
#define LNOTIFY_MOVE        1
#define LNOTIFY_DISCARD     2

#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)

HANDLE  FAR PASCAL LocalAlloc(WORD, WORD);
WORD    FAR PASCAL LocalCompact(WORD);
HANDLE  FAR PASCAL LocalFree(HANDLE);
HANDLE  FAR PASCAL LocalHandle(WORD);
BOOL    FAR PASCAL LocalInit( WORD, WORD, WORD);
char NEAR * FAR PASCAL LocalLock(HANDLE);
FARPROC FAR PASCAL LocalNotify(FARPROC);
HANDLE  FAR PASCAL LocalReAlloc(HANDLE, WORD, WORD);
WORD    FAR PASCAL LocalSize(HANDLE);
BOOL    FAR PASCAL LocalUnlock(HANDLE);
WORD    FAR PASCAL LocalFlags(HANDLE);
WORD    FAR PASCAL LocalShrink(HANDLE, WORD);

/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED      0x4000
#define LMEM_LOCKCOUNT      0x00FF

#endif /* NOMEMMGR */

LONG   FAR PASCAL SetSwapAreaSize(WORD);
LPSTR  FAR PASCAL ValidateFreeSpaces(void);
VOID   FAR PASCAL LimitEmsPages(DWORD);
BOOL   FAR PASCAL SetErrorMode(WORD);
VOID   FAR PASCAL ValidateCodeSegments(void);

LPSTR  FAR PASCAL GetDOSEnvironment(void);

WORD   FAR PASCAL AllocDStoCSAlias(WORD);
WORD   FAR PASCAL AllocSelector(WORD);
WORD   FAR PASCAL ChangeSelector(WORD, WORD);
WORD   FAR PASCAL FreeSelector(WORD);

#define UnlockResource(h)   GlobalUnlock(h)

HANDLE FAR PASCAL FindResource(HANDLE, LPSTR, LPSTR);
HANDLE FAR PASCAL LoadResource(HANDLE, HANDLE);
BOOL   FAR PASCAL FreeResource(HANDLE);
LPSTR  FAR PASCAL LockResource(HANDLE);
FARPROC FAR PASCAL SetResourceHandler(HANDLE, LPSTR, FARPROC);
HANDLE FAR PASCAL AllocResource(HANDLE, HANDLE, DWORD);
WORD   FAR PASCAL SizeofResource(HANDLE, HANDLE);
int    FAR PASCAL AccessResource(HANDLE, HANDLE);

#define MAKEINTRESOURCE(i)  (LPSTR)((DWORD)((WORD)(i)))

#ifndef NORESOURCE


/* Predefined Resource Types */
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)



#endif /* NORESOURCE */

void   FAR PASCAL Yield(void);
HANDLE FAR PASCAL GetCurrentTask(void);

#ifndef NOATOM
typedef WORD                ATOM;

#define MAKEINTATOM(i)      (LPSTR)((DWORD)((WORD)(i)))

BOOL   FAR PASCAL InitAtomTable(int);
ATOM   FAR PASCAL AddAtom(LPSTR);
ATOM   FAR PASCAL DeleteAtom(ATOM);
ATOM   FAR PASCAL FindAtom(LPSTR);
WORD   FAR PASCAL GetAtomName(ATOM, LPSTR, int);
ATOM   FAR PASCAL GlobalAddAtom(LPSTR);
ATOM   FAR PASCAL GlobalDeleteAtom(ATOM);
ATOM   FAR PASCAL GlobalFindAtom(LPSTR);
WORD   FAR PASCAL GlobalGetAtomName(ATOM, LPSTR, int);
HANDLE FAR PASCAL GetAtomHandle(ATOM);

#endif /* NOATOM */

/* User Profile Routines */
WORD FAR PASCAL GetProfileInt(LPSTR, LPSTR, int);
int  FAR PASCAL GetProfileString(LPSTR, LPSTR, LPSTR, LPSTR, int);
BOOL FAR PASCAL WriteProfileString(LPSTR, LPSTR, LPSTR);
WORD FAR PASCAL GetPrivateProfileInt(LPSTR, LPSTR, int, LPSTR);
int  FAR PASCAL GetPrivateProfileString(LPSTR, LPSTR, LPSTR, LPSTR, int, LPSTR);
BOOL FAR PASCAL WritePrivateProfileString(LPSTR, LPSTR, LPSTR, LPSTR);

WORD FAR PASCAL GetWindowsDirectory(LPSTR,WORD);
WORD FAR PASCAL GetSystemDirectory(LPSTR,WORD);

/* Catch() and Throw() */
typedef int                 CATCHBUF[9];
typedef int FAR             *LPCATCHBUF;

int  FAR PASCAL Catch(LPCATCHBUF);
void FAR PASCAL Throw(LPCATCHBUF, int);

void FAR PASCAL FatalAppExit(int, LPSTR);
void FAR PASCAL FatalExit(int);

void FAR PASCAL SwapRecording(WORD);

/* Character Translation Routines */
int   FAR PASCAL AnsiToOem(LPSTR, LPSTR);
BOOL  FAR PASCAL OemToAnsi(LPSTR, LPSTR);
void  FAR PASCAL AnsiToOemBuff(LPSTR, LPSTR, int);
void  FAR PASCAL OemToAnsiBuff(LPSTR, LPSTR, int);
LPSTR FAR PASCAL AnsiUpper(LPSTR);
WORD  FAR PASCAL AnsiUpperBuff(LPSTR, WORD);
LPSTR FAR PASCAL AnsiLower(LPSTR);
WORD  FAR PASCAL AnsiLowerBuff(LPSTR, WORD);
LPSTR FAR PASCAL AnsiNext(LPSTR);
LPSTR FAR PASCAL AnsiPrev(LPSTR, LPSTR);

/* Keyboard Information Routines */
#ifndef NOKEYBOARDINFO
DWORD FAR PASCAL OemKeyScan(WORD);
WORD  FAR PASCAL VkKeyScan(WORD);
int   FAR PASCAL GetKeyboardType(int);
WORD  FAR PASCAL MapVirtualKey(WORD, WORD);
int   FAR PASCAL GetKBCodePage();
int   FAR PASCAL GetKeyNameText(LONG, LPSTR, int);
int   FAR PASCAL ToAscii(WORD wVirtKey, WORD wScanCode, LPSTR lpKeyState, LPVOID lpChar, WORD wFlags);
#endif

#ifndef  NOLANGUAGE
/* Language dependent Routines */
BOOL  FAR  PASCAL IsCharAlpha(char);
BOOL  FAR  PASCAL IsCharAlphaNumeric(char);
BOOL  FAR  PASCAL IsCharUpper(char);
BOOL  FAR  PASCAL IsCharLower(char);
#endif

LONG FAR PASCAL GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#define WF_LARGEFRAME   0x0100
#define WF_SMALLFRAME   0x0200
#define WF_80x87        0x0400

/* WEP fSystemExit flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL    0


#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640
#define OCR_ICON            32641
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647

#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516

#endif /* OEMRESOURCE */

#endif /* NOKERNEL */


/*--------------------------------------------------------------------------*/
/*  GDI Section                                                             */
/*--------------------------------------------------------------------------*/

#ifndef NOGDI

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1   /*  0       */
#define R2_NOTMERGEPEN      2   /* DPon     */
#define R2_MASKNOTPEN       3   /* DPna     */
#define R2_NOTCOPYPEN       4   /* PN       */
#define R2_MASKPENNOT       5   /* PDna     */
#define R2_NOT              6   /* Dn       */
#define R2_XORPEN           7   /* DPx      */
#define R2_NOTMASKPEN       8   /* DPan     */
#define R2_MASKPEN          9   /* DPa      */
#define R2_NOTXORPEN        10  /* DPxn     */
#define R2_NOP              11  /* D        */
#define R2_MERGENOTPEN      12  /* DPno     */
#define R2_COPYPEN          13  /* P        */
#define R2_MERGEPENNOT      14  /* PDno     */
#define R2_MERGEPEN         15  /* DPo      */
#define R2_WHITE            16  /*  1       */

/*  Ternary raster operations */
#define SRCCOPY             (DWORD)0x00CC0020UL /* dest = source                   */
#define SRCPAINT            (DWORD)0x00EE0086UL /* dest = source OR dest           */
#define SRCAND              (DWORD)0x008800C6UL /* dest = source AND dest          */
#define SRCINVERT           (DWORD)0x00660046UL /* dest = source XOR dest          */
#define SRCERASE            (DWORD)0x00440328UL /* dest = source AND (NOT dest )   */
#define NOTSRCCOPY          (DWORD)0x00330008UL /* dest = (NOT source)             */
#define NOTSRCERASE         (DWORD)0x001100A6UL /* dest = (NOT src) AND (NOT dest) */
#define MERGECOPY           (DWORD)0x00C000CAUL /* dest = (source AND pattern)     */
#define MERGEPAINT          (DWORD)0x00BB0226UL /* dest = (NOT source) OR dest     */
#define PATCOPY             (DWORD)0x00F00021UL /* dest = pattern                  */
#define PATPAINT            (DWORD)0x00FB0A09UL /* dest = DPSnoo                   */
#define PATINVERT           (DWORD)0x005A0049UL /* dest = pattern XOR dest         */
#define DSTINVERT           (DWORD)0x00550009UL /* dest = (NOT dest)               */
#define BLACKNESS           (DWORD)0x00000042UL /* dest = BLACK                    */
#define WHITENESS           (DWORD)0x00FF0062UL /* dest = WHITE                    */

#endif /* NORASTEROPS */

/* StretchBlt() Modes */
#define BLACKONWHITE                 1
#define WHITEONBLACK                 2
#define COLORONCOLOR                 3

/* PolyFill() Modes */
#define ALTERNATE                    1
#define WINDING                      2

/* Text Alignment Options */
#define TA_NOUPDATECP                0
#define TA_UPDATECP                  1

#define TA_LEFT                      0
#define TA_RIGHT                     2
#define TA_CENTER                    6

#define TA_TOP                       0
#define TA_BOTTOM                    8
#define TA_BASELINE                  24

#define ETO_GRAYED                   1
#define ETO_OPAQUE                   2
#define ETO_CLIPPED                  4

#define ASPECT_FILTERING             0x0001

#ifndef NOMETAFILE

/* Metafile Functions */
#define META_SETBKCOLOR              0x0201
#define META_SETBKMODE               0x0102
#define META_SETMAPMODE              0x0103
#define META_SETROP2                 0x0104
#define META_SETRELABS               0x0105
#define META_SETPOLYFILLMODE         0x0106
#define META_SETSTRETCHBLTMODE       0x0107
#define META_SETTEXTCHAREXTRA        0x0108
#define META_SETTEXTCOLOR            0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG            0x020B
#define META_SETWINDOWEXT            0x020C
#define META_SETVIEWPORTORG          0x020D
#define META_SETVIEWPORTEXT          0x020E
#define META_OFFSETWINDOWORG         0x020F
#define META_SCALEWINDOWEXT          0x0400
#define META_OFFSETVIEWPORTORG       0x0211
#define META_SCALEVIEWPORTEXT        0x0412
#define META_LINETO                  0x0213
#define META_MOVETO                  0x0214
#define META_EXCLUDECLIPRECT         0x0415
#define META_INTERSECTCLIPRECT       0x0416
#define META_ARC                     0x0817
#define META_ELLIPSE                 0x0418
#define META_FLOODFILL               0x0419
#define META_PIE                     0x081A
#define META_RECTANGLE               0x041B
#define META_ROUNDRECT               0x061C
#define META_PATBLT                  0x061D
#define META_SAVEDC                  0x001E
#define META_SETPIXEL                0x041F
#define META_OFFSETCLIPRGN           0x0220
#define META_TEXTOUT                 0x0521
#define META_BITBLT                  0x0922
#define META_STRETCHBLT              0x0B23
#define META_POLYGON                 0x0324
#define META_POLYLINE                0x0325
#define META_ESCAPE                  0x0626
#define META_RESTOREDC               0x0127
#define META_FILLREGION              0x0228
#define META_FRAMEREGION             0x0429
#define META_INVERTREGION            0x012A
#define META_PAINTREGION             0x012B
#define META_SELECTCLIPREGION        0x012C
#define META_SELECTOBJECT            0x012D
#define META_SETTEXTALIGN            0x012E
#define META_DRAWTEXT                0x062F

#define META_CHORD                   0x0830
#define META_SETMAPPERFLAGS          0x0231
#define META_EXTTEXTOUT              0x0a32
#define META_SETDIBTODEV             0x0d33
#define META_SELECTPALETTE           0x0234
#define META_REALIZEPALETTE          0x0035
#define META_ANIMATEPALETTE          0x0436
#define META_SETPALENTRIES           0x0037
#define META_POLYPOLYGON             0x0538
#define META_RESIZEPALETTE           0x0139

#define META_DIBBITBLT               0x0940
#define META_DIBSTRETCHBLT           0x0b41
#define META_DIBCREATEPATTERNBRUSH   0x0142
#define META_STRETCHDIB              0x0f43

#define META_DELETEOBJECT            0x01f0

#define META_CREATEPALETTE           0x00f7
#define META_CREATEBRUSH             0x00F8
#define META_CREATEPATTERNBRUSH      0x01F9
#define META_CREATEPENINDIRECT       0x02FA
#define META_CREATEFONTINDIRECT      0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP            0x06FE
#define META_CREATEREGION            0x06FF

#endif /* NOMETAFILE */

/* GDI Escapes */
#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETABORTPROC                 9
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETENDCAP                    21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772

#define STRETCHBLT                   2048
#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109
#define SET_MIRROR_MODE              4110

/* Spooler Error Codes */
#define SP_NOTREPORTED               0x4000
#define SP_ERROR                     (-1)
#define SP_APPABORT                  (-2)
#define SP_USERABORT                 (-3)
#define SP_OUTOFDISK                 (-4)
#define SP_OUTOFMEMORY               (-5)

#define PR_JOBSTATUS                 0x0000

/* Object Definitions for EnumObjects() */
#define OBJ_PEN                      1
#define OBJ_BRUSH                    2

/* Bitmap Header Definition */
typedef struct tagBITMAP
  {
    int         bmType;
    int         bmWidth;
    int         bmHeight;
    int         bmWidthBytes;
    BYTE        bmPlanes;
    BYTE        bmBitsPixel;
    LPSTR       bmBits;
  } BITMAP;
typedef BITMAP              *PBITMAP;
typedef BITMAP NEAR         *NPBITMAP;
typedef BITMAP FAR          *LPBITMAP;

typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER {
        DWORD   bcSize;                 /* used to get to color table */
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR *LPBITMAPCOREHEADER;
typedef BITMAPCOREHEADER *PBITMAPCOREHEADER;


typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        DWORD      biWidth;
        DWORD      biHeight;
        WORD       biPlanes;
        WORD       biBitCount;

        DWORD      biCompression;
        DWORD      biSizeImage;
        DWORD      biXPelsPerMeter;
        DWORD      biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER;

typedef BITMAPINFOHEADER FAR *LPBITMAPINFOHEADER;
typedef BITMAPINFOHEADER *PBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO FAR *LPBITMAPINFO;
typedef BITMAPINFO *PBITMAPINFO;

typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO FAR *LPBITMAPCOREINFO;
typedef BITMAPCOREINFO *PBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR *LPBITMAPFILEHEADER;
typedef BITMAPFILEHEADER *PBITMAPFILEHEADER;


#define MAKEPOINT(l)        (*((POINT FAR *)&(l)))

#ifndef NOMETAFILE

/* Clipboard Metafile Picture Structure */
typedef struct tagHANDLETABLE
  {
    HANDLE      objectHandle[1];
  } HANDLETABLE;
typedef HANDLETABLE         *PHANDLETABLE;
typedef HANDLETABLE FAR     *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
  } METARECORD;
typedef METARECORD          *PMETARECORD;
typedef METARECORD FAR      *LPMETARECORD;

typedef struct tagMETAFILEPICT
  {
    int         mm;
    int         xExt;
    int         yExt;
    HANDLE      hMF;
  } METAFILEPICT;
typedef METAFILEPICT FAR    *LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
} METAHEADER;

#endif /* NOMETAFILE */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
  {
    int         tmHeight;
    int         tmAscent;
    int         tmDescent;
    int         tmInternalLeading;
    int         tmExternalLeading;
    int         tmAveCharWidth;
    int         tmMaxCharWidth;
    int         tmWeight;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    int         tmOverhang;
    int         tmDigitizedAspectX;
    int         tmDigitizedAspectY;
  } TEXTMETRIC;
typedef TEXTMETRIC          *PTEXTMETRIC;
typedef TEXTMETRIC NEAR     *NPTEXTMETRIC;
typedef TEXTMETRIC FAR      *LPTEXTMETRIC;

#endif /* NOTEXTMETRIC */

/* GDI Logical Objects: */

/* Pel Array */
typedef struct tagPELARRAY
  {
    int         paXCount;
    int         paYCount;
    int         paXExt;
    int         paYExt;
    BYTE        paRGBs;
  } PELARRAY;
typedef PELARRAY            *PPELARRAY;
typedef PELARRAY NEAR       *NPPELARRAY;
typedef PELARRAY FAR        *LPPELARRAY;

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
  {
    WORD        lbStyle;
    DWORD       lbColor;
    int       lbHatch;
  } LOGBRUSH;
typedef LOGBRUSH            *PLOGBRUSH;
typedef LOGBRUSH NEAR       *NPLOGBRUSH;
typedef LOGBRUSH FAR        *LPLOGBRUSH;

typedef LOGBRUSH            PATTERN;
typedef PATTERN             *PPATTERN;
typedef PATTERN NEAR        *NPPATTERN;
typedef PATTERN FAR         *LPPATTERN;

/* Logical Pen */
typedef struct tagLOGPEN
  {
    WORD        lopnStyle;
    POINT       lopnWidth;
    DWORD       lopnColor;
  } LOGPEN;
typedef LOGPEN              *PLOGPEN;
typedef LOGPEN NEAR         *NPLOGPEN;
typedef LOGPEN FAR          *LPLOGPEN;



typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR  *LPPALETTEENTRY;

/* Logical Palette */
typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE          *PLOGPALETTE;
typedef LOGPALETTE NEAR     *NPLOGPALETTE;
typedef LOGPALETTE FAR      *LPLOGPALETTE;


/* Logical Font */
#define LF_FACESIZE         32

typedef struct tagLOGFONT
  {
    int       lfHeight;
    int       lfWidth;
    int       lfEscapement;
    int       lfOrientation;
    int       lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
  } LOGFONT;
typedef LOGFONT             *PLOGFONT;
typedef LOGFONT NEAR        *NPLOGFONT;
typedef LOGFONT FAR         *LPLOGFONT;

#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3

#define CLIP_DEFAULT_PRECIS     0
#define CLIP_CHARACTER_PRECIS   1
#define CLIP_STROKE_PRECIS      2

#define DEFAULT_QUALITY         0
#define DRAFT_QUALITY           1
#define PROOF_QUALITY           2

#define DEFAULT_PITCH           0
#define FIXED_PITCH             1
#define VARIABLE_PITCH          2

#define ANSI_CHARSET            0
#define SYMBOL_CHARSET          2
#define SHIFTJIS_CHARSET        128
#define OEM_CHARSET             255

/* Font Families */
#define FF_DONTCARE         (0<<4)  /* Don't care or don't know. */
#define FF_ROMAN            (1<<4)  /* Variable stroke width, serifed. */
                                    /* Times Roman, Century Schoolbook, etc. */
#define FF_SWISS            (2<<4)  /* Variable stroke width, sans-serifed. */
                                    /* Helvetica, Swiss, etc. */
#define FF_MODERN           (3<<4)  /* Constant stroke width, serifed or sans-serifed. */
                                    /* Pica, Elite, Courier, etc. */
#define FF_SCRIPT           (4<<4)  /* Cursive, etc. */
#define FF_DECORATIVE       (5<<4)  /* Old English, etc. */

/* Font Weights */
#define FW_DONTCARE         0
#define FW_THIN             100
#define FW_EXTRALIGHT       200
#define FW_LIGHT            300
#define FW_NORMAL           400
#define FW_MEDIUM           500
#define FW_SEMIBOLD         600
#define FW_BOLD             700
#define FW_EXTRABOLD        800
#define FW_HEAVY            900

#define FW_ULTRALIGHT       FW_EXTRALIGHT
#define FW_REGULAR          FW_NORMAL
#define FW_DEMIBOLD         FW_SEMIBOLD
#define FW_ULTRABOLD        FW_EXTRABOLD
#define FW_BLACK            FW_HEAVY

/* EnumFonts Masks */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002

#define RGB(r,g,b)          ((DWORD)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))
#define PALETTERGB(r,g,b)   (0x02000000UL | RGB(r,g,b))
#define PALETTEINDEX(i)     ((DWORD)(0x01000000UL | (WORD)(i)))

#define GetRValue(rgb)      ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

/* Background Modes */
#define TRANSPARENT         1
#define OPAQUE              2

/* Mapping Modes */
#define MM_TEXT             1
#define MM_LOMETRIC         2
#define MM_HIMETRIC         3
#define MM_LOENGLISH        4
#define MM_HIENGLISH        5
#define MM_TWIPS            6
#define MM_ISOTROPIC        7
#define MM_ANISOTROPIC      8

/* Coordinate Modes */
#define ABSOLUTE            1
#define RELATIVE            2

/* Stock Logical Objects */
#define WHITE_BRUSH         0
#define LTGRAY_BRUSH        1
#define GRAY_BRUSH          2
#define DKGRAY_BRUSH        3
#define BLACK_BRUSH         4
#define NULL_BRUSH          5
#define HOLLOW_BRUSH        NULL_BRUSH
#define WHITE_PEN           6
#define BLACK_PEN           7
#define NULL_PEN            8
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16

/* Brush Styles */
#define BS_SOLID            0
#define BS_NULL             1
#define BS_HOLLOW           BS_NULL
#define BS_HATCHED          2
#define BS_PATTERN          3
#define BS_INDEXED          4
#define BS_DIBPATTERN       5

/* Hatch Styles */
#define HS_HORIZONTAL       0       /* ----- */
#define HS_VERTICAL         1       /* ||||| */
#define HS_FDIAGONAL        2       /* \\\\\ */
#define HS_BDIAGONAL        3       /* ///// */
#define HS_CROSS            4       /* +++++ */
#define HS_DIAGCROSS        5       /* xxxxx */

/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1       /* -------  */
#define PS_DOT              2       /* .......  */
#define PS_DASHDOT          3       /* _._._._  */
#define PS_DASHDOTDOT       4       /* _.._.._  */
#define PS_NULL             5
#define PS_INSIDEFRAME      6

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0     /* Device driver version                    */
#define TECHNOLOGY    2     /* Device classification                    */
#define HORZSIZE      4     /* Horizontal size in millimeters           */
#define VERTSIZE      6     /* Vertical size in millimeters             */
#define HORZRES       8     /* Horizontal width in pixels               */
#define VERTRES       10    /* Vertical width in pixels                 */
#define BITSPIXEL     12    /* Number of bits per pixel                 */
#define PLANES        14    /* Number of planes                         */
#define NUMBRUSHES    16    /* Number of brushes the device has         */
#define NUMPENS       18    /* Number of pens the device has            */
#define NUMMARKERS    20    /* Number of markers the device has         */
#define NUMFONTS      22    /* Number of fonts the device has           */
#define NUMCOLORS     24    /* Number of colors the device supports     */
#define PDEVICESIZE   26    /* Size required for device descriptor      */
#define CURVECAPS     28    /* Curve capabilities                       */
#define LINECAPS      30    /* Line capabilities                        */
#define POLYGONALCAPS 32    /* Polygonal capabilities                   */
#define TEXTCAPS      34    /* Text capabilities                        */
#define CLIPCAPS      36    /* Clipping capabilities                    */
#define RASTERCAPS    38    /* Bitblt capabilities                      */
#define ASPECTX       40    /* Length of the X leg                      */
#define ASPECTY       42    /* Length of the Y leg                      */
#define ASPECTXY      44    /* Length of the hypotenuse                 */

#define LOGPIXELSX    88    /* Logical pixels/inch in X                 */
#define LOGPIXELSY    90    /* Logical pixels/inch in Y                 */

#define SIZEPALETTE  104    /* Number of entries in physical palette    */
#define NUMRESERVED  106    /* Number of reserved entries in palette    */
#define COLORRES     108    /* Actual color resolution                  */

#ifndef NOGDICAPMASKS

/* Device Capability Masks: */

/* Device Technologies */
#define DT_PLOTTER          0   /* Vector plotter                   */
#define DT_RASDISPLAY       1   /* Raster display                   */
#define DT_RASPRINTER       2   /* Raster printer                   */
#define DT_RASCAMERA        3   /* Raster camera                    */
#define DT_CHARSTREAM       4   /* Character-stream, PLP            */
#define DT_METAFILE         5   /* Metafile, VDM                    */
#define DT_DISPFILE         6   /* Display-file                     */

/* Curve Capabilities */
#define CC_NONE             0   /* Curves not supported             */
#define CC_CIRCLES          1   /* Can do circles                   */
#define CC_PIE              2   /* Can do pie wedges                */
#define CC_CHORD            4   /* Can do chord arcs                */
#define CC_ELLIPSES         8   /* Can do ellipese                  */
#define CC_WIDE             16  /* Can do wide lines                */
#define CC_STYLED           32  /* Can do styled lines              */
#define CC_WIDESTYLED       64  /* Can do wide styled lines         */
#define CC_INTERIORS        128 /* Can do interiors                 */

/* Line Capabilities */
#define LC_NONE             0   /* Lines not supported              */
#define LC_POLYLINE         2   /* Can do polylines                 */
#define LC_MARKER           4   /* Can do markers                   */
#define LC_POLYMARKER       8   /* Can do polymarkers               */
#define LC_WIDE             16  /* Can do wide lines                */
#define LC_STYLED           32  /* Can do styled lines              */
#define LC_WIDESTYLED       64  /* Can do wide styled lines         */
#define LC_INTERIORS        128 /* Can do interiors                 */

/* Polygonal Capabilities */
#define PC_NONE             0   /* Polygonals not supported         */
#define PC_POLYGON          1   /* Can do polygons                  */
#define PC_RECTANGLE        2   /* Can do rectangles                */
#define PC_WINDPOLYGON      4   /* Can do winding polygons          */
#define PC_TRAPEZOID        4   /* Can do trapezoids                */
#define PC_SCANLINE         8   /* Can do scanlines                 */
#define PC_WIDE             16  /* Can do wide borders              */
#define PC_STYLED           32  /* Can do styled borders            */
#define PC_WIDESTYLED       64  /* Can do wide styled borders       */
#define PC_INTERIORS        128 /* Can do interiors                 */

/* Polygonal Capabilities */
#define CP_NONE             0   /* No clipping of output            */
#define CP_RECTANGLE        1   /* Output clipped to rects          */

/* Text Capabilities */
#define TC_OP_CHARACTER     0x0001  /* Can do OutputPrecision   CHARACTER      */
#define TC_OP_STROKE        0x0002  /* Can do OutputPrecision   STROKE         */
#define TC_CP_STROKE        0x0004  /* Can do ClipPrecision     STROKE         */
#define TC_CR_90            0x0008  /* Can do CharRotAbility    90             */
#define TC_CR_ANY           0x0010  /* Can do CharRotAbility    ANY            */
#define TC_SF_X_YINDEP      0x0020  /* Can do ScaleFreedom      X_YINDEPENDENT */
#define TC_SA_DOUBLE        0x0040  /* Can do ScaleAbility      DOUBLE         */
#define TC_SA_INTEGER       0x0080  /* Can do ScaleAbility      INTEGER        */
#define TC_SA_CONTIN        0x0100  /* Can do ScaleAbility      CONTINUOUS     */
#define TC_EA_DOUBLE        0x0200  /* Can do EmboldenAbility   DOUBLE         */
#define TC_IA_ABLE          0x0400  /* Can do ItalisizeAbility  ABLE           */
#define TC_UA_ABLE          0x0800  /* Can do UnderlineAbility  ABLE           */
#define TC_SO_ABLE          0x1000  /* Can do StrikeOutAbility  ABLE           */
#define TC_RA_ABLE          0x2000  /* Can do RasterFontAble    ABLE           */
#define TC_VA_ABLE          0x4000  /* Can do VectorFontAble    ABLE           */
#define TC_RESERVED         0x8000

#endif /* NOGDICAPMASKS */

/* Raster Capabilities */
#define RC_BITBLT           1       /* Can do standard BLT.             */
#define RC_BANDING          2       /* Device requires banding support  */
#define RC_SCALING          4       /* Device requires scaling support  */
#define RC_BITMAP64         8       /* Device can support >64K bitmap   */
#define RC_GDI20_OUTPUT     0x0010      /* has 2.0 output calls         */
#define RC_DI_BITMAP        0x0080      /* supports DIB to memory       */
#define RC_PALETTE          0x0100      /* supports a palette           */
#define RC_DIBTODEV         0x0200      /* supports DIBitsToDevice      */
#define RC_BIGFONT          0x0400      /* supports >64K fonts          */
#define RC_STRETCHBLT       0x0800      /* supports StretchBlt          */
#define RC_FLOODFILL        0x1000      /* supports FloodFill           */
#define RC_STRETCHDIB       0x2000      /* supports StretchDIBits       */


/* palette entry flags */

#define PC_RESERVED     0x01    /* palette index used for animation */
#define PC_EXPLICIT     0x02    /* palette index is explicit to device */
#define PC_NOCOLLAPSE   0x04    /* do not match color to system palette */

/* DIB color table identifiers */

#define DIB_RGB_COLORS  0       /* color table in RGBTriples */
#define DIB_PAL_COLORS  1       /* color table in palette indices */

/* constants for Get/SetSystemPaletteUse() */

#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/* constants for CreateDIBitmap */
#define CBM_INIT        0x04L   /* initialize bitmap */

#ifndef NODRAWTEXT

/* DrawText() Format Flags */
#define DT_TOP              0x0000
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000

int  FAR PASCAL DrawText(HDC, LPSTR, int, LPRECT, WORD);
BOOL FAR PASCAL DrawIcon(HDC, int, int, HICON);

#endif /* NODRAWTEXT */

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

HDC   FAR PASCAL GetWindowDC(HWND);
HDC   FAR PASCAL GetDC(HWND);
int   FAR PASCAL ReleaseDC(HWND, HDC);
HDC   FAR PASCAL CreateDC(LPSTR, LPSTR, LPSTR, LPSTR);
HDC   FAR PASCAL CreateIC(LPSTR, LPSTR, LPSTR, LPSTR);
HDC   FAR PASCAL CreateCompatibleDC(HDC);
BOOL  FAR PASCAL DeleteDC(HDC);
int   FAR PASCAL SaveDC(HDC);
BOOL  FAR PASCAL RestoreDC(HDC, int);
DWORD FAR PASCAL MoveTo(HDC, int, int);
DWORD FAR PASCAL GetCurrentPosition(HDC);
BOOL  FAR PASCAL LineTo(HDC, int, int);
DWORD FAR PASCAL GetDCOrg(HDC);

int   FAR PASCAL MulDiv(int, int, int);

BOOL FAR PASCAL ExtTextOut(HDC, int, int, WORD, LPRECT, LPSTR, WORD, LPINT);

BOOL FAR PASCAL Polyline(HDC, LPPOINT, int);
BOOL FAR PASCAL Polygon(HDC, LPPOINT, int);
BOOL FAR PASCAL PolyPolygon(HDC, LPPOINT, LPINT, int);

BOOL  FAR PASCAL Rectangle(HDC, int, int, int, int);
BOOL  FAR PASCAL RoundRect(HDC, int, int, int, int, int, int);
BOOL  FAR PASCAL Ellipse(HDC, int, int, int, int);
BOOL  FAR PASCAL Arc(HDC, int, int, int, int, int, int, int, int);
BOOL  FAR PASCAL Chord(HDC, int, int, int, int, int, int, int, int);
BOOL  FAR PASCAL Pie(HDC, int, int, int, int, int, int, int, int);
BOOL  FAR PASCAL PatBlt(HDC, int, int, int, int, DWORD);
BOOL  FAR PASCAL BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);
BOOL  FAR PASCAL StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
BOOL  FAR PASCAL TextOut(HDC, int, int, LPSTR, int);
LONG  FAR PASCAL TabbedTextOut(HDC, int, int, LPSTR, int, int, LPINT, int);
BOOL  FAR PASCAL GetCharWidth(HDC, WORD, WORD, LPINT);
DWORD FAR PASCAL SetPixel( HDC, int, int, DWORD);
DWORD FAR PASCAL GetPixel( HDC, int, int);
BOOL  FAR PASCAL FloodFill( HDC, int, int, DWORD);
BOOL  FAR PASCAL ExtFloodFill(HDC, int, int, DWORD, WORD);
void  FAR PASCAL LineDDA(int, int, int, int, FARPROC, LPSTR);

HANDLE FAR PASCAL GetStockObject(int);

HPEN FAR PASCAL CreatePen(int, int, DWORD);
HPEN FAR PASCAL CreatePenIndirect(LOGPEN FAR *);

HBRUSH FAR PASCAL CreateSolidBrush(DWORD);
HBRUSH FAR PASCAL CreateHatchBrush(int,DWORD);
DWORD  FAR PASCAL SetBrushOrg(HDC, int, int);
DWORD  FAR PASCAL GetBrushOrg(HDC);
HBRUSH FAR PASCAL CreatePatternBrush(HBITMAP);
HBRUSH FAR PASCAL CreateBrushIndirect(LOGBRUSH FAR *);

HBITMAP FAR PASCAL CreateBitmap(int, int, BYTE, BYTE, LPSTR);
HBITMAP FAR PASCAL CreateBitmapIndirect(BITMAP FAR *);
HBITMAP FAR PASCAL CreateCompatibleBitmap(HDC, int, int);
HBITMAP FAR PASCAL CreateDiscardableBitmap(HDC, int, int);

LONG  FAR PASCAL SetBitmapBits(HBITMAP, DWORD, LPSTR);
LONG  FAR PASCAL GetBitmapBits(HBITMAP, LONG, LPSTR);
DWORD FAR PASCAL SetBitmapDimension(HBITMAP, int, int);
DWORD FAR PASCAL GetBitmapDimension(HBITMAP);

HFONT FAR PASCAL CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPSTR);
HFONT FAR PASCAL CreateFontIndirect(LOGFONT FAR *);

int  FAR PASCAL SelectClipRgn(HDC, HRGN);
HRGN FAR PASCAL CreateRectRgn(int, int, int, int);
void FAR PASCAL SetRectRgn(HRGN, int, int, int, int);
HRGN FAR PASCAL CreateRectRgnIndirect(LPRECT);
HRGN FAR PASCAL CreateEllipticRgnIndirect(LPRECT);
HRGN FAR PASCAL CreateEllipticRgn(int, int, int, int);
HRGN FAR PASCAL CreatePolygonRgn(LPPOINT, int, int);
HRGN FAR PASCAL CreatePolyPolygonRgn(LPPOINT, LPINT, int, int);
HRGN FAR PASCAL CreateRoundRectRgn(int, int, int, int, int, int);

int    FAR PASCAL GetObject(HANDLE, int, LPSTR);
BOOL   FAR PASCAL DeleteObject(HANDLE);
HANDLE FAR PASCAL SelectObject(HDC, HANDLE);
BOOL   FAR PASCAL UnrealizeObject(HBRUSH);

DWORD FAR PASCAL SetBkColor(HDC, DWORD);
DWORD FAR PASCAL GetBkColor(HDC);
int   FAR PASCAL SetBkMode(HDC, int);
int   FAR PASCAL GetBkMode(HDC);
DWORD FAR PASCAL SetTextColor(HDC, DWORD);
DWORD FAR PASCAL GetTextColor(HDC);
WORD  FAR PASCAL SetTextAlign(HDC, WORD);
WORD  FAR PASCAL GetTextAlign(HDC);
DWORD FAR PASCAL SetMapperFlags(HDC, DWORD);
DWORD FAR PASCAL GetAspectRatioFilter(HDC);
DWORD FAR PASCAL GetNearestColor(HDC, DWORD);
int   FAR PASCAL SetROP2(HDC, int);
int   FAR PASCAL GetROP2(HDC);
int   FAR PASCAL SetStretchBltMode(HDC, int);
int   FAR PASCAL GetStretchBltMode(HDC);
int   FAR PASCAL SetPolyFillMode(HDC, int);
int   FAR PASCAL GetPolyFillMode(HDC);
int   FAR PASCAL SetMapMode(HDC, int);
int   FAR PASCAL GetMapMode(HDC);
DWORD FAR PASCAL SetWindowOrg(HDC, int, int);
DWORD FAR PASCAL GetWindowOrg(HDC);
DWORD FAR PASCAL SetWindowExt(HDC, int, int);
DWORD FAR PASCAL GetWindowExt(HDC);
DWORD FAR PASCAL SetViewportOrg(HDC, int, int);
DWORD FAR PASCAL GetViewportOrg(HDC);
DWORD FAR PASCAL SetViewportExt(HDC, int, int);
DWORD FAR PASCAL GetViewportExt(HDC);
DWORD FAR PASCAL OffsetViewportOrg(HDC, int, int);
DWORD FAR PASCAL ScaleViewportExt(HDC, int, int, int, int);
DWORD FAR PASCAL OffsetWindowOrg(HDC, int, int);
DWORD FAR PASCAL ScaleWindowExt(HDC, int, int, int, int);

int  FAR PASCAL GetClipBox(HDC, LPRECT);
int  FAR PASCAL IntersectClipRect(HDC, int, int, int, int);
int  FAR PASCAL OffsetClipRgn(HDC, int, int);
int  FAR PASCAL ExcludeClipRect(HDC, int, int, int, int);
BOOL FAR PASCAL PtVisible(HDC, int, int);
int  FAR PASCAL CombineRgn(HRGN, HRGN, HRGN, int);
BOOL FAR PASCAL EqualRgn(HRGN, HRGN);
int  FAR PASCAL OffsetRgn(HRGN, int, int);
int  FAR PASCAL GetRgnBox(HRGN, LPRECT);

int   FAR PASCAL SetTextJustification(HDC, int, int);
DWORD FAR PASCAL GetTextExtent(HDC, LPSTR, int);
DWORD FAR PASCAL GetTabbedTextExtent(HDC, LPSTR, int, int, LPINT);
int   FAR PASCAL SetTextCharacterExtra(HDC, int);
int   FAR PASCAL GetTextCharacterExtra(HDC);

HANDLE FAR PASCAL GetMetaFile(LPSTR);
BOOL   FAR PASCAL DeleteMetaFile(HANDLE);
HANDLE FAR PASCAL CopyMetaFile(HANDLE, LPSTR);

#ifndef NOMETAFILE
void FAR PASCAL PlayMetaFileRecord(HDC, LPHANDLETABLE, LPMETARECORD, WORD);
BOOL FAR PASCAL EnumMetaFile(HDC, LOCALHANDLE, FARPROC, BYTE FAR *);
#endif

BOOL FAR PASCAL PlayMetaFile(HDC, HANDLE);
int FAR PASCAL Escape(HDC, int, int, LPSTR, LPSTR);
int FAR PASCAL EnumFonts(HDC, LPSTR, FARPROC, LPSTR);
int FAR PASCAL EnumObjects(HDC, int, FARPROC, LPSTR);
int FAR PASCAL GetTextFace(HDC, int, LPSTR);

#ifndef NOTEXTMETRIC
BOOL FAR PASCAL GetTextMetrics(HDC, LPTEXTMETRIC );
#endif

int FAR PASCAL GetDeviceCaps(HDC, int);

int FAR PASCAL SetEnvironment(LPSTR, LPSTR, WORD);
int FAR PASCAL GetEnvironment(LPSTR, LPSTR, WORD);

BOOL FAR PASCAL DPtoLP(HDC, LPPOINT, int);
BOOL FAR PASCAL LPtoDP(HDC, LPPOINT, int);

HANDLE FAR PASCAL CreateMetaFile(LPSTR);
HANDLE FAR PASCAL CloseMetaFile(HANDLE);
HANDLE FAR PASCAL GetMetaFileBits(HANDLE);
HANDLE FAR PASCAL SetMetaFileBits(HANDLE);

int FAR PASCAL SetDIBits(HDC,HANDLE,WORD,WORD,LPSTR,LPBITMAPINFO,WORD);
int FAR PASCAL GetDIBits(HDC,HANDLE,WORD,WORD,LPSTR,LPBITMAPINFO,WORD);
int FAR PASCAL SetDIBitsToDevice(HDC,WORD,WORD,WORD,WORD,
                                        WORD,WORD,WORD,WORD,
                                        LPSTR,LPBITMAPINFO,WORD);
HBITMAP FAR PASCAL CreateDIBitmap(HDC,LPBITMAPINFOHEADER,DWORD,LPSTR,
                                                LPBITMAPINFO,WORD);
HBRUSH FAR PASCAL CreateDIBPatternBrush(HANDLE,WORD);
int FAR PASCAL StretchDIBits(HDC, WORD, WORD, WORD, WORD, WORD,
                        WORD, WORD, WORD, LPSTR, LPBITMAPINFO, WORD, DWORD);

HPALETTE FAR PASCAL CreatePalette (LPLOGPALETTE);
HPALETTE  FAR PASCAL SelectPalette (HDC,HPALETTE, BOOL) ;
WORD FAR PASCAL RealizePalette (HDC) ;
int  FAR PASCAL UpdateColors (HDC) ;
void FAR PASCAL AnimatePalette(HPALETTE, WORD, WORD, LPPALETTEENTRY);
WORD FAR PASCAL SetPaletteEntries(HPALETTE,WORD,WORD,LPPALETTEENTRY);
WORD FAR PASCAL GetPaletteEntries(HPALETTE,WORD,WORD,LPPALETTEENTRY);
WORD FAR PASCAL GetNearestPaletteIndex(HPALETTE, DWORD);
BOOL FAR PASCAL ResizePalette(HPALETTE, WORD);

WORD FAR PASCAL GetSystemPaletteEntries(HDC,WORD,WORD,LPPALETTEENTRY);
WORD FAR PASCAL GetSystemPaletteUse(HDC, WORD);
WORD FAR PASCAL SetSystemPaletteUse(HDC, WORD);
#endif /* NOGDI */


/*--------------------------------------------------------------------------*/
/*      USER Section                                                        */
/*--------------------------------------------------------------------------*/

#ifndef NOUSER

int FAR PASCAL wvsprintf(LPSTR,LPSTR,LPSTR);
#define wsprintf WSPRINTF
int FAR cdecl wsprintf(LPSTR,LPSTR,...);

#ifndef NOSCROLL

/* Scroll Bar Constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3

/* Scroll Bar Commands */
#define SB_LINEUP           0
#define SB_LINEDOWN         1
#define SB_PAGEUP           2
#define SB_PAGEDOWN         3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_BOTTOM           7
#define SB_ENDSCROLL        8

#endif /* NOSCROLL */

#ifndef NOSHOWWINDOW

/* ShowWindow() Commands */
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9

/* Old ShowWindow() Commands */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

/* Identifiers for the WM_SHOWWINDOW message */
#define SW_PARENTCLOSING    1
#define SW_OTHERZOOM        2
#define SW_PARENTOPENING    3
#define SW_OTHERUNZOOM      4

#endif /* NOSHOWWINDOW */

/* Region Flags */
#define ERROR               0
#define NULLREGION          1
#define SIMPLEREGION        2
#define COMPLEXREGION       3

/* CombineRgn() Styles */
#define RGN_AND             1
#define RGN_OR              2
#define RGN_XOR             3
#define RGN_DIFF            4
#define RGN_COPY            5

#ifndef NOVIRTUALKEYCODES

/* Virtual Keys, Standard Set */
#define VK_LBUTTON          0x01
#define VK_RBUTTON          0x02
#define VK_CANCEL           0x03
#define VK_MBUTTON          0x04    /* NOT contiguous with L & RBUTTON */
#define VK_BACK             0x08
#define VK_TAB              0x09
#define VK_CLEAR            0x0C
#define VK_RETURN           0x0D
#define VK_SHIFT            0x10
#define VK_CONTROL          0x11
#define VK_MENU             0x12
#define VK_PAUSE            0x13
#define VK_CAPITAL          0x14
#define VK_ESCAPE           0x1B
#define VK_SPACE            0x20
#define VK_PRIOR            0x21
#define VK_NEXT             0x22
#define VK_END              0x23
#define VK_HOME             0x24
#define VK_LEFT             0x25
#define VK_UP               0x26
#define VK_RIGHT            0x27
#define VK_DOWN             0x28
#define VK_SELECT           0x29
#define VK_PRINT            0x2A
#define VK_EXECUTE          0x2B
#define VK_SNAPSHOT         0x2C
/* #define VK_COPY          0x2C not used by keyboards. */
#define VK_INSERT           0x2D
#define VK_DELETE           0x2E
#define VK_HELP             0x2F

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '9' */

#define VK_NUMPAD0          0x60
#define VK_NUMPAD1          0x61
#define VK_NUMPAD2          0x62
#define VK_NUMPAD3          0x63
#define VK_NUMPAD4          0x64
#define VK_NUMPAD5          0x65
#define VK_NUMPAD6          0x66
#define VK_NUMPAD7          0x67
#define VK_NUMPAD8          0x68
#define VK_NUMPAD9          0x69
#define VK_MULTIPLY         0x6A
#define VK_ADD              0x6B
#define VK_SEPARATOR        0x6C
#define VK_SUBTRACT         0x6D
#define VK_DECIMAL          0x6E
#define VK_DIVIDE           0x6F
#define VK_F1               0x70
#define VK_F2               0x71
#define VK_F3               0x72
#define VK_F4               0x73
#define VK_F5               0x74
#define VK_F6               0x75
#define VK_F7               0x76
#define VK_F8               0x77
#define VK_F9               0x78
#define VK_F10              0x79
#define VK_F11              0x7A
#define VK_F12              0x7B
#define VK_F13              0x7C
#define VK_F14              0x7D
#define VK_F15              0x7E
#define VK_F16              0x7F

#define VK_NUMLOCK          0x90

#endif /* NOVIRTUALKEYCODES */

#ifndef NOWH

/* SetWindowsHook() codes */
#define WH_MSGFILTER        (-1)
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1
#define WH_KEYBOARD         2
#define WH_GETMESSAGE       3
#define WH_CALLWNDPROC      4
#define WH_CBT              5
#define WH_SYSMSGFILTER     6
#define WH_WINDOWMGR        7

/* Hook Codes */
#define HC_LPLPFNNEXT       (-2)
#define HC_LPFNNEXT         (-1)
#define HC_ACTION           0
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREM            3
#define HC_NOREMOVE         3
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* CBT Hook Codes */
#define HCBT_MOVESIZE       0
#define HCBT_MINMAX         1
#define HCBT_QS             2

/* WH_MSGFILTER Filter Proc Codes */
#define MSGF_DIALOGBOX      0
#define MSGF_MESSAGEBOX     1
#define MSGF_MENU           2
#define MSGF_MOVE           3
#define MSGF_SIZE           4
#define MSGF_SCROLLBAR      5
#define MSGF_NEXTWINDOW     6

/* Window Manager Hook Codes */
#define WC_INIT             1
#define WC_SWP              2
#define WC_DEFWINDOWPROC    3
#define WC_MINMAX           4
#define WC_MOVE             5
#define WC_SIZE             6
#define WC_DRAWCAPTION      7

/* Message Structure used in Journaling */
typedef struct tagEVENTMSG
  {
    WORD    message;
    WORD    paramL;
    WORD    paramH;
    DWORD   time;
  } EVENTMSG;
typedef EVENTMSG            *PEVENTMSGMSG;
typedef EVENTMSG NEAR       *NPEVENTMSGMSG;
typedef EVENTMSG FAR        *LPEVENTMSGMSG;

#endif /* NOWH */

typedef struct tagWNDCLASS
  {
    WORD        style;
    LONG        (FAR PASCAL *lpfnWndProc)( HWND, WORD, WORD, LONG );
    int         cbClsExtra;
    int         cbWndExtra;
    HANDLE      hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPSTR       lpszMenuName;
    LPSTR       lpszClassName;
  } WNDCLASS;
typedef WNDCLASS            *PWNDCLASS;
typedef WNDCLASS NEAR       *NPWNDCLASS;
typedef WNDCLASS FAR        *LPWNDCLASS;

#ifndef NOMSG

/* Message structure */
typedef struct tagMSG
  {
    HWND        hwnd;
    WORD        message;
    WORD        wParam;
    LONG        lParam;
    DWORD       time;
    POINT       pt;
  } MSG;
typedef MSG                 *PMSG;
typedef MSG NEAR            *NPMSG;
typedef MSG FAR             *LPMSG;

#endif /* NOMSG */

#ifndef NOWINOFFSETS

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#define GWL_WNDPROC         (-4)
#define GWW_HINSTANCE       (-6)
#define GWW_HWNDPARENT      (-8)
#define GWW_ID              (-12)
#define GWL_STYLE           (-16)
#define GWL_EXSTYLE         (-20)

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#endif /* NOWINOFFSETS */

#ifndef NOWINMESSAGES

/* Window Messages */
#define WM_NULL             0x0000
#define WM_CREATE           0x0001
#define WM_DESTROY          0x0002
#define WM_MOVE             0x0003
#define WM_SIZE             0x0005
#define WM_ACTIVATE         0x0006
#define WM_SETFOCUS         0x0007
#define WM_KILLFOCUS        0x0008
#define WM_ENABLE           0x000A
#define WM_SETREDRAW        0x000B
#define WM_SETTEXT          0x000C
#define WM_GETTEXT          0x000D
#define WM_GETTEXTLENGTH    0x000E
#define WM_PAINT            0x000F
#define WM_CLOSE            0x0010
#define WM_QUERYENDSESSION  0x0011
#define WM_QUIT             0x0012
#define WM_QUERYOPEN        0x0013
#define WM_ERASEBKGND       0x0014
#define WM_SYSCOLORCHANGE   0x0015
#define WM_ENDSESSION       0x0016
#define WM_SHOWWINDOW       0x0018
#define WM_CTLCOLOR         0x0019
#define WM_WININICHANGE     0x001A
#define WM_DEVMODECHANGE    0x001B
#define WM_ACTIVATEAPP      0x001C
#define WM_FONTCHANGE       0x001D
#define WM_TIMECHANGE       0x001E
#define WM_CANCELMODE       0x001F
#define WM_SETCURSOR        0x0020
#define WM_MOUSEACTIVATE    0x0021
#define WM_CHILDACTIVATE    0x0022
#define WM_QUEUESYNC        0x0023
#define WM_GETMINMAXINFO    0x0024
#define WM_PAINTICON        0x0026
#define WM_ICONERASEBKGND   0x0027
#define WM_NEXTDLGCTL       0x0028
#define WM_SPOOLERSTATUS    0x002A
#define WM_DRAWITEM         0x002B
#define WM_MEASUREITEM      0x002C
#define WM_DELETEITEM       0x002D
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F
#define WM_SETFONT          0x0030
#define WM_GETFONT          0x0031


#define WM_QUERYDRAGICON    0x0037

#define WM_COMPAREITEM      0x0039
#define WM_COMPACTING       0x0041

#define WM_NCCREATE         0x0081
#define WM_NCDESTROY        0x0082
#define WM_NCCALCSIZE       0x0083
#define WM_NCHITTEST        0x0084
#define WM_NCPAINT          0x0085
#define WM_NCACTIVATE       0x0086
#define WM_GETDLGCODE       0x0087
#define WM_NCMOUSEMOVE      0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP      0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP      0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP      0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

#define WM_KEYFIRST         0x0100
#define WM_KEYDOWN          0x0100
#define WM_KEYUP            0x0101
#define WM_CHAR             0x0102
#define WM_DEADCHAR         0x0103
#define WM_SYSKEYDOWN       0x0104
#define WM_SYSKEYUP         0x0105
#define WM_SYSCHAR          0x0106
#define WM_SYSDEADCHAR      0x0107
#define WM_KEYLAST          0x0108

#define WM_INITDIALOG       0x0110
#define WM_COMMAND          0x0111
#define WM_SYSCOMMAND       0x0112
#define WM_TIMER            0x0113
#define WM_HSCROLL          0x0114
#define WM_VSCROLL          0x0115
#define WM_INITMENU         0x0116
#define WM_INITMENUPOPUP    0x0117
#define WM_MENUSELECT       0x011F
#define WM_MENUCHAR         0x0120
#define WM_ENTERIDLE        0x0121


#define WM_MOUSEFIRST       0x0200
#define WM_MOUSEMOVE        0x0200
#define WM_LBUTTONDOWN      0x0201
#define WM_LBUTTONUP        0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN      0x0204
#define WM_RBUTTONUP        0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN      0x0207
#define WM_MBUTTONUP        0x0208
#define WM_MBUTTONDBLCLK    0x0209
#define WM_MOUSELAST        0x0209

#define WM_PARENTNOTIFY     0x0210
#define WM_MDICREATE        0x0220
#define WM_MDIDESTROY       0x0221
#define WM_MDIACTIVATE      0x0222
#define WM_MDIRESTORE       0x0223
#define WM_MDINEXT          0x0224
#define WM_MDIMAXIMIZE      0x0225
#define WM_MDITILE          0x0226
#define WM_MDICASCADE       0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU       0x0230


#define WM_CUT              0x0300
#define WM_COPY             0x0301
#define WM_PASTE            0x0302
#define WM_CLEAR            0x0303
#define WM_UNDO             0x0304
#define WM_RENDERFORMAT     0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_SIZECLIPBOARD    0x030B
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311




/* NOTE: All Message Numbers below 0x0400 are RESERVED. */

/* Private Window Messages Start Here: */
#define WM_USER             0x0400

#ifndef NONCMESSAGES

/* WM_SYNCTASK Commands */
#define ST_BEGINSWP         0
#define ST_ENDSWP           1

/* WinWhere() Area Codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTGROWBOX           4
#define HTSIZE              HTGROWBOX
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTREDUCE            8
#define HTZOOM              9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTSIZEFIRST         HTLEFT
#define HTSIZELAST          HTBOTTOMRIGHT

#endif /* NONCMESSAGES */

/* WM_MOUSEACTIVATE Return Codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3

WORD FAR PASCAL RegisterWindowMessage(LPSTR);

/* Size Message Commands */
#define SIZENORMAL          0
#define SIZEICONIC          1
#define SIZEFULLSCREEN      2
#define SIZEZOOMSHOW        3
#define SIZEZOOMHIDE        4

#ifndef NOKEYSTATES

/* Key State Masks for Mouse Messages */
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010

#endif /* NOKEYSTATES */

#endif /* NOWINMESSAGES */

#ifndef NOWINSTYLES

/* Window Styles */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L
#define WS_MINIMIZE         0x20000000L
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L
#define WS_MAXIMIZE         0x01000000L
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW      (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW      (WS_CHILD)

#define WS_TILEDWINDOW      (WS_OVERLAPPEDWINDOW)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME 0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008
                        /*  0x0010 -- no longer used */
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080
#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800
#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000    /* Global window class */

#endif /* NOWINSTYLES */

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

#endif /* NOCLIPBOARD */

typedef struct tagPAINTSTRUCT
  {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[16];
  } PAINTSTRUCT;
typedef PAINTSTRUCT         *PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR    *NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR     *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCT
  {
    LPSTR       lpCreateParams;
    HANDLE      hInstance;
    HANDLE      hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPSTR       lpszName;
    LPSTR       lpszClass;
    DWORD       dwExStyle;
  } CREATESTRUCT;
typedef CREATESTRUCT FAR    *LPCREATESTRUCT;


/* Owner draw control types */
#define ODT_MENU        1
#define ODT_LISTBOX     2
#define ODT_COMBOBOX    3
#define ODT_BUTTON      4

/* Owner draw actions */
#define ODA_DRAWENTIRE  0x0001
#define ODA_SELECT      0x0002
#define ODA_FOCUS       0x0004

/* Owner draw state */
#define ODS_SELECTED    0x0001
#define ODS_GRAYED      0x0002
#define ODS_DISABLED    0x0004
#define ODS_CHECKED     0x0008
#define ODS_FOCUS       0x0010

/* MEASUREITEMSTRUCT for ownerdraw */
typedef struct tagMEASUREITEMSTRUCT
  {
    WORD        CtlType;
    WORD        CtlID;
    WORD        itemID;
    WORD        itemWidth;
    WORD        itemHeight;
    DWORD       itemData;
  } MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR *PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR  *LPMEASUREITEMSTRUCT;


/* DRAWITEMSTRUCT for ownerdraw */
typedef struct tagDRAWITEMSTRUCT
  {
    WORD        CtlType;
    WORD        CtlID;
    WORD        itemID;
    WORD        itemAction;
    WORD        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
  } DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR *PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR  *LPDRAWITEMSTRUCT;

/* DELETEITEMSTRUCT for ownerdraw */
typedef struct tagDELETEITEMSTRUCT
  {
    WORD       CtlType;
    WORD       CtlID;
    WORD       itemID;
    HWND       hwndItem;
    DWORD      itemData;
  } DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR *PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR  *LPDELETEITEMSTRUCT;

/* COMPAREITEMSTUCT for ownerdraw sorting */
typedef struct tagCOMPAREITEMSTRUCT
  {
    WORD        CtlType;
    WORD        CtlID;
    HWND        hwndItem;
    WORD        itemID1;
    DWORD       itemData1;
    WORD        itemID2;
    DWORD       itemData2;
  } COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR *PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR  *LPCOMPAREITEMSTRUCT;

#ifndef NOMSG

/* Message Function Templates */
BOOL FAR PASCAL GetMessage(LPMSG, HWND, WORD, WORD);
BOOL FAR PASCAL TranslateMessage(LPMSG);
LONG FAR PASCAL DispatchMessage(LPMSG);
BOOL FAR PASCAL PeekMessage(LPMSG, HWND, WORD, WORD, WORD);

/* PeekMessage() Options */
#define PM_NOREMOVE         0x0000
#define PM_REMOVE           0x0001
#define PM_NOYIELD          0x0002

#endif /* NOMSG */

#ifdef WIN_INTERNAL
    #ifndef LSTRING
    #define NOLSTRING
    #endif
    #ifndef LFILEIO
    #define NOLFILEIO
    #endif
#endif

#ifndef NOLSTRING
int         FAR PASCAL lstrcmp( LPSTR, LPSTR );
int         FAR PASCAL lstrcmpi( LPSTR, LPSTR );
LPSTR       FAR PASCAL lstrcpy( LPSTR, LPSTR );
LPSTR       FAR PASCAL lstrcat( LPSTR, LPSTR );
int         FAR PASCAL lstrlen( LPSTR );
#endif  /* NOLSTRING */

#ifndef NOLFILEIO
int         FAR PASCAL _lopen( LPSTR, int );
int         FAR PASCAL _lclose( int );
int         FAR PASCAL _lcreat( LPSTR, int );
LONG        FAR PASCAL _llseek( int, long, int );
WORD        FAR PASCAL _lread( int, LPSTR, int );
WORD        FAR PASCAL _lwrite( int, LPSTR, int );

#define READ        0   /* Flags for _lopen */
#define WRITE       1
#define READ_WRITE  2
#endif  /* NOLFILEIO */

BOOL  FAR PASCAL ExitWindows(DWORD dwReserved, WORD wReturnCode);

BOOL  FAR PASCAL SwapMouseButton(BOOL);
DWORD FAR PASCAL GetMessagePos(void);
LONG  FAR PASCAL GetMessageTime(void);

HWND  FAR PASCAL GetSysModalWindow(void);
HWND  FAR PASCAL SetSysModalWindow(HWND);

LONG  FAR PASCAL SendMessage(HWND, WORD, WORD, LONG);
BOOL  FAR PASCAL PostMessage(HWND, WORD, WORD, LONG);
BOOL  FAR PASCAL PostAppMessage(HANDLE, WORD, WORD, LONG);
void  FAR PASCAL ReplyMessage(LONG);
void  FAR PASCAL WaitMessage(void);
LONG  FAR PASCAL DefWindowProc(HWND, WORD, WORD, LONG);
void  FAR PASCAL PostQuitMessage(int);
LONG  FAR PASCAL CallWindowProc(FARPROC, HWND, WORD, WORD, LONG);
BOOL  FAR PASCAL InSendMessage(void);

WORD  FAR PASCAL GetDoubleClickTime(void);
void  FAR PASCAL SetDoubleClickTime(WORD);

BOOL  FAR PASCAL RegisterClass(LPWNDCLASS);
BOOL  FAR PASCAL UnregisterClass(LPSTR, HANDLE);
BOOL  FAR PASCAL GetClassInfo(HANDLE, LPSTR, LPWNDCLASS);

BOOL  FAR PASCAL SetMessageQueue(int);

#define CW_USEDEFAULT       ((int)0x8000)
HWND  FAR PASCAL CreateWindow(LPSTR, LPSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPSTR);
HWND  FAR PASCAL CreateWindowEx(DWORD, LPSTR, LPSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPSTR);

BOOL FAR PASCAL IsWindow(HWND);
BOOL FAR PASCAL IsChild(HWND, HWND);
BOOL FAR PASCAL DestroyWindow(HWND);

BOOL FAR PASCAL ShowWindow(HWND, int);
BOOL FAR PASCAL FlashWindow(HWND, BOOL);
void FAR PASCAL ShowOwnedPopups(HWND, BOOL);

BOOL FAR PASCAL OpenIcon(HWND);
void FAR PASCAL CloseWindow(HWND);
void FAR PASCAL MoveWindow(HWND, int, int, int, int, BOOL);
void FAR PASCAL SetWindowPos(HWND, HWND, int, int, int, int, WORD);

#ifndef NODEFERWINDOWPOS

HANDLE FAR PASCAL BeginDeferWindowPos(int nNumWindows);
HANDLE FAR PASCAL DeferWindowPos(HANDLE hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, WORD wFlags);
void FAR PASCAL EndDeferWindowPos(HANDLE hWinPosInfo);

#endif /* NODEFERWINDOWPOS */

BOOL FAR PASCAL IsWindowVisible(HWND);
BOOL FAR PASCAL IsIconic(HWND);
BOOL FAR PASCAL AnyPopup(void);
void FAR PASCAL BringWindowToTop(HWND);
BOOL FAR PASCAL IsZoomed(HWND);

/* SetWindowPos Flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_DRAWFRAME       0x0020
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOREPOSITION    0x0200

#ifndef NOCTLMGR

HWND FAR PASCAL CreateDialog(HANDLE, LPSTR, HWND, FARPROC);
HWND FAR PASCAL CreateDialogIndirect(HANDLE, LPSTR, HWND, FARPROC);
HWND FAR PASCAL CreateDialogParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
HWND FAR PASCAL CreateDialogIndirectParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  FAR PASCAL DialogBox(HANDLE, LPSTR, HWND, FARPROC);
int  FAR PASCAL DialogBoxIndirect(HANDLE, HANDLE, HWND, FARPROC);
int  FAR PASCAL DialogBoxParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  FAR PASCAL DialogBoxIndirectParam(HANDLE, HANDLE, HWND, FARPROC, LONG);
void FAR PASCAL EndDialog(HWND, int);
HWND FAR PASCAL GetDlgItem(HWND, int);
void FAR PASCAL SetDlgItemInt(HWND, int, WORD, BOOL);
WORD FAR PASCAL GetDlgItemInt(HWND, int, BOOL FAR *, BOOL);
void FAR PASCAL SetDlgItemText(HWND, int, LPSTR);
int  FAR PASCAL GetDlgItemText(HWND, int, LPSTR, int);
void FAR PASCAL CheckDlgButton(HWND, int, WORD);
void FAR PASCAL CheckRadioButton(HWND, int, int, int);
WORD FAR PASCAL IsDlgButtonChecked(HWND, int);
LONG FAR PASCAL SendDlgItemMessage(HWND, int, WORD, WORD, LONG);
HWND FAR PASCAL GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND FAR PASCAL GetNextDlgTabItem(HWND, HWND, BOOL);
int  FAR PASCAL GetDlgCtrlID(HWND);
long FAR PASCAL GetDialogBaseUnits(void);
LONG FAR PASCAL DefDlgProc(HWND, WORD, WORD, LONG);
#define DLGWINDOWEXTRA   30     /* Window extra byted needed for private dialog classes */

#endif /* NOCTLMGR */

#ifndef NOMSG
BOOL FAR PASCAL CallMsgFilter(LPMSG, int);
#endif

#ifndef NOCLIPBOARD

/* Clipboard Manager Functions */
BOOL   FAR PASCAL OpenClipboard(HWND);
BOOL   FAR PASCAL CloseClipboard(void);
HWND   FAR PASCAL GetClipboardOwner(void);
HWND   FAR PASCAL SetClipboardViewer(HWND);
HWND   FAR PASCAL GetClipboardViewer(void);
BOOL   FAR PASCAL ChangeClipboardChain(HWND, HWND);
HANDLE FAR PASCAL SetClipboardData(WORD, HANDLE);
HANDLE FAR PASCAL GetClipboardData(WORD);
WORD   FAR PASCAL RegisterClipboardFormat(LPSTR);
int    FAR PASCAL CountClipboardFormats(void);
WORD   FAR PASCAL EnumClipboardFormats(WORD);
int    FAR PASCAL GetClipboardFormatName(WORD, LPSTR, int);
BOOL   FAR PASCAL EmptyClipboard(void);
BOOL   FAR PASCAL IsClipboardFormatAvailable(WORD);
int    FAR PASCAL GetPriorityClipboardFormat(WORD  FAR *, int);

#endif /* NOCLIPBOARD */

HWND FAR PASCAL SetFocus(HWND);
HWND FAR PASCAL GetFocus(void);
HWND FAR PASCAL GetActiveWindow(void);
int  FAR PASCAL GetKeyState(int);
int  FAR PASCAL GetAsyncKeyState(int);
void FAR PASCAL GetKeyboardState(BYTE FAR *);
void FAR PASCAL SetKeyboardState(BYTE FAR *);
BOOL FAR PASCAL EnableHardwareInput(BOOL);
BOOL FAR PASCAL GetInputState(void);
HWND FAR PASCAL GetCapture(void);
HWND FAR PASCAL SetCapture(HWND);
void FAR PASCAL ReleaseCapture(void);

/* Windows Functions */
WORD FAR PASCAL SetTimer(HWND, int, WORD, FARPROC);
BOOL FAR PASCAL KillTimer(HWND, int);

BOOL FAR PASCAL EnableWindow(HWND,BOOL);
BOOL FAR PASCAL IsWindowEnabled(HWND);

HANDLE FAR PASCAL LoadAccelerators(HANDLE, LPSTR);

#ifndef NOMSG
int  FAR PASCAL TranslateAccelerator(HWND, HANDLE, LPMSG);
#endif

#ifndef NOSYSMETRICS

/* GetSystemMetrics() codes */
#define SM_CXSCREEN         0
#define SM_CYSCREEN         1
#define SM_CXVSCROLL        2
#define SM_CYHSCROLL        3
#define SM_CYCAPTION        4
#define SM_CXBORDER         5
#define SM_CYBORDER         6
#define SM_CXDLGFRAME       7
#define SM_CYDLGFRAME       8
#define SM_CYVTHUMB         9
#define SM_CXHTHUMB         10
#define SM_CXICON           11
#define SM_CYICON           12
#define SM_CXCURSOR         13
#define SM_CYCURSOR         14
#define SM_CYMENU           15
#define SM_CXFULLSCREEN     16
#define SM_CYFULLSCREEN     17
#define SM_CYKANJIWINDOW    18
#define SM_MOUSEPRESENT     19
#define SM_CYVSCROLL        20
#define SM_CXHSCROLL        21
#define SM_DEBUG            22
#define SM_SWAPBUTTON       23
#define SM_RESERVED1        24
#define SM_RESERVED2        25
#define SM_RESERVED3        26
#define SM_RESERVED4        27
#define SM_CXMIN            28
#define SM_CYMIN            29
#define SM_CXSIZE           30
#define SM_CYSIZE           31
#define SM_CXFRAME          32
#define SM_CYFRAME          33
#define SM_CXMINTRACK       34
#define SM_CYMINTRACK       35
#define SM_CMETRICS         36

int FAR PASCAL GetSystemMetrics(int);

#endif /* NOSYSMETRICS */

#ifndef NOMENUS

HMENU FAR PASCAL LoadMenu(HANDLE, LPSTR);
HMENU FAR PASCAL LoadMenuIndirect(LPSTR);
HMENU FAR PASCAL GetMenu(HWND);
BOOL  FAR PASCAL SetMenu(HWND, HMENU);
BOOL  FAR PASCAL ChangeMenu(HMENU, WORD, LPSTR, WORD, WORD);
BOOL  FAR PASCAL HiliteMenuItem(HWND, HMENU, WORD, WORD);
int   FAR PASCAL GetMenuString(HMENU, WORD, LPSTR, int, WORD);
WORD  FAR PASCAL GetMenuState(HMENU, WORD, WORD);
void  FAR PASCAL DrawMenuBar(HWND);
HMENU FAR PASCAL GetSystemMenu(HWND, BOOL);
HMENU FAR PASCAL CreateMenu(void);
HMENU FAR PASCAL CreatePopupMenu(void);
BOOL  FAR PASCAL DestroyMenu(HMENU);
BOOL  FAR PASCAL CheckMenuItem(HMENU, WORD, WORD);
BOOL  FAR PASCAL EnableMenuItem(HMENU, WORD, WORD);
HMENU FAR PASCAL GetSubMenu(HMENU, int);
WORD  FAR PASCAL GetMenuItemID(HMENU, int);
WORD  FAR PASCAL GetMenuItemCount(HMENU);

BOOL  FAR PASCAL InsertMenu(HMENU, WORD, WORD, WORD, LPSTR);
BOOL  FAR PASCAL AppendMenu(HMENU, WORD, WORD, LPSTR);
BOOL  FAR PASCAL ModifyMenu(HMENU, WORD, WORD, WORD, LPSTR);
BOOL  FAR PASCAL RemoveMenu(HMENU, WORD, WORD);
BOOL  FAR PASCAL DeleteMenu(HMENU, WORD, WORD);
BOOL  FAR PASCAL SetMenuItemBitmaps(HMENU, WORD, WORD, HBITMAP, HBITMAP);
LONG  FAR PASCAL GetMenuCheckMarkDimensions(void);
BOOL  FAR PASCAL TrackPopupMenu(HMENU, WORD, int, int, int, HWND, LPRECT);

#endif /* NOMENUS */

BOOL FAR PASCAL GrayString(HDC, HBRUSH, FARPROC, DWORD, int, int, int, int, int);
void FAR PASCAL UpdateWindow(HWND);
HWND FAR PASCAL SetActiveWindow(HWND);

HDC  FAR PASCAL BeginPaint(HWND, LPPAINTSTRUCT);
void FAR PASCAL EndPaint(HWND, LPPAINTSTRUCT);
BOOL FAR PASCAL GetUpdateRect(HWND, LPRECT, BOOL);
int  FAR PASCAL GetUpdateRgn(HWND, HRGN, BOOL);

int  FAR PASCAL ExcludeUpdateRgn(HDC, HWND);

void FAR PASCAL InvalidateRect(HWND, LPRECT, BOOL);
void FAR PASCAL ValidateRect(HWND, LPRECT);

void FAR PASCAL InvalidateRgn(HWND, HRGN, BOOL);
void FAR PASCAL ValidateRgn(HWND, HRGN);

void FAR PASCAL ScrollWindow(HWND, int, int, LPRECT, LPRECT);
BOOL FAR PASCAL ScrollDC(HDC, int, int, LPRECT, LPRECT, HRGN, LPRECT);

#ifndef NOSCROLL
int  FAR PASCAL SetScrollPos(HWND, int, int, BOOL);
int  FAR PASCAL GetScrollPos(HWND, int);
void FAR PASCAL SetScrollRange(HWND, int, int, int, BOOL);
void FAR PASCAL GetScrollRange(HWND, int, LPINT, LPINT);
void FAR PASCAL ShowScrollBar(HWND, WORD, BOOL);
#endif

BOOL   FAR PASCAL SetProp(HWND, LPSTR, HANDLE);
HANDLE FAR PASCAL GetProp(HWND, LPSTR);
HANDLE FAR PASCAL RemoveProp(HWND, LPSTR);
int    FAR PASCAL EnumProps(HWND, FARPROC);
void   FAR PASCAL SetWindowText(HWND, LPSTR);
int    FAR PASCAL GetWindowText(HWND, LPSTR, int);
int    FAR PASCAL GetWindowTextLength(HWND);

void FAR PASCAL GetClientRect(HWND, LPRECT);
void FAR PASCAL GetWindowRect(HWND, LPRECT);
void FAR PASCAL AdjustWindowRect(LPRECT, LONG, BOOL);
void FAR PASCAL AdjustWindowRectEx(LPRECT, LONG, BOOL, DWORD);

#ifndef NOMB

/* MessageBox() Flags */
#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005

#define MB_ICONHAND         0x0010
#define MB_ICONQUESTION     0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000

#define MB_NOFOCUS          0x8000

#define MB_TYPEMASK         0x000F
#define MB_ICONMASK         0x00F0
#define MB_DEFMASK          0x0F00
#define MB_MODEMASK         0x3000
#define MB_MISCMASK         0xC000

int  FAR PASCAL MessageBox(HWND, LPSTR, LPSTR, WORD);
void FAR PASCAL MessageBeep(WORD);

#endif /* NOMB */

int     FAR PASCAL ShowCursor(BOOL);
void    FAR PASCAL SetCursorPos(int, int);
HCURSOR FAR PASCAL SetCursor(HCURSOR);
void    FAR PASCAL GetCursorPos(LPPOINT);
void    FAR PASCAL ClipCursor(LPRECT);

void FAR PASCAL CreateCaret(HWND, HBITMAP, int, int);
WORD FAR PASCAL GetCaretBlinkTime(void);
void FAR PASCAL SetCaretBlinkTime(WORD);
void FAR PASCAL DestroyCaret(void);
void FAR PASCAL HideCaret(HWND);
void FAR PASCAL ShowCaret(HWND);
void FAR PASCAL SetCaretPos(int, int);
void FAR PASCAL GetCaretPos(LPPOINT);

void FAR PASCAL ClientToScreen(HWND, LPPOINT);
void FAR PASCAL ScreenToClient(HWND, LPPOINT);
HWND FAR PASCAL WindowFromPoint(POINT);
HWND FAR PASCAL ChildWindowFromPoint(HWND, POINT);

#ifndef NOCOLOR

/* Color Types */
#define CTLCOLOR_MSGBOX         0
#define CTLCOLOR_EDIT           1
#define CTLCOLOR_LISTBOX        2
#define CTLCOLOR_BTN            3
#define CTLCOLOR_DLG            4
#define CTLCOLOR_SCROLLBAR      5
#define CTLCOLOR_STATIC         6
#define CTLCOLOR_MAX            8     /* three bits max */

#define COLOR_SCROLLBAR         0
#define COLOR_BACKGROUND        1
#define COLOR_ACTIVECAPTION     2
#define COLOR_INACTIVECAPTION   3
#define COLOR_MENU              4
#define COLOR_WINDOW            5
#define COLOR_WINDOWFRAME       6
#define COLOR_MENUTEXT          7
#define COLOR_WINDOWTEXT        8
#define COLOR_CAPTIONTEXT       9
#define COLOR_ACTIVEBORDER      10
#define COLOR_INACTIVEBORDER    11
#define COLOR_APPWORKSPACE      12
#define COLOR_HIGHLIGHT         13
#define COLOR_HIGHLIGHTTEXT     14
#define COLOR_BTNFACE           15
#define COLOR_BTNSHADOW         16
#define COLOR_GRAYTEXT          17
#define COLOR_BTNTEXT           18
#define COLOR_ENDCOLORS         COLOR_BTNTEXT

DWORD FAR PASCAL GetSysColor(int);
void  FAR PASCAL SetSysColors(int, LPINT, LONG FAR *);

#endif /* NOCOLOR */

BOOL FAR PASCAL FillRgn(HDC, HRGN, HBRUSH);
BOOL FAR PASCAL FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL FAR PASCAL InvertRgn(HDC, HRGN);
BOOL FAR PASCAL PaintRgn(HDC, HRGN);
BOOL FAR PASCAL PtInRegion(HRGN, int, int);

void FAR PASCAL DrawFocusRect(HDC, LPRECT);
int  FAR PASCAL FillRect(HDC, LPRECT, HBRUSH);
int  FAR PASCAL FrameRect(HDC, LPRECT, HBRUSH);
void FAR PASCAL InvertRect(HDC, LPRECT);
void FAR PASCAL SetRect(LPRECT, int, int, int, int);
void FAR PASCAL SetRectEmpty(LPRECT);
int  FAR PASCAL CopyRect(LPRECT, LPRECT);
void FAR PASCAL InflateRect(LPRECT, int, int);
int  FAR PASCAL IntersectRect(LPRECT, LPRECT, LPRECT);
int  FAR PASCAL UnionRect(LPRECT, LPRECT, LPRECT);
void FAR PASCAL OffsetRect(LPRECT, int, int);
BOOL FAR PASCAL IsRectEmpty(LPRECT);
BOOL FAR PASCAL EqualRect(LPRECT, LPRECT);
BOOL FAR PASCAL PtInRect(LPRECT, POINT);
BOOL FAR PASCAL RectVisible(HDC, LPRECT);
BOOL FAR PASCAL RectInRegion(HRGN, LPRECT);

DWORD FAR PASCAL GetCurrentTime(void);
DWORD FAR PASCAL GetTickCount(void);

#ifndef NOWINOFFSETS

WORD FAR PASCAL GetWindowWord(HWND, int);
WORD FAR PASCAL SetWindowWord(HWND, int, WORD);
LONG FAR PASCAL GetWindowLong(HWND, int);
LONG FAR PASCAL SetWindowLong(HWND, int, LONG);
WORD FAR PASCAL GetClassWord(HWND, int);
WORD FAR PASCAL SetClassWord(HWND, int, WORD);
LONG FAR PASCAL GetClassLong(HWND, int);
LONG FAR PASCAL SetClassLong(HWND, int, LONG);
HWND FAR PASCAL GetDesktopHwnd(void);
HWND FAR PASCAL GetDesktopWindow(void);

#endif /* NOWINOFFSETS */

HWND   FAR PASCAL GetParent(HWND);
HWND   FAR PASCAL SetParent(HWND, HWND);
BOOL   FAR PASCAL EnumChildWindows(HWND, FARPROC, LONG);
HWND   FAR PASCAL FindWindow(LPSTR, LPSTR);
BOOL   FAR PASCAL EnumWindows(FARPROC, LONG);
BOOL   FAR PASCAL EnumTaskWindows(HANDLE, FARPROC, LONG);
int    FAR PASCAL GetClassName(HWND, LPSTR, int);
HWND   FAR PASCAL GetTopWindow(HWND);
HWND   FAR PASCAL GetNextWindow(HWND, WORD);
HANDLE FAR PASCAL GetWindowTask(HWND);
HWND   FAR PASCAL GetLastActivePopup(HWND);

/* GetWindow() Constants */
#define GW_HWNDFIRST        0
#define GW_HWNDLAST         1
#define GW_HWNDNEXT         2
#define GW_HWNDPREV         3
#define GW_OWNER            4
#define GW_CHILD            5

HWND FAR PASCAL GetWindow(HWND, WORD);

#ifndef NOWH
FARPROC FAR PASCAL SetWindowsHook(int, FARPROC);
BOOL    FAR PASCAL UnhookWindowsHook(int, FARPROC);
DWORD   FAR PASCAL DefHookProc(int, WORD, DWORD, FARPROC FAR *);
#endif

#ifndef NOMENUS

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_INSERT          0x0000
#define MF_CHANGE          0x0080
#define MF_APPEND          0x0100
#define MF_DELETE          0x0200
#define MF_REMOVE          0x1000

#define MF_BYCOMMAND       0x0000
#define MF_BYPOSITION      0x0400


#define MF_SEPARATOR       0x0800

#define MF_ENABLED         0x0000
#define MF_GRAYED          0x0001
#define MF_DISABLED        0x0002

#define MF_UNCHECKED       0x0000
#define MF_CHECKED         0x0008
#define MF_USECHECKBITMAPS 0x0200

#define MF_STRING          0x0000
#define MF_BITMAP          0x0004
#define MF_OWNERDRAW       0x0100

#define MF_POPUP           0x0010
#define MF_MENUBARBREAK    0x0020
#define MF_MENUBREAK       0x0040

#define MF_UNHILITE        0x0000
#define MF_HILITE          0x0080

#define MF_SYSMENU         0x2000
#define MF_HELP            0x4000
#define MF_MOUSESELECT     0x8000

/* Menu item resource format */
typedef struct
  {
    WORD versionNumber;
    WORD offset;
  } MENUITEMTEMPLATEHEADER;

typedef struct
  {
    WORD  mtOption;
    WORD  mtID;
    char  mtString[1];
  } MENUITEMTEMPLATE;

#define MF_END             0x0080

#endif /* NOMENUS */

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130

#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

#endif /* NOSYSCOMMANDS */

/* Resource Loading Routines */
HBITMAP FAR PASCAL LoadBitmap(HANDLE, LPSTR);
HCURSOR FAR PASCAL LoadCursor(HANDLE, LPSTR);
HCURSOR FAR PASCAL CreateCursor(HANDLE, int, int, int, int, LPSTR, LPSTR);
BOOL    FAR PASCAL DestroyCursor(HCURSOR);

/* Standard Cursor IDs */
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)
#define IDC_WAIT            MAKEINTRESOURCE(32514)
#define IDC_CROSS           MAKEINTRESOURCE(32515)
#define IDC_UPARROW         MAKEINTRESOURCE(32516)
#define IDC_SIZE            MAKEINTRESOURCE(32640)
#define IDC_ICON            MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)

HICON FAR PASCAL LoadIcon(HANDLE, LPSTR);
HICON FAR PASCAL CreateIcon(HANDLE, int, int, BYTE, BYTE, LPSTR, LPSTR);
BOOL  FAR PASCAL DestroyIcon(HICON);


#define ORD_LANGDRIVER    1     /* The ordinal number for the entry point of
                                ** language drivers.
                                */

#ifndef NOICONS

/* Standard Icon IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)

#endif /* NOICONS */

int  FAR PASCAL LoadString(HANDLE, WORD, LPSTR, int);

int  FAR PASCAL AddFontResource(LPSTR);
BOOL FAR PASCAL RemoveFontResource(LPSTR);

#ifndef NOKANJI

#define CP_HWND             0
#define CP_OPEN             1
#define CP_DIRECT           2

/* VK from the keyboard driver */
#define VK_KANA             0x15
#define VK_ROMAJI           0x16
#define VK_ZENKAKU          0x17
#define VK_HIRAGANA         0x18
#define VK_KANJI            0x19

/* VK to send to Applications */
#define VK_CONVERT          0x1C
#define VK_NONCONVERT       0x1D
#define VK_ACCEPT           0x1E
#define VK_MODECHANGE       0x1F

/* Conversion function numbers */
#define KNJ_START           0x01
#define KNJ_END             0x02
#define KNJ_QUERY           0x03

#define KNJ_LEARN_MODE      0x10
#define KNJ_GETMODE         0x11
#define KNJ_SETMODE         0x12

#define KNJ_CODECONVERT     0x20
#define KNJ_CONVERT         0x21
#define KNJ_NEXT            0x22
#define KNJ_PREVIOUS        0x23
#define KNJ_ACCEPT          0x24

#define KNJ_LEARN           0x30
#define KNJ_REGISTER        0x31
#define KNJ_REMOVE          0x32
#define KNJ_CHANGE_UDIC     0x33

/* NOTE: DEFAULT        = 0
 *       JIS1           = 1
 *       JIS2           = 2
 *       SJIS2          = 3
 *       JIS1KATAKANA   = 4
 *       SJIS2HIRAGANA  = 5
 *       SJIS2KATAKANA  = 6
 *       OEM            = F
 */

#define KNJ_JIS1toJIS1KATAKANA  0x14
#define KNJ_JIS1toSJIS2         0x13
#define KNJ_JIS1toSJIS2HIRAGANA 0x15
#define KNJ_JIS1toSJIS2KATAKANA 0x16
#define KNJ_JIS1toDEFAULT       0x10
#define KNJ_JIS1toSJIS2OEM      0x1F
#define KNJ_JIS2toSJIS2         0x23
#define KNJ_SJIS2toJIS2         0x32

#define KNJ_MD_ALPHA            0x01
#define KNJ_MD_HIRAGANA         0x02
#define KNJ_MD_HALF             0x04
#define KNJ_MD_JIS              0x08
#define KNJ_MD_SPECIAL          0x10

#define KNJ_CVT_NEXT            0x01
#define KNJ_CVT_PREV            0x02
#define KNJ_CVT_KATAKANA        0x03
#define KNJ_CVT_HIRAGANA        0x04
#define KNJ_CVT_JIS1            0x05
#define KNJ_CVT_SJIS2           0x06
#define KNJ_CVT_DEFAULT         0x07
#define KNJ_CVT_TYPED           0x08

typedef struct
  {
    int         fnc;
    int         wParam;
    LPSTR       lpSource;
    LPSTR       lpDest;
    int         wCount;
    LPSTR       lpReserved1;
    LPSTR       lpReserved2;
  } KANJISTRUCT, FAR *LPKANJISTRUCT;

int  FAR PASCAL ConvertRequest(HWND, LPKANJISTRUCT);
BOOL FAR PASCAL SetConvertParams(int, int);
VOID FAR PASCAL SetConvertHook(BOOL);

#endif

/* Key Conversion Window */
BOOL FAR PASCAL IsTwoByteCharPrefix(char);

/* Dialog Box Command IDs */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7

#ifndef NOCTLMGR

/* Control Manager Structures and Definitions */

#ifndef NOWINSTYLES

/* Edit Control Styles */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L


#endif /* NOWINSTYLES */

/* Edit Control Notification Codes */
#define EN_SETFOCUS         0x0100
#define EN_KILLFOCUS        0x0200
#define EN_CHANGE           0x0300
#define EN_UPDATE           0x0400
#define EN_ERRSPACE         0x0500
#define EN_MAXTEXT          0x0501
#define EN_HSCROLL          0x0601
#define EN_VSCROLL          0x0602

#ifndef NOWINMESSAGES

/* Edit Control Messages */
#define EM_GETSEL          (WM_USER+0)
#define EM_SETSEL          (WM_USER+1)
#define EM_GETRECT         (WM_USER+2)
#define EM_SETRECT         (WM_USER+3)
#define EM_SETRECTNP       (WM_USER+4)
#define EM_SCROLL          (WM_USER+5)
#define EM_LINESCROLL      (WM_USER+6)
#define EM_GETMODIFY       (WM_USER+8)
#define EM_SETMODIFY       (WM_USER+9)
#define EM_GETLINECOUNT    (WM_USER+10)
#define EM_LINEINDEX       (WM_USER+11)
#define EM_SETHANDLE       (WM_USER+12)
#define EM_GETHANDLE       (WM_USER+13)
#define EM_GETTHUMB        (WM_USER+14)
#define EM_LINELENGTH      (WM_USER+17)
#define EM_REPLACESEL      (WM_USER+18)
#define EM_SETFONT         (WM_USER+19)
#define EM_GETLINE         (WM_USER+20)
#define EM_LIMITTEXT       (WM_USER+21)
#define EM_CANUNDO         (WM_USER+22)
#define EM_UNDO            (WM_USER+23)
#define EM_FMTLINES        (WM_USER+24)
#define EM_LINEFROMCHAR    (WM_USER+25)
#define EM_SETWORDBREAK    (WM_USER+26)
#define EM_SETTABSTOPS     (WM_USER+27)
#define EM_SETPASSWORDCHAR (WM_USER+28)
#define EM_EMPTYUNDOBUFFER (WM_USER+29)
#define EM_MSGMAX          (WM_USER+30)

#endif /* NOWINMESSAGES */

/* Button Control Styles */
#define BS_PUSHBUTTON      0x00L
#define BS_DEFPUSHBUTTON   0x01L
#define BS_CHECKBOX        0x02L
#define BS_AUTOCHECKBOX    0x03L
#define BS_RADIOBUTTON     0x04L
#define BS_3STATE          0x05L
#define BS_AUTO3STATE      0x06L
#define BS_GROUPBOX        0x07L
#define BS_USERBUTTON      0x08L
#define BS_AUTORADIOBUTTON 0x09L
#define BS_PUSHBOX         0x0AL
#define BS_OWNERDRAW       0x0BL
#define BS_LEFTTEXT        0x20L


/* User Button Notification Codes */
#define BN_CLICKED         0
#define BN_PAINT           1
#define BN_HILITE          2
#define BN_UNHILITE        3
#define BN_DISABLE         4
#define BN_DOUBLECLICKED   5

/* Button Control Messages */
#define BM_GETCHECK        (WM_USER+0)
#define BM_SETCHECK        (WM_USER+1)
#define BM_GETSTATE        (WM_USER+2)
#define BM_SETSTATE        (WM_USER+3)
#define BM_SETSTYLE        (WM_USER+4)

/* Static Control Constants */
#define SS_LEFT            0x00L
#define SS_CENTER          0x01L
#define SS_RIGHT           0x02L
#define SS_ICON            0x03L
#define SS_BLACKRECT       0x04L
#define SS_GRAYRECT        0x05L
#define SS_WHITERECT       0x06L
#define SS_BLACKFRAME      0x07L
#define SS_GRAYFRAME       0x08L
#define SS_WHITEFRAME      0x09L
#define SS_USERITEM        0x0AL
#define SS_SIMPLE          0x0BL
#define SS_LEFTNOWORDWRAP  0x0CL
#define SS_NOPREFIX        0x80L    /* Don't do "&" character translation */

/* Dialog Manager Routines */

#ifndef NOMSG
BOOL FAR PASCAL IsDialogMessage(HWND, LPMSG);
#endif

void FAR PASCAL MapDialogRect(HWND, LPRECT);

int  FAR PASCAL DlgDirList(HWND, LPSTR, int, int, WORD);
BOOL FAR PASCAL DlgDirSelect(HWND, LPSTR, int);
int  FAR PASCAL DlgDirListComboBox(HWND, LPSTR, int, int, WORD);
BOOL FAR PASCAL DlgDirSelectComboBox(HWND, LPSTR, int);


/* Dialog Styles */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L   /* Edit items get Local storage. */
#define DS_SETFONT          0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME       0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG        0x100L  /* WM_ENTERIDLE message will not be sent */

#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)
#define DC_HASDEFID         0x534B

/* Dialog Codes */
#define DLGC_WANTARROWS     0x0001      /* Control wants arrow keys         */
#define DLGC_WANTTAB        0x0002      /* Control wants tab keys           */
#define DLGC_WANTALLKEYS    0x0004      /* Control wants all keys           */
#define DLGC_WANTMESSAGE    0x0004      /* Pass message to control          */
#define DLGC_HASSETSEL      0x0008      /* Understands EM_SETSEL message    */
#define DLGC_DEFPUSHBUTTON  0x0010      /* Default pushbutton               */
#define DLGC_UNDEFPUSHBUTTON 0x0020     /* Non-default pushbutton           */
#define DLGC_RADIOBUTTON    0x0040      /* Radio button                     */
#define DLGC_WANTCHARS      0x0080      /* Want WM_CHAR messages            */
#define DLGC_STATIC         0x0100      /* Static item: don't include       */
#define DLGC_BUTTON         0x2000      /* Button item: can be checked      */

#define LB_CTLCODE          0L

/* Listbox Return Values */
#define LB_OKAY             0
#define LB_ERR              (-1)
#define LB_ERRSPACE         (-2)

/*
**  The idStaticPath parameter to DlgDirList can have the following values
**  ORed if the list box should show other details of the files along with
**  the name of the files;
*/
                                  /* all other details also will be returned */


/* Listbox Notification Codes */
#define LBN_ERRSPACE        (-2)
#define LBN_SELCHANGE       1
#define LBN_DBLCLK          2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5



#ifndef NOWINMESSAGES

/* Listbox messages */
#define LB_ADDSTRING           (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL              (WM_USER+6)
#define LB_SETCURSEL           (WM_USER+7)
#define LB_GETSEL              (WM_USER+8)
#define LB_GETCURSEL           (WM_USER+9)
#define LB_GETTEXT             (WM_USER+10)
#define LB_GETTEXTLEN          (WM_USER+11)
#define LB_GETCOUNT            (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR                 (WM_USER+14)
#define LB_GETTOPINDEX         (WM_USER+15)
#define LB_FINDSTRING          (WM_USER+16)
#define LB_GETSELCOUNT         (WM_USER+17)
#define LB_GETSELITEMS         (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_SETTOPINDEX         (WM_USER+24)
#define LB_GETITEMRECT         (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_MSGMAX              (WM_USER+33)

#endif /* NOWINMESSAGES */

#ifndef NOWINSTYLES

/* Listbox Styles */
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#endif /* NOWINSTYLES */


/* Combo Box return Values */
#define CB_OKAY             0
#define CB_ERR              (-1)
#define CB_ERRSPACE         (-2)


/* Combo Box Notification Codes */
#define CBN_ERRSPACE        (-1)
#define CBN_SELCHANGE       1
#define CBN_DBLCLK          2
#define CBN_SETFOCUS        3
#define CBN_KILLFOCUS       4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7

/* Combo Box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#endif  /* NOWINSTYLES */


/* Combo Box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL            (WM_USER+0)
#define CB_LIMITTEXT             (WM_USER+1)
#define CB_SETEDITSEL            (WM_USER+2)
#define CB_ADDSTRING             (WM_USER+3)
#define CB_DELETESTRING          (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT              (WM_USER+6)
#define CB_GETCURSEL             (WM_USER+7)
#define CB_GETLBTEXT             (WM_USER+8)
#define CB_GETLBTEXTLEN          (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT          (WM_USER+11)
#define CB_FINDSTRING            (WM_USER+12)
#define CB_SELECTSTRING          (WM_USER+13)
#define CB_SETCURSEL             (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_MSGMAX                (WM_USER+19)
#endif  /* NOWINMESSAGES */



#ifndef NOWINSTYLES

/* Scroll Bar Styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

#endif /* NOWINSTYLES */

#endif /* NOCTLMGR */

#ifndef NOSOUND

int   FAR PASCAL OpenSound(void);
void  FAR PASCAL CloseSound(void);
int   FAR PASCAL SetVoiceQueueSize(int, int);
int   FAR PASCAL SetVoiceNote(int, int, int, int);
int   FAR PASCAL SetVoiceAccent(int, int, int, int, int);
int   FAR PASCAL SetVoiceEnvelope(int, int, int);
int   FAR PASCAL SetSoundNoise(int, int);
int   FAR PASCAL SetVoiceSound(int, LONG, int);
int   FAR PASCAL StartSound(void);
int   FAR PASCAL StopSound(void);
int   FAR PASCAL WaitSoundState(int);
int   FAR PASCAL SyncAllVoices(void);
int   FAR PASCAL CountVoiceNotes(int);
LPINT FAR PASCAL GetThresholdEvent(void);
int   FAR PASCAL GetThresholdStatus(void);
int   FAR PASCAL SetVoiceThreshold(int, int);

/* WaitSoundState() Constants */
#define S_QUEUEEMPTY        0
#define S_THRESHOLD         1
#define S_ALLTHRESHOLD      2

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* SetSoundNoise() Sources */
#define S_PERIOD512   0     /* Freq = N/512 high pitch, less coarse hiss  */
#define S_PERIOD1024  1     /* Freq = N/1024                              */
#define S_PERIOD2048  2     /* Freq = N/2048 low pitch, more coarse hiss  */
#define S_PERIODVOICE 3     /* Source is frequency from voice channel (3) */
#define S_WHITE512    4     /* Freq = N/512 high pitch, less coarse hiss  */
#define S_WHITE1024   5     /* Freq = N/1024                              */
#define S_WHITE2048   6     /* Freq = N/2048 low pitch, more coarse hiss  */
#define S_WHITEVOICE  7     /* Source is frequency from voice channel (3) */

#define S_SERDVNA     (-1)  /* Device not available */
#define S_SEROFM      (-2)  /* Out of memory        */
#define S_SERMACT     (-3)  /* Music active         */
#define S_SERQFUL     (-4)  /* Queue full           */
#define S_SERBDNT     (-5)  /* Invalid note         */
#define S_SERDLN      (-6)  /* Invalid note length  */
#define S_SERDCC      (-7)  /* Invalid note count   */
#define S_SERDTP      (-8)  /* Invalid tempo        */
#define S_SERDVL      (-9)  /* Invalid volume       */
#define S_SERDMD      (-10) /* Invalid mode         */
#define S_SERDSH      (-11) /* Invalid shape        */
#define S_SERDPT      (-12) /* Invalid pitch        */
#define S_SERDFQ      (-13) /* Invalid frequency    */
#define S_SERDDR      (-14) /* Invalid duration     */
#define S_SERDSR      (-15) /* Invalid source       */
#define S_SERDST      (-16) /* Invalid state        */

#endif /* NOSOUND */

#ifndef NOCOMM

#define NOPARITY            0
#define ODDPARITY           1
#define EVENPARITY          2
#define MARKPARITY          3
#define SPACEPARITY         4

#define ONESTOPBIT          0
#define ONE5STOPBITS        1
#define TWOSTOPBITS         2

#define IGNORE              0       /* Ignore signal    */
#define INFINITE            0xFFFF  /* Infinite timeout */

/* Error Flags */
#define CE_RXOVER           0x0001  /* Receive Queue overflow       */
#define CE_OVERRUN          0x0002  /* Receive Overrun Error        */
#define CE_RXPARITY         0x0004  /* Receive Parity Error         */
#define CE_FRAME            0x0008  /* Receive Framing error        */
#define CE_BREAK            0x0010  /* Break Detected               */
#define CE_CTSTO            0x0020  /* CTS Timeout                  */
#define CE_DSRTO            0x0040  /* DSR Timeout                  */
#define CE_RLSDTO           0x0080  /* RLSD Timeout                 */
#define CE_TXFULL           0x0100  /* TX Queue is full             */
#define CE_PTO              0x0200  /* LPTx Timeout                 */
#define CE_IOE              0x0400  /* LPTx I/O Error               */
#define CE_DNS              0x0800  /* LPTx Device not selected     */
#define CE_OOP              0x1000  /* LPTx Out-Of-Paper            */
#define CE_MODE             0x8000  /* Requested mode unsupported   */

#define IE_BADID            (-1)    /* Invalid or unsupported id    */
#define IE_OPEN             (-2)    /* Device Already Open          */
#define IE_NOPEN            (-3)    /* Device Not Open              */
#define IE_MEMORY           (-4)    /* Unable to allocate queues    */
#define IE_DEFAULT          (-5)    /* Error in default parameters  */
#define IE_HARDWARE         (-10)   /* Hardware Not Present         */
#define IE_BYTESIZE         (-11)   /* Illegal Byte Size            */
#define IE_BAUDRATE         (-12)   /* Unsupported BaudRate         */

/* Events */
#define EV_RXCHAR           0x0001  /* Any Character received       */
#define EV_RXFLAG           0x0002  /* Received certain character   */
#define EV_TXEMPTY          0x0004  /* Transmitt Queue Empty        */
#define EV_CTS              0x0008  /* CTS changed state            */
#define EV_DSR              0x0010  /* DSR changed state            */
#define EV_RLSD             0x0020  /* RLSD changed state           */
#define EV_BREAK            0x0040  /* BREAK received               */
#define EV_ERR              0x0080  /* Line status error occurred   */
#define EV_RING             0x0100  /* Ring signal detected         */
#define EV_PERR             0x0200  /* Printer error occured        */

/* Escape Functions */
#define SETXOFF             1       /* Simulate XOFF received       */
#define SETXON              2       /* Simulate XON received        */
#define SETRTS              3       /* Set RTS high                 */
#define CLRRTS              4       /* Set RTS low                  */
#define SETDTR              5       /* Set DTR high                 */
#define CLRDTR              6       /* Set DTR low                  */
#define RESETDEV            7       /* Reset device if possible     */

#define LPTx                0x80    /* Set if ID is for LPT device  */

typedef struct tagDCB
  {
    BYTE Id;              /* Internal Device ID              */
    WORD BaudRate;        /* Baud rate at which runing       */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    WORD RlsTimeout;      /* Timeout for RLSD to be set      */
    WORD CtsTimeout;      /* Timeout for CTS to be set       */
    WORD DsrTimeout;      /* Timeout for DSR to be set       */

    BYTE fBinary: 1;      /* Binary Mode (skip EOF check     */
    BYTE fRtsDisable:1;   /* Don't assert RTS at init time   */
    BYTE fParity: 1;      /* Enable parity checking          */
    BYTE fOutxCtsFlow:1;  /* CTS handshaking on output       */
    BYTE fOutxDsrFlow:1;  /* DSR handshaking on output       */
    BYTE fDummy: 2;       /* Reserved                        */
    BYTE fDtrDisable:1;   /* Don't assert DTR at init time   */

    BYTE fOutX: 1;        /* Enable output X-ON/X-OFF        */
    BYTE fInX: 1;         /* Enable input X-ON/X-OFF         */
    BYTE fPeChar: 1;      /* Enable Parity Err Replacement   */
    BYTE fNull: 1;        /* Enable Null stripping           */
    BYTE fChEvt: 1;       /* Enable Rx character event.      */
    BYTE fDtrflow: 1;     /* DTR handshake on input          */
    BYTE fRtsflow: 1;     /* RTS handshake on input          */
    BYTE fDummy2: 1;

    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    char PeChar;          /* Parity error replacement char   */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Received Event character        */
    WORD TxDelay;         /* Amount of time between chars    */
  } DCB;

typedef struct tagCOMSTAT
  {
    BYTE fCtsHold: 1;   /* Transmit is on CTS hold         */
    BYTE fDsrHold: 1;   /* Transmit is on DSR hold         */
    BYTE fRlsdHold: 1;  /* Transmit is on RLSD hold        */
    BYTE fXoffHold: 1;  /* Received handshake              */
    BYTE fXoffSent: 1;  /* Issued handshake                */
    BYTE fEof: 1;       /* End of file character found     */
    BYTE fTxim: 1;      /* Character being transmitted     */
    WORD cbInQue;       /* count of characters in Rx Queue */
    WORD cbOutQue;      /* count of characters in Tx Queue */
  } COMSTAT;

int  FAR PASCAL OpenComm(LPSTR, WORD, WORD);
int  FAR PASCAL SetCommState(DCB FAR *);
int  FAR PASCAL GetCommState(int, DCB FAR *);
int  FAR PASCAL ReadComm(int, LPSTR, int);
int  FAR PASCAL UngetCommChar(int, char);
int  FAR PASCAL WriteComm(int, LPSTR, int);
int  FAR PASCAL CloseComm(int);
int  FAR PASCAL GetCommError(int, COMSTAT FAR *);
int  FAR PASCAL BuildCommDCB(LPSTR, DCB FAR *);
int  FAR PASCAL TransmitCommChar(int, char);
WORD FAR * FAR PASCAL SetCommEventMask(int, WORD);
WORD FAR PASCAL GetCommEventMask(int, int);
int  FAR PASCAL SetCommBreak(int);
int  FAR PASCAL ClearCommBreak(int);
int  FAR PASCAL FlushComm(int, int);
int  FAR PASCAL EscapeCommFunction(int, int);

#endif /* NOCOMM */

#ifndef NOMDI

typedef struct tagMDICREATESTRUCT
  {
    LPSTR szClass;
    LPSTR szTitle;
    HANDLE hOwner;
    int x,y;
    int cx,cy;
    LONG style;
    LONG lParam;        /* app-defined stuff */
  } MDICREATESTRUCT;

typedef MDICREATESTRUCT FAR * LPMDICREATESTRUCT;

typedef struct tagCLIENTCREATESTRUCT
  {
    HANDLE hWindowMenu;
    WORD idFirstChild;
  } CLIENTCREATESTRUCT;

typedef CLIENTCREATESTRUCT FAR * LPCLIENTCREATESTRUCT;

LONG FAR PASCAL DefFrameProc(HWND,HWND,WORD,WORD,LONG);
LONG FAR PASCAL DefMDIChildProc(HWND,WORD,WORD,LONG);

#ifndef NOMSG
BOOL FAR PASCAL TranslateMDISysAccel(HWND,LPMSG);
#endif

WORD FAR PASCAL ArrangeIconicWindows(HWND);

#endif /* NOMDI */

#endif /* NOUSER */

#ifndef NOHELP

/*  Help engine section.  */

/* Commands to pass WinHelp() */
#define HELP_CONTEXT    0x0001   /* Display topic in ulTopic */
#define HELP_QUIT       0x0002   /* Terminate help */
#define HELP_INDEX      0x0003   /* Display index */
#define HELP_HELPONHELP 0x0004   /* Display help on using help */
#define HELP_SETINDEX   0x0005   /* Set the current Index for multi index help */
#define HELP_KEY        0x0101   /* Display topic for keyword in offabData */
#define HELP_MULTIKEY   0x0201

BOOL FAR PASCAL WinHelp(HWND hwndMain, LPSTR lpszHelp, WORD usCommand, DWORD ulData);

typedef struct tagMULTIKEYHELP
  {
    WORD    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
  } MULTIKEYHELP;

#endif /* NOHELP */

#ifndef NOPROFILER

/* function declarations for profiler routines contained in Windows libraries */
int  far pascal ProfInsChk(void);
void far pascal ProfSetup(int,int);
void far pascal ProfSampRate(int,int);
void far pascal ProfStart(void);
void far pascal ProfStop(void);
void far pascal ProfClear(void);
void far pascal ProfFlush(void);
void far pascal ProfFinish(void);

#endif /* NOPROFILER */

int PASCAL WinMain( HANDLE, HANDLE, LPSTR, int );
int FAR PASCAL LibMain( HANDLE, WORD, WORD, LPSTR );
int FAR PASCAL WEP(int);

#if defined( __cplusplus )
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.
#pragma warn .bbf
#endif

#endif  /* __WINDOWS_H */

/*  math.h

    Definitions for the math floating point package.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef  __MATH_H
#define  __MATH_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#define HUGE_VAL    _huge_dble
extern double _Cdecl _huge_dble;
#define _LHUGE_VAL   _huge_ldble
extern long double _Cdecl _huge_ldble;

#ifdef __cplusplus
extern "C" {
#endif
double  _Cdecl _FARFUNC acos  (double __x);
double  _Cdecl _FARFUNC asin  (double __x);
double  _Cdecl atan  (double __x);
double  _Cdecl _FARFUNC atan2 (double __y, double __x);
double  _Cdecl _FARFUNC ceil  (double __x);
double  _Cdecl _FARFUNC cos   (double __x);
double  _Cdecl _FARFUNC cosh  (double __x);
double  _Cdecl _FARFUNC exp   (double __x);
double  _Cdecl fabs  (double __x);
double  _Cdecl __fabs__  (double __x);          /* Intrinsic */
double  _Cdecl _FARFUNC floor (double __x);
double  _Cdecl _FARFUNC fmod  (double __x, double __y);
double  _Cdecl _FARFUNC frexp (double __x, int _FAR *__exponent);
double  _Cdecl _FARFUNC ldexp (double __x, int __exponent);
double  _Cdecl _FARFUNC log   (double __x);
double  _Cdecl _FARFUNC log10 (double __x);
double  _Cdecl _FARFUNC modf  (double __x, double _FAR *__ipart);
double  _Cdecl _FARFUNC pow   (double __x, double __y);
double  _Cdecl _FARFUNC sin   (double __x);
double  _Cdecl _FARFUNC sinh  (double __x);
double  _Cdecl _FARFUNC sqrt  (double __x);
double  _Cdecl _FARFUNC tan   (double __x);
double  _Cdecl _FARFUNC tanh  (double __x);

long double _Cdecl _FARFUNC acosl  (long double __x);
long double _Cdecl _FARFUNC asinl  (long double __x);
long double _Cdecl _FARFUNC atan2l (long double __x, long double __y);
long double _Cdecl atanl  (long double __x);
long double _Cdecl _FARFUNC ceill  (long double __x);
long double _Cdecl _FARFUNC coshl  (long double __x);
long double _Cdecl _FARFUNC cosl   (long double __x);
long double _Cdecl _FARFUNC expl   (long double __x);
long double _Cdecl fabsl  (long double __x);
long double _Cdecl _FARFUNC floorl (long double __x);
long double _Cdecl _FARFUNC fmodl  (long double __x, long double __y);
long double _Cdecl _FARFUNC frexpl (long double __x, int _FAR *__exponent);
long double _Cdecl _FARFUNC ldexpl (long double __x, int __exponent);
long double _Cdecl _FARFUNC log10l (long double __x);
long double _Cdecl _FARFUNC logl   (long double __x);
long double _Cdecl _FARFUNC modfl  (long double __x, long double _FAR *__ipart);
long double _Cdecl _FARFUNC powl   (long double __x, long double __y);
long double _Cdecl _FARFUNC sinhl  (long double __x);
long double _Cdecl _FARFUNC sinl   (long double __x);
long double _Cdecl _FARFUNC sqrtl  (long double __x);
long double _Cdecl _FARFUNC tanhl  (long double __x);
long double _Cdecl _FARFUNC tanl   (long double __x);

typedef enum
{
    DOMAIN = 1,    /* argument domain error -- log (-1)        */
    SING,          /* argument singularity  -- pow (0,-2))     */
    OVERFLOW,      /* overflow range error  -- exp (1000)      */
    UNDERFLOW,     /* underflow range error -- exp (-1000)     */
    TLOSS,         /* total loss of significance -- sin(10e70) */
    PLOSS,         /* partial loss of signif. -- not used      */
    STACKFAULT     /* floating point unit stack overflow       */
}   _mexcep;

#ifdef __cplusplus
}
#endif


#if !__STDC__

struct  exception
{
    int type;
    char   _FAR *name;
    double  arg1, arg2, retval;
};

struct  _exceptionl
{
    int type;
    char   _FAR *name;
    long double  arg1, arg2, retval;
};

#ifdef __cplusplus
extern "C" {
#endif
int     _Cdecl abs   (int __x);
double  _Cdecl atof  (const char _FAR *__s);
double  _Cdecl _FARFUNC hypot (double __x, double __y);
long    _Cdecl labs  (long __x);
int     _Cdecl _FARFUNC matherr (struct exception _FAR *__e);
double  _Cdecl _FARFUNC poly  (double __x, int __degree, double _FAR *__coeffs);
double  _Cdecl _FARFUNC pow10 (int __p);
int     _Cdecl _FARFUNC _matherrl (struct _exceptionl _FAR *__e);

long double _Cdecl _atold (const char _FAR *__s);
long double _Cdecl _FARFUNC hypotl (long double __x, long double __y);
long double _Cdecl _FARFUNC polyl  (long double __x, int __degree, long double _FAR *__coeffs);
long double _Cdecl _FARFUNC pow10l (int __p);

#ifdef __cplusplus
    /* use class complex instead of cabs in C++ */
#else
struct complex      /* as used by "cabs" function */
{
    double  x, y;
};

struct _complexl    /* as used by "cabsl" function */
{
    long double  x, y;
};

#define cabs(z)     (hypot  ((z).x, (z).y))
#define cabsl(z)    (hypotl ((z).x, (z).y))
#endif

#ifdef __cplusplus
}
#endif

/* Constants rounded for 21 decimals. */
#define M_E         2.71828182845904523536
#define M_LOG2E     1.44269504088896340736
#define M_LOG10E    0.434294481903251827651
#define M_LN2       0.693147180559945309417
#define M_LN10      2.30258509299404568402
#define M_PI        3.14159265358979323846
#define M_PI_2      1.57079632679489661923
#define M_PI_4      0.785398163397448309616
#define M_1_PI      0.318309886183790671538
#define M_2_PI      0.636619772367581343076
#define M_1_SQRTPI  0.564189583547756286948
#define M_2_SQRTPI  1.12837916709551257390
#define M_SQRT2     1.41421356237309504880
#define M_SQRT_2    0.707106781186547524401

#define EDOM    33      /* Math argument */
#define ERANGE  34      /* Result too large */

#endif  /* !__STDC__ */

#endif
/*  stdlib.h

    Definitions for common types, variables, and functions.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __STDLIB_H
#define __STDLIB_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef NULL
#include <_null.h>
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifndef _DIV_T
#define _DIV_T
typedef struct {
        int     quot;
        int     rem;
} div_t;
#endif

#ifndef _LDIV_T
#define _LDIV_T
typedef struct {
        long    quot;
        long    rem;
} ldiv_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif

/* Old typedef
*/
typedef void _Cdecl (* atexit_t)(void);

/* Maximum value returned by "rand" function
*/
#define RAND_MAX 0x7FFFU

#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1

#define MB_CUR_MAX 1

#ifdef __cplusplus
extern "C" {
#endif

void        _Cdecl abort(void);
int         _Cdecl __abs__(int);
#ifdef __cplusplus
inline int _Cdecl  abs(int __x) { return __abs__(__x); }
#else
int         _CType abs(int __x);
#  define abs(x)   __abs__(x)
#endif
int         _Cdecl atexit(void (_Cdecl *__func)(void));
double      _Cdecl atof(const char _FAR *__s);
int         _CType atoi(const char _FAR *__s);
long        _CType atol(const char _FAR *__s);
void _FAR * _CType bsearch(const void _FAR *__key, const void _FAR *__base,
               size_t __nelem, size_t __width,
               int (_CType *fcmp)(const void _FAR *,
               const void _FAR *));
void _FAR * _Cdecl calloc(size_t __nitems, size_t __size);
div_t       _Cdecl div(int __numer, int __denom);
void        _Cdecl exit(int __status);
void        _Cdecl free(void _FAR *__block);
char _FAR * _CType getenv(const char _FAR *__name);
long        _Cdecl labs(long __x);
ldiv_t      _Cdecl ldiv(long __numer, long __denom);
void _FAR * _Cdecl malloc(size_t __size);
int         _Cdecl mblen(const char _FAR *__s, size_t __n);
size_t      _Cdecl mbstowcs(wchar_t _FAR *__pwcs, const char _FAR *__s,
            size_t __n);
int     _Cdecl _FARFUNC mbtowc(wchar_t _FAR *__pwc, const char _FAR *__s, size_t __n);
void    _CType _FARFUNC qsort(void _FAR *__base, size_t __nelem, size_t __width,
        int _CType (*_FARFUNC __fcmp)(const void _FAR *, const void _FAR *));
int     _Cdecl rand(void);
void _FAR *_Cdecl realloc(void _FAR *__block, size_t __size);
void    _Cdecl srand(unsigned __seed);
double  _Cdecl strtod(const char _FAR *__s, char _FAR *_FAR *__endptr);
long    _Cdecl _FARFUNC strtol(const char _FAR *__s, char _FAR *_FAR *__endptr,
              int __radix);
long double _Cdecl _strtold(const char _FAR *__s, char _FAR *_FAR *__endptr);
unsigned long _Cdecl _FARFUNC strtoul(const char _FAR *__s, char _FAR *_FAR *__endptr,
                 int __radix);
int     _Cdecl _FARFUNC system(const char _FAR *__command);
size_t  _Cdecl _FARFUNC wcstombs(char _FAR *__s, const wchar_t _FAR *__pwcs,
            size_t __n);
int     _Cdecl _FARFUNC wctomb(char _FAR *__s, wchar_t __wc);

#ifdef __cplusplus
}
#endif

#if !__STDC__

/* Variables */

#if defined( _RTLDLL )

#ifdef __cplusplus
extern "C" {
#endif

int far * far _Cdecl __getErrno(void);
int far * far _Cdecl __getDOSErrno(void);

#ifdef __cplusplus
}
#endif

#define errno (*__getErrno())
#define _doserrno (*__getDOSErrno())

#else

extern  int   _Cdecl _doserrno;
extern  int   _Cdecl errno;

#endif

/*
  These 2 constants are defined in MS's stdlib.h.  Rather than defining them
  all the time and invading the ANSI programmers name space we'll only make
  them visible when __STDC__ is *off*.  Anybody using these constants ain't
  writing standard C anyway!
*/
#define DOS_MODE  0
#define OS2_MODE  1

extern  unsigned        _Cdecl _psp;

extern  char          **_Cdecl environ;
extern  int             _Cdecl _fmode;
extern  unsigned char   _Cdecl _osmajor;
extern  unsigned char   _Cdecl _osminor;
extern  unsigned int    _Cdecl _version;

#if defined( _RTLDLL )

#ifdef __cplusplus
extern "C" {
#endif
extern  char far * far * far _Cdecl __get_sys_errlist(void);
extern  int  far _Cdecl __get_sys_nerr(void);
#ifdef __cplusplus
}
#endif

#define sys_errlist __get_sys_errlist()
#define sys_nerr __get_sys_nerr()

#else

extern  char           _FAR *_Cdecl sys_errlist[];
extern  int             _Cdecl sys_nerr;

#endif

/* Constants for MSC pathname functions */

#define _MAX_PATH       80
#define _MAX_DRIVE      3
#define _MAX_DIR        66
#define _MAX_FNAME      9
#define _MAX_EXT        5

#ifdef __cplusplus
inline int _Cdecl random(int __num)
                 { return(int)(((long)rand()*__num)/(RAND_MAX+1)); }
/* need prototype of time() for C++ randomize() */
extern "C" long _Cdecl _FARFUNC time(long _FAR *);
inline void _Cdecl randomize(void) { srand((unsigned) time(NULL)); }
inline int  _Cdecl atoi(const char _FAR *__s) { return (int) atol(__s); }
#else
#define random(num)(int)(((long)rand()*(num))/(RAND_MAX+1))
#define randomize()     srand((unsigned)time(NULL))
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#define atoi(s)     ((int) atol(s))
#endif

#ifdef __cplusplus
extern "C" {
#endif

long double _Cdecl _atold(const char _FAR *__s);
char   _FAR *_Cdecl ecvt(double __value, int __ndig, int _FAR *__dec,
             int _FAR *__sign);
void    _Cdecl _exit(int __status);
char   _FAR *_Cdecl fcvt(double __value, int __ndig, int _FAR *__dec,
            int _FAR *__sign);
char _FAR * _CType _FARFUNC _fullpath( char _FAR *__buf,
                  const char _FAR *__path,
                  size_t __maxlen );
char   _FAR *_Cdecl gcvt(double __value, int __ndec, char _FAR *__buf);
char   _FAR *_CType _FARFUNC itoa(int __value, char _FAR *__string, int __radix);
void   _FAR *_Cdecl _FARFUNC lfind(const void _FAR *__key, const void _FAR *__base,
         size_t _FAR *__num, size_t __width,
         int _Cdecl(*_FARFUNC __fcmp)(const void _FAR *, const void _FAR *));

unsigned long _Cdecl _lrotl(unsigned long __val, int __count);
unsigned long _Cdecl _lrotr(unsigned long __val, int __count);

void   _FAR *_Cdecl _FARFUNC lsearch(const void _FAR *__key, void _FAR *__base,
         size_t _FAR *__num, size_t __width,
         int _Cdecl(*_FARFUNC __fcmp)(const void _FAR *, const void _FAR *));
char _FAR * _CType _FARFUNC ltoa(long __value, char _FAR *__string, int __radix);
void _Cdecl _FARFUNC _makepath( char _FAR *__path,
                  const char _FAR *__drive,
                  const char _FAR *__dir,
                  const char _FAR *__name,
                  const char _FAR *__ext );
int     _Cdecl _FARFUNC putenv(const char _FAR *__name);

unsigned    _Cdecl _rotl(unsigned __value, int __count);
unsigned    _Cdecl _rotr(unsigned __value, int __count);

unsigned    _Cdecl __rotl__(unsigned __value, int __count);     /* intrinsic */
unsigned    _Cdecl __rotr__(unsigned __value, int __count);     /* intrinsic */

void        _Cdecl _searchenv(const char _FAR *__file,
                  const char _FAR *__varname,
                  char _FAR *__pathname);
void        _Cdecl _searchstr(const char _FAR *__file,
                  const char _FAR *__ipath,
                  char _FAR *__pathname);
void _Cdecl _FARFUNC _splitpath( const char _FAR *__path,
                   char _FAR *__drive,
                   char _FAR *__dir,
                   char _FAR *__name,
                   char _FAR *__ext );
void    _Cdecl _FARFUNC swab(char _FAR *__from, char _FAR *__to, int __nbytes);
char _FAR *_CType _FARFUNC ultoa(unsigned long __value, char _FAR *__string,
              int __radix);


#ifdef __cplusplus
}
#endif

#ifdef __BCOPT__
#define _rotl(__value, __count)  __rotl__(__value, __count)
#define _rotr(__value, __count)  __rotr__(__value, __count)
#endif

#endif  /* !__STDC__ */

#endif  /* __STDLIB_H */
/*****************************************************************************\
*                                                                             *
* cpl.h -       Control panel extension DLL definitions                       *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
******************************************************************************
*  General rules for being installed in the Control Panel:
*
*      1) The DLL must export a function named CPlApplet which will handle
*         the messages discussed below.
*      2) If the applet needs to save information in CONTROL.INI minimize
*         clutter by using the application name [MMCPL.appletname].
*      2) If the applet is refrenced in CONTROL.INI under [MMCPL] use
*         the following form:
*              ...
*              [MMCPL]
*              uniqueName=c:\mydir\myapplet.dll
*              ...
*
*
*  The order applet DLL's are loaded by CONTROL.EXE is:
*
*      1) MAIN.CPL is loaded from the windows system directory.
*
*      2) Installable drivers that are loaded and export the
*         CplApplet() routine.
*
*      3) DLL's specified in the [MMCPL] section of CONTROL.INI.
*
*      4) DLL's named *.CPL from windows system directory.
*
*/

#ifndef __CPL_H         /* prevent multiple includes */
#define __CPL_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#if !defined(WINVER) || (WINVER < 0x030a)
#error Control panel extensions require Windows 3.1
#endif

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*
 * CONTROL.EXE will answer this message and launch an applet
 *
 * WM_CPL_LAUNCH
 *
 *      wParam      - window handle of calling app
 *      lParam      - LPSTR of name of applet to launch
 *
 * WM_CPL_LAUNCHED
 *
 *      wParam      - TRUE/FALSE if applet was launched
 *      lParam      - NULL
 *
 * CONTROL.EXE will post this message to the caller when the applet returns
 * (ie., when wParam is a valid window handle)
 *
 */
#define WM_CPL_LAUNCH   (WM_USER+1000)
#define WM_CPL_LAUNCHED (WM_USER+1001)

/* A function prototype for CPlApplet() */

typedef LRESULT (CALLBACK *APPLET_PROC)(HWND hwndCpl, UINT msg, LPARAM lParam1, LPARAM lParam2);

/* The data structure CPlApplet() must fill in. */

typedef struct tagCPLINFO
{
    int     idIcon;     /* icon resource id, provided by CPlApplet() */
    int     idName;     /* name string res. id, provided by CPlApplet() */
    int     idInfo;     /* info string res. id, provided by CPlApplet() */
    LONG    lData;      /* user defined data */
} CPLINFO, *PCPLINFO, FAR *LPCPLINFO;

typedef struct tagNEWCPLINFO
{
    DWORD       dwSize;         /* similar to the commdlg */
    DWORD       dwFlags;
    DWORD       dwHelpContext;  /* help context to use */
    LONG        lData;          /* user defined data */
    HICON       hIcon;          /* icon to use, this is owned by CONTROL.EXE (may be deleted) */
    char        szName[32];     /* short name */
    char        szInfo[64];     /* long name (status line) */
    char        szHelpFile[128];/* path to help file to use */
} NEWCPLINFO, *PNEWCPLINFO, FAR *LPNEWCPLINFO;


/* The messages CPlApplet() must handle: */

#define CPL_INIT        1
/*  This message is sent to indicate CPlApplet() was found. */
/*  lParam1 and lParam2 are not defined. */
/*  Return TRUE or FALSE indicating whether the control panel should proceed. */


#define CPL_GETCOUNT    2
/*  This message is sent to determine the number of applets to be displayed. */
/*  lParam1 and lParam2 are not defined. */
/*  Return the number of applets you wish to display in the control */
/*  panel window. */


#define CPL_INQUIRE     3
/*  This message is sent for information about each applet. */
/*  lParam1 is the applet number to register, a value from 0 to */
/*  (CPL_GETCOUNT - 1).  lParam2 is a far ptr to a CPLINFO structure. */
/*  Fill in CPL_INFO's idIcon, idName, idInfo and lData fields with */
/*  the resource id for an icon to display, name and description string ids, */
/*  and a long data item associated with applet #lParam1. */


#define CPL_SELECT      4
/*  This message is sent when the applet's icon has been clicked upon. */
/*  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */


#define CPL_DBLCLK      5
/*  This message is sent when the applet's icon has been double-clicked */
/*  upon.  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */
/*  This message should initiate the applet's dialog box. */


#define CPL_STOP        6
/*  This message is sent for each applet when the control panel is exiting. */
/*  lParam1 is the applet number.  lParam2 is the applet's lData  value. */
/*  Do applet specific cleaning up here. */


#define CPL_EXIT        7
/*  This message is sent just before the control panel calls FreeLibrary. */
/*  lParam1 and lParam2 are not defined. */
/*  Do non-applet specific cleaning up here. */


#define CPL_NEWINQUIRE  8
/* this is the same as CPL_INQUIRE execpt lParam2 is a pointer to a */
/* NEWCPLINFO structure.  this will be sent before the CPL_INQUIRE */
/* and if it is responed to (return != 0) CPL_INQUIRE will not be sent */


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __CPL_H */
/*****************************************************************************\
*                                                                             *
* penwoem.h -   Pen Windows APIs into recognizer layer.                       *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef __PENWOEM_H     /* prevent multiple includes */
#define __PENWOEM_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef __PENWIN_H
#include <penwin.h>     /* <penwin.h> must be included */
#endif  /* __PENWIN_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

typedef int (CALLBACK *LPFUNCRESULTS) (LPRCRESULT, REC);

/* Initialization Functions */

#define WCR_RECOGNAME          0
#define WCR_QUERY              1
#define WCR_CONFIGDIALOG       2
#define WCR_DEFAULT            3
#define WCR_RCCHANGE           4
#define WCR_VERSION            5
#define WCR_TRAIN              6
#define WCR_TRAINSAVE          7
#define WCR_TRAINMAX           8
#define WCR_TRAINDIRTY         9
#define WCR_TRAINCUSTOM        10
#define WCR_QUERYLANGUAGE      11
#define WCR_USERCHANGE         12
#define WCR_PRIVATE            1024

/* sub-function of WCR_USERCHANGE */
#define CRUC_REMOVE            1

/* Return values for WCR_TRAIN Function */
#define TRAIN_NONE             0x0000
#define TRAIN_DEFAULT          0x0001
#define TRAIN_CUSTOM           0x0002
#define TRAIN_BOTH             (TRAIN_DEFAULT | TRAIN_CUSTOM)

/* Control values for TRAINSAVE */
#define TRAIN_SAVE             0  /* Save changes that have been made */
#define TRAIN_REVERT           1  /* Discard changes that have been made */

UINT WINAPI ConfigRecognizer(UINT, WPARAM, LPARAM);
BOOL WINAPI InitRecognizer(LPRC);
VOID WINAPI CloseRecognizer(VOID);

/* Recognition Functions */
REC  WINAPI RecognizeInternal(LPRC, LPFUNCRESULTS);
REC  WINAPI RecognizeDataInternal(LPRC, HPENDATA, LPFUNCRESULTS);

/* Training Functions */
BOOL WINAPI TrainInkInternal(LPRC, HPENDATA, LPSYV);
BOOL WINAPI TrainContextInternal(LPRCRESULT, LPSYE, int, LPSYC, int);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __PENWOEM_H */
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef __OLE_H         /* prevent multiple includes */
#define __OLE_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* WIN3.0 */

#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY         /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none,
    olerender_draw,
    olerender_format
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifndef OLE_INTERNAL
    oleupdate_oncall
#else
    oleupdate_oncall,
    oleupdate_onclose
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifndef OLE_INTERNAL
/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);

    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);

/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif  /* !OLE_NTERNAL */

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* !RC_INVOKED */

#endif  /* __OLE_H */
MZ@O  @   	       >    Pjr                                     t  i  V  K  6  !                    z  e  T  I  4  #                    p  #                    z      
  s
  S
  	  	  	  r	  K	  <	  	  	            ^  ;              v  e  Z  :  '              z  a  L  <               `  M  B  2                    y  n  ^  G  )    
  HVv			Au:FkB{3R	Gr48qj-xCG                                                                                                                                                                                                                                      .0!. , ڣ   .  3؋aC&8ùى   +> s >Ǹr(>r"G;r> t> u ;w
ډ   +؎JW!_ҋ3.+>\vG> r@w> r7X !r*g\!r H !r@ HI!r
X  !s   
t@ p &3. 6 6 6 gP.VW _^VW.3/ & F-\t	 / 
_^ËLF! H  5!t v 5!x z 5!| ~ 5!   %ʎں! %t !%x !%| !% !ø ׋;t&?t&O2;sӃ;t&? &t&_&Wô ׋;t&?t&8gr&gӃ;t&? &t&_&Wô@ !ù V . P   U VWF   PFPFP	FF  F  F F F F F F	 F 6 P P3PFP2
FPFPFPFPFPFPFPz7YYPt7YYPn7YYPh7YYPb7YYP\7YYvY PY P3P P P Pd P{vޚY P3P P P P P{vY P P P{ PP P{ PTP P{F:	~HuFHF~PuF@F~ uF ~uF ~t vޚY P3P P P Pd P{vޚY P3P P P P P{vY P P P{PP P{PTP P{~t vޚY P3P PP Pd P{vY P3P P.P P P{vޚY4P P P{vY;PP P{KPTP P{~t vޚY P3P PRP Pd P{vY P3P PcP P P{iP P P{vޚYpPP P{vYPTP P{~t vޚY P3P PP Pd P{vY P3P PP P P{P P P{PP P{vޚYPTP P{F~t~tvY P3P PF  IFڻd 
 PYPvڸ P{vYF PYF
 Fځ~,| P3P3PvޚYP>PYYxPP1YYF    .	 BV!	 BVvޚYF  'F PXPF P P F Fځ~|F  'PF P PF P F F؁~X|Ҹ P3P3PP P P{ P P3P"P P P{ P3P PWPP P{
 PǺ  Pƺ  PAv PKYY
 P
 PF  PF  PjFH v暭Y
 PǺ  Pƺ  PA~HuH~Pu@~KuH~Mu@Ǻ  Pƺ  Pv YYFF;Fu,~Hu@~PuH~Ku@~MuH} ~ } ~ vޚY
 PǺ  Pƺ  PA@;FtH;Fu;~t@;FtH;Ft ;vt v PKYY
 P
 PF  PF  Pk BV^ BVv PKYY
 P
 PF  PF  PF@FF~t>~t ~t  P3P PvYP P P{ P3P3PvޚYP P P{P P P{P P P{P,P P{7P^P P{~t ~t  P3P PvYEP P P{WP>P#YYc-PF{ PlPxP]P>P YYP YYP YYP	YYPYY4~t ~t  P3P PF  IFڻd 
 PYuPvڸ P{vY2 P^YF
 Fځ~,|vޚY P3P3PP P< P{F  ~ tmn PFP)YY3 _^]UVv3PvVF7 ^]UVvFRPVV3 ^]UVvVVY ^]U>
 u 
F
3]UvY]UVvu

>
 u1:~ uuvJY^] U3PPv]U P3Pv]3P P3Pø PP3PyVt^UVWv~
_^] YQ3YQ YQ YQ UVWF
V^Nutite uy
؃ y
ۃ   W33;rw;r+@[ tƋ t؃ _^]  t3[Ssـˀ3[Ssـˀ3UVv|X~W 6ރ06 ^] UVvV^] U D^!% ]U"VW~
^$wXrSFN}~ t-G؃ v+F	+FuNN,
s:F F
_^] U3Pvv
 P PaPj] U^で^BF
^NV!rP]UFFF]UVvt VYFu> uF^]Vt^UF  ]ËZ5N  %U^^ t P?^NV!rP]ú ;\s+Ǉ^  ڱƇ ㉇*B;\rՠ P$Yu& P t 3P3PPD0PYu&. P. t 3P3P,PÊ  '@'U VWF  FP F  FW2I_6GNu/SQRj+jPWvV
uF FP ~jZY[j~~v
t<%t6GNv<%t~3ɉNNNFF2Ћ؀ `sv. wNЀ wNŀ w~+tV뵃fN 맀 wMF u)N8~6Fsy؃NFou׉FbsʵFU,0wF|F3uFtFNeN fY


F V3҈V~6
FV~6GGvF t6GG~~uu~ u6 NRPWǘPFPSV}  Vv~^67CC^F  t6CC^:Z6 F fN+ϋV; vV~6F~26  vV~F  u6=F6=FuP;NvN vV~N} WQ^SR #FPF t	 F
F P ~F tV~&=-uI+~V&=-tF
tO&~ ~
N}N~^ #F= ufou~ F xtXuN@KKn}F  NF u yK;F@ t0hFbV~'++&<-t< t<+u&CIK08+&6GN+~	˰ Uv~F  u6=F6=FP *FF&F tGG&  v~%
u~P}~ tF_^] :$o/X|)kJPU` VJPcZVJe] UVWb FNZ~
v;s
H~ u;;trsrsrsë_^]
 UFԁ ;s 3	  ]UFV  u r
;s 	  ]UvY]UFRPYY]ðPXPYPZP[P P
X6Y UVWv~F  F} F FF - ؃w..c6vX ;F}lNgX F]FXa u.>g t'&\FFF@PF@P7RPFP PNVv  \F	   FZ ;F}X FVF[ ;F}PXPYPZP[PP	NOtVv i F _^] U>P3PvFP]UVv^F&F:t3< u ^]   UQ@ Y t	tYq<t<uP <t& X<@u׳tA2   <t*  <t<uPx
Xt	> t@]ôpP Y d&]&\UF^J&`:^t^ 83^&`>^v>^@s>^t 3a>^@t@ & _>^t PRiPuu 3b>^u  ec   YX`Z_[]úpu @ !' z@!bÜ C@@ӝV3 u  Fd|^UV3ҋ^3PR[Yډ^N;s~wr#~ rn ^y3;Vru;Fr^]À> t
  ! V> t
P>Y^U> tF ]UvY]UvY]UvRY]UVW~vWVvv
[u3-F+@FvWVtRPvFFF;v
~ _^]UVW~vWVvv
u3-F+@FWV$RPvvFFF;v
~ _^]UVDF^N
!r~ uP]À> t !UVWv~
vVvWzt#vvF+FVR+ƋVRWu3S։~F ;v}
׉vF)v+ƋVRWRPvWNRPF+F@P~FF;u͸ _^]VW\r;tB  _^9t#wt6 ;6tT G3Su[;twu?u2 ?t\ߋ;t>wu|  Ë6t|\]wÉ__VWDtR r6%= s > tt9s_;uf !  397sk _^P3PP[[% t	3RP[[XP3SP[[=t؉X@[3P3SPu[[=tءGX@X3)7@\uËSPQP[tvVF$[^Ë;w5;uSP[[]+)|Bˋ7كVWU^F
t7t-IЃs ;rwOPeS3[]_^UFP P3P]&UFȠ` P3[ش ` *ЈVF] UVWv~;t	 :`rƲ _^] UVW~FFF;eu 3Ftvv
fFF;eu 3Ft_vvCFQ~ tFPFPe {
^&7F~ tFPFP?Ɗܹ  	N
^
&7F
OuV 1_^]
 UVa u>g tvv
vvRpvv
vvR]
 UVW^
v~` Ƞ_ ;w-;w);%;w!9Vw;v~~~~ ~ 3_^] UVvV.\ B;V~^] U a t*>g u ~tFF
FF~t F
 PF PF PF PF
 @PF P`PF PF PF PF P
`PF PF PA`PF PF PF PF P
 F
 @PF PF HPF PF
 PF P
`PF
 PF PF
 PF P
`PF PF P`PF
 PF PF
t>\fFn
NvV ] U^4 ;sauaCBB]a$aô  X +@ Y +@UNCFV!rP]UV;\r	 PǇ^  R Y]U>^!rǇ^  3PS]UVW~un f9}t^= |)E u
 9E
uF   9E
u8EE
0.E@)5PEE
PEPh;tE uM3_^]UVWF  >\D tVbYFOuF_^]UVWv< }
TB3+ЋD@ u,L
< }	Iـ?
uGJuA?
uGJu_^] UVWv~
VYtGu< ~V|)FVd_  DD
WvvDPu
=u3_^]UVv P33PRDPVFu=u < }tD^ tW P33PRDPxVFu=tP3PvvDPTu=u*FVFVVFVV)FVVF^]UVW~vNsF_^]UN<V!rP] U^++Ҵ@!] UVWv~ u% 3PvYYF tx#>ǩu P~u#>t
6z ǀ t3 F t7P P tv3PO} WYvv6}l Vv YY|Z3PWdYYF t   t%   P PWA
 tWF t t t PPv|/ t 3ցRF t3 ZЋ㉗^_^]UN u
 u V"N
=!rFF% ^㉇^FP;]UVWF;\r
 P F@= r^^ t3 vvvF@= r^^ @uFbNv<t-<tS PFPvh[F;u S PPQv}^く^ [+_^]5UVWv~
9tu~v > u,u > uu < t P33PRVD tt'YdD   DD
~t>v:q+~ uWYFuuLlFD
D|~uL3_^]UW؎~3H_]U VW~v;>\r
 Pj F@= s3 ^ t P33PRW5^ @uvVW  で^vFFMN^FF<
uFFFx+Ё |'+VPW[ ;tu=F+F1x~ ux+v!VxPW  ;ttŋF+F_^]U^^ t P@^NV!rP^く^ XPH]VW D tVYOu_^U3PPYY P3PYY P3PYYFt3Pv+YY >Ft3PvQYY dFt3Pv:YY Ft3Pv#YY 6PoYY6>PYY6PYY6dPYY>P6YY>P6YY>P6dYY3  PR6d PnYt3  PR6>]Ã> t P6YY > t P6YY > t P6YY 3PP
YY3P>P*YY3PdPYY3PPYYø PPYY PdPYY P>PYY PPYYUVv
PVYYVY^]UVWv|uD  | u3Q3| tD+D
3tPVWYY=u 3tLYFDD  Ft3_^]UVWvu$ PYtiVYDD  D  D  D  PYt9 PPWV P PVD P PWV_^]UVWvu$ P\YtjVYFDD D  D  D  P+Yt9 PPWV, P PV P PWVj_^]UVWv~t1| tVYYPVWYY3PVdYY tVY_^]UVW~} tE% = u } u} u*~u FF PFPu= u WWYuE+E= ~  FuE+ERFPWFPFPVWx~t)VE;Er´ PWWYY]E E _^]UVWv~| uu3  t+ t    u @ t  t  tĸ ǀ t  @ t v
Pv=ȃtLD | t 3P33PRQ߃TD|u	|uW|tD+D= ~  3FFPFPVFPFPWV7_^]UVWv~V| t
| t3\t~~  F	3F33PPWVvFPFPVFPFPWV_^]UVWvFVFV| tD+D
3tPt
tx;tL ~
u=D;Dv+D3t()FVD uTB?
un^ 9Tu~
 u3~
u  FPvvt9ރTD| uF| t@D+D= ~  F|FPFPVFPFPWV|u|uTD_^]UVWv| u | tD+D
3tXPt
tQ;uӋD+D= ~  F|D+DRFPVRFPFPWVfD;Dv+D3tS PD;Dv+D3ؙRPt݃TDtttVttV|u	|u&3_^]UVWv| tD% = uD;Dv+D3t
\  | t | u VWYuD+D= ~  FDFD+D+FPFFPttFFPFFPvVFFPFFPVtR\ FF P" PtuF3PPD" F# P" P" PVtuFF_^]UVWv~uJ PYtGu( ( PYD PY P4YYvv
vVi _^]Ë6G  UVWv~t9D P PcYY t3P( PAYY tV8Y_^]Ë6GUVvV t% = u| t v
Rv Pt3 P4zYY^]UVWv~uP PYtTu. . D(. PpYvF
 Pv PV
 P( P&YYDD* _^]UVWv~uP P6YtTu. . D(. PYvF
 Pv PV
 P( P YYDD* _^]Ë6G
 6G  UVWv~tFDD*3P( P|YY3PVYY t3P. PYY tV}Y_^]Ë6G6GUVvv4YY^]UVWv~u( P(Yt%u  PYD
D  _^]Ë6G UVWv~u( PYt*u  PY PVtYYD_^]Ë6G UVWv~D   t3[ t2t%_G_;Gv__+G3;}	wYuG tV Y u 3_^]UVWv~t*D t3P PYY tVY_^]Ë6GUVWv~t3D3PVYY t3P PYY tVY_^]Ë6GUVWv-_G_;Grw_WY_GD_G_;Grw_WY__ 
% uu P4)YY_^]UVWv~3PVRYYu ~F  GFG  F0FG_G_;Grw_WY_GNtK_G_;Grw_WY__ F^
% @t~u~u;~u  P4RYY _^]UVWv~FPVGYYG uF_^]UVWv~F  F  
 u!uG P4mYYoG N^3Ҹ
 PR[Yڃ0 ^N_ t_GG_;GrwY__ 
uVF_^]UVWv~F  F  0|7~!uG P4YYoG VFtPR[Yڃ0 ^N_ t_GG_;Grw;Y__ 0|7~VF_^]UVWv~F  F  
 u"uG P4YY G 
t7
tW0VFPR[Yډ^N_ t_GG_;Grwq
Y__ 
uVF_^]UVWv3PVYYuF  F  _G_;Grw_WY__ Ѓ-u 3+tt9_ t_GG_;Grw	Y__ ЋG%@   tRVYYVF G%    t G%   u0tRV̋_ t_GG_;Grw:	Y__ ЃxtXu<_ t_GG_;GrwY__ H0|7RV;F  F  tVF؃ VF^W_^]UVvv4?YY^]UVWv~u& PYt u  PYD_^]Ë6GW UVWv~u& PYt*u  PdY PVyYYD _^]Ë6GL UVWv~t/D"$V~ Y t3P P4YY tV+Y_^]Ë6GUVWv~t3D&(3PVYY t3P P
YY tVY_^]Ë6GUVvw_WY=u P4YY^]UVv N3
 PRvvf03
 PRvvBΉVFFuЋ^]UVv NF$0 VFΉVFFuߋ^]UVv~
 t:*F NF% ^؊ VFΉVFFuً^]UVWv3G%@   t G%    t 
 ؃
u~ |~ s 3F~ tVF؃ VFVF
u7RPFPЋFFu ~ tJ G%   tuLpuIG%   t 3FPvvFPЋG%   t4~ tNQ"vvFPyЋG%   tTWRV_^]UVWv3G%@   tGG%   t 3FPvvFPFЋG%   tm~ tVY[G%    t$vvFPЋG%   t/\*vvFPuЋFFtG%   t^WRV_^]UVW~
 tWYY u0GFG  HFG%
   uUNW_G_;Gr´ Pw_WYY_wG =u P5tYYN}G uMFЋ_G_;Gr´ Pw_WYY_wG =u P5YYG u`G%   tUNW_G_;Gr´ Pw_WYY_wG =u P5YYN}G% `  tW2 Y _^]UVvG u twY 3^]UVvG uG%    tVgYG% @  t>PRYPJY^]UVW~
 tWY u~ t	vY3F~ t	vY3FGFG  +F+FFG%
   uUNW_G_;Gr´ Pw_WYY_wG =u P5pYYN}G u%~ tvvw7;Ft P5;YYG u`G%   tUNW_G_;Gr´ Pw_WYY_wG =u P5YYN}G u%~ tvvw;Ft P5YYG u`G%   tUNW_G_;Gr´ Pw_WYY_wG =u P5BYYN}G% `  tWY _^]UVv PYuT DD  ^]UVvu PYt6`D  D  D  D
  D  D  D  D  D  D  ^]UVvVWY=u\ ^]UVW~E;Ev+E3F~ ~)PuvރFFFE^FFFF;F}+E;ErWWY=u
]E F=uF_^]UVW~E+EF~ ~PvuTރFFFEFF;F}3^FЋE;Er´ PWWYY]E =uF_^]UVWv~tv| tt?Y tV4Y_^]UF]UF]UVvV3PFPRV ^]UVWv~| t| t9|ttY|t~ t
9~rFǉDu 3D~
 t	t 3D_^]UVv^VN
ttDTtt;rD^]UVvVNDD
tt;rD^]UF]UVvv
3PvvVW
^]UVWvV~D+D;|WRty܃~FDWRVW
_^]UVvD;Dv+D3u| tD+D
3u3^]UVvD;Dv	\ 	DD^]UVvF% T DD% DDD
% DD
^]UVvu" PYt	D  ^]UVWv~t| ttY tVY_^]UVvD   3D
DD D  D 3DDD  D  FD^]UVvDTFVFV##t!T!DFV##t!T!DFV##t!T!DFV	T	DD%   tL dVF^]UVvV% 	D%	D%	D
^]UVWv|tWYFD~ tL L
 
dd
_^]            UVW~ Nǻ
 303u_^] UVWv~"uV
F_^] UVWv
~ND&*E_^]
 UVv&
t<ar	<z$_&F^] UW~2Oǌ_] UVW~vt"uOv"uOǌ_^] UV	!] U>!]UWV
 =!s+33ҸB!r#t	#u=vF~3_]
 U3ɋV
 B!rNV?!r3 ] UVWVWv~N_^_^]UV؋vF  F  ރv .^F ^F ^F ^F^F ^F^F ^F2 ^FS ^Fn~^F0^Fj^F`^FV^FL^F	^F:^F	0^F3	&^FN	^Fh	^F	V`^FFFt%PvvvvRP	PgڸPvvR^]ˊvlZPF<2(ULLءF  ]U> t		PP8  Y]UvP  Ytu
;u33^&&W H]UVv^&&GttV&w&7D  ^&G  &  ^]UVWv
^&7% &)VƱЃtNڎ33_^]
 UV؋FV FV>u ^&?pktz^&r&vd3WF vPƺ P Pu5vvvv^&w=Pƻ RX(X&  F;6|^]U
VW^&?PKt	 ~~F^&r&
v^&G&WFVF  DT
;Fu;VtF~r~u-F= r뉡 FVDT
tVD    vvvv^&w2TDD  F@_^]ULLV؋vF> u s6F^]U^&  ^CwZ.Y^& Y^& O^& E^& ^& 1^&  '^& ^&^&^&]9F/%%Uvv
vv^&? }	&]UGE)CA)\                G  G  G  G(  G&  G*  G      ]UdVv^&  FPvvvv
\FPvvV> u32FP33PRvv
+FPvvVg> u͸ ^] UVvPƺ P	Pƺ ؋(&GEt       vvPPPt3 6P't3P666t66YY;t6P뙋ƺ ؋(&GEV ^] UVW؃> uq Pww3PPe
.VFVWv _^P1YY= t3P
Y PYPPr	P P	YY P3PPI P3PPI P3PYY3PY3PPYY_^]UVWF  && £CA  ^&? u_KF ؋"$t4F "F~ |FF ^&^
F&FF;}	^&? tvv
vvP^&? }&N^
&FFu BPvv> t-P	VF^&:t&\t&\F^& ^&? ~	&% 6Pu^&qVW\E 2_^6hPGt ^&6PX%] r jhjhlxv> t\P
\PYY PPRIP
\P YY>I tI \IsW'   _^]UVWvvHVF
^& N^&? uF;Fsvv63<vvƺ P Puƺ V^
$"
 dF;6|>
|N Pvv Pvvu V^
$"	 _^]UVvvHVF
^& N^&? uF;FsvvI3#vvƺ P Pu@;F;6|׃>|%^GP RXZ!^]UV؋v>tp;6~btCA    6VY PPRIP
I\W'^]Uؠ u]UؐfuCACA)]UVWؠ u	  6Pt%6P Ǉ(  Ǉ&  33|
 t)| t#tVD    D  D  D  Gr_^]Uؐ3PPYY]UVW؋v~|"|G;F
rG;Fr
9v
|9~}86>F
FFFPvv
WV	
3PP YY_^]UvvP
   ]UءFV3PP\YY+P+P3PPy~uvPvvYY3PP YY]UVW؋v~WVYY6>_^]UءFPFPYY]Uء]Uء]U؋G]U؋G]U؃>t33 ]UPvYRP'ڸ]UVW؋v~WV
YYWVYY_^]UVW؋v~PP
YYPPYY_^]UvvP   ]UVW؋v~
wv6F>WvV_^]UVW؋v~Wv
WV,
vv
Wv

vVvv

WVvV	_^]U^&G&]UVW؋v~v6>WVYY_^]UVWVW~ _^_^]UVWؐ;F
s3 F
VW؎v _^v
vvo_^]U졺RP^3ɡ  RP  ] UV؋vVPVvv
vv	^]UV؋v
VPVhP3Pvv	^]U^&^
&]U؋FF]UV؋vV@PVvv
vv	^]U؃~w(F~ u 
^PZ
Y]Uؠ ]Uؠ ]UVW؋FVFV> u|^&?v ^& FF  !^^&~^^&G^FF;Fr^&t VW~ _^FFP	YY_^]UV؋v> t+ H;r!~ |Fu vV	YY^]UvvP   ]UVvv
vv^u^]UVW؋~^
&F&wvGV+;vvvF;Gw;|3r/F|&^
&wvvv
vW
^
F&G_^]UvvP
   ]Uvv66J	>
 u%> u6vv	YYRYY]UVW؋v~|	|~6
>WVYY_^]UVW؋vuu|;6~	j;6uhƺ ;6u7H ؃ t:H F^wvW^G    G  G  G  EEt P
 P 
PJPPFPPt>t  F PFPtB FVFF  3PvvvetF PFPTvvYY;tF PFPk'FVEF E6EU3F
 6FF
v
vVH_^]Uvv
vvu  ]Uؐ]ːSˀ>
u7>u
 ô
@  &
>
t>
t$ &U.VW A_^]
U.VW3.	
>
u
^& u2E  A_^]U.VWF^N
V~ u̀8 A_^]U.VW'F<
s
6
6
lXX
 A_^]U.VW>
t# A>t@  
&2

_^]U.VWF2P2 A&_!_^]U.VWF2P2 A&_
Xy_^]U.VWF2P2 A&__^]U.VWf
& A^  A_^]U.VWfF* A_^]U.VWF
+Fy@ P2 A&_[N+NyA r#t3_^]U.VW

 	

~
&
"u_ 
/~&
~
&"x$
*s2.3!	
.!
~2&_^]U.VW6
	 
_^]U]~
2<u&2
~
&U.VW^

 A_^]U.VW A_^]U.VWF^ A_^]U.VWF^
 A_^]U.VWF^N
V A_^]U.VWN^  A_^]U.VWN^  A_^]U.VWF^N
V A_^]U.VWF^N
V;r;sQR A[XNV2 A_^]U.VWF^ AF
^NV A_^]U.VWF^ AF
^ A  hN
V A_^]U.VWF^ AF
^NV A_^]U.VW A~ _^]U.VWF& A_^]U.VW2: A_^]U.VW2: A_^]U.VW: A_^]U.VWN  A@_^]U.VW  AH_^]U.VW^2 A_^]U.VWF̀^N
V A_^]U.VWF2^ A_^]U.VW^C A_^]U.VWF^N


2" A_^]U.VWF^N
6
&|&T&|ՎWU, A[XӋ_^]U.VWf& AF  A_^]U.VWF^ A^
2+I& A_^]U.VW&_V
Ȋ؊Ff"t>&}t
2ً$ A_^]U.VWF^N
V̀$ A_^]U.VW^2+I( A_^]M U.VW S ( A_^]U.VWF^. A2_^]U.VWF^V
0 A_^]U.VW^NVv
~;r;r+&7+&4 A_^]U.VW^
NVF6 A_^]                  


 $ 
t2.!
.%!
.3!	
ô<t1 s
Q sj #t


 s
+ r "t
þ 3&&&;u
ø }
t03 r*"t&
4 r û9 &?Z4u&49u
	
Àr	sø <utt
rw2ú2$ $:tÀ
s2ù $0<uðð33Ҵ0tًڊG
t<ut 3                 z                            V ^..p    _  [ Rqz    *RI gg                                    '               d d         ^^P      ;r;r#x#x   X"y X3؋}      L  Ë PS7[X p y% @s, p <u	x &Z !s   ?s=t6 6 p  
	>  t>o  t&؋È&"t  |  p r o 3p t v S>p Hȫ.6t &} .6t & } .6t 
&4@  .6t &4@ [DPSQR&G@@&G&G3ҹ &_x z ZY[Xp     p ã ã   p <u ã 2  2    " p â                                               & d$ (  "     P#t;ǭuXXˡ 
. .r  p    PS
 [X ^rQRȋӇ  ZY9s p ã                                                 CAGWOW
OG GG   p r> ss p 4 +yߋ+y;> s++ ++ PSQRW_ZY[X               <r2AFk    2CPSQ3Y_ C #uX" t&&_  F >  tH}- X( ;s= r  p  ø  Á>  r> t  >;r r6 6+ 5 u"t #uWQY_#uޏ 
 WQY_û &GG&GGI À> tn>t> u6 6s0 p ;u;u>t2    >;>s6&Sx &[QR   r	 p S[PXS[PXZYt?Rы>  t_#uO W+PX+S[_#t   p áiS^[PS[X+LSPX[+S6[-;|;}@IKB4      D> s > u>  r/PS2 " p 3[Xv   " p \ 6 6PS6 3W> 6WVWVO>  t > u>  r3҈PS3ҹZ 3= r [X;tSPZ GXS3;Ük tX[3;ÜY t  > tPSv[XegÉP XË>  tZ Z+> #u 6 6QR6 WVSSPP X X X ^^666PM;u;u> ^s!
> s À> u +&&_   - r> u_ _ ЋË ËȋQRh3R;t3ҋX;rZY+ ح+ Ⱦëë;rh;r>  tZ ZSPPPNXTء XX[@;~PS3[X&&_            >  r= r&N^F؉^6 s *s XX FFF  .  F~rF^;^uF  FF;F|F  ^CCFʀt;|;|;}SQ ; Y[Հu
uËwO;|·׋+tF++ËЋvF;Fs"F#tH@;|	HuFF ^CCCCu<t;F}F;F|Fދv3N&PVU  ^u ! ]^X@;Fr    >c t Ã>c t ȋӇ;r> u p      Z  

Z
    
        c   xO> u22F2F. F2>  t> t   p   2        U*FrF F
^FڋF^	F ;FFFFuFFuFF^;wd 
s F܉Vދ^FV3FFFF܋Vދ^^FVs s +FVމFV։~v r F^F^F^;^|
u;Fr o F;F|uF;Fr 2 F^F^;^
u;Fw8 W F tы]X FFFFFFF+FFFFFFFFFFFFFFFFNF)FFFF+FFFFFËVv~F u7VWƋߋȋ _^VWߋƋߋȋ _^F^NVUq] 	  ދƋ* ~ u;F|;F~;F};F~WVv~J ^_
x
x+؋p
x++t3ɇʑËȋrËƋ>o  u$P2 p &X>o  u2 p &_ S      ;w'a:l !H#l%')+-/2468:<> @ACEGjI<KMNPFRSUKWXZ\]_`bycd9fghjYklmnoqrsttuvwGxyyhz
{{2||3}}~l~~L U FZU   F} 3ҹh= ~-  =Z ~ !3Ѐ>  t
Ѓ   ]                           ssãTVXZ( >  tTVXZø؋ȋ  ûT X 
uáX+TpԣPZ+VpȣRT X 
u"t  "u  >P uV; } V ;V}Vv>R uT; } T ;T}TQT; } P T: ;T}
P T'V; } Pb V ;V}PO V"u/ 12ҋ; }; ~G; }; ~áTXTVZV+V.P>RT+T.R>PV > ;};|H> ;~;<> ;};|0> ;~;$> 6   > 6 
  ;};~; w; w; |; |;|;|                    2S[;À>o  u $ p "y(>o  uPSQR$ p 
 ZY[Xã       >| t"tJ> t >  tT >  tFu 3Ҁ>o  u$ p    
r
 ㋟22á S؀> uO XS؀> uh X  p À> u #yÊ2>|  u
>  tA& p á>t> t2&>uH+á>u	2&>t>u+                 +                               >| t&:t'SQ Y[rã3ۉ#u$#u@#u@1> u ';s#uCF á#u  6 >+tÎ3&<+uà*2P&6X&6	 SQ >3&C.*.:s2s&6Y[    *:r2>߃&?>> tw_Y W2IQv .:u"t_  ȋӇ&GG2ŀttW3_W2_ Xq 3 ۀ>  tؓ l " P 0 X3$2$@tJˀËttËttÀ>tTR6 SG Q2 H> t Y[&"tSQ`Y[CXP> t  Q 5 Yá> t > t>uH>  t) á> u> t>u>  t  P $&:u"XtX  s p           Borland C++ - Copyright 1991 Borland Intl. Null pointer assignment
Divide error
Abnormal program termination
                                                   OUT.TXT   CIRCLE TOUCH   START  ABOUT   HIGH SCORES    EXIT    CIRCLE TOUCH   START  ABOUT   HIGH SCORES    EXIT    CIRCLE TOUCH   START  ABOUT   HIGH SCORES    EXIT    CIRCLE TOUCH   START  ABOUT   HIGH SCORES    EXIT    CIRCLE TOUCH   START  ABOUT   HIGH SCORES    EXIT  START!!! Enter your name:     1   2   3  4   5   6   7  8   9   10  11 12  13  14 15  16  17 18  19   14  13  12  11 10   9   8  7  6   5   4   3   2   1  When you are blocked inside of circles, press the "ESC" key.                 ABOUT...  Game writen by Ionica Bizau.      The goal is to touch the circles.  Move the circle using the arrows...    Try to get good scores.      Have fun! :)  HIGH SCORES...... 




                :           Bye!      Press any key to exit. Thanks!    "                                                                                                         
           TRIP           LITT           SANS           GOTH           SCRI           SIMP           TSCR           LCOM           EURO           BOLD                                                                                                                                                       ))                                                                                         I\                                                                                                       CGA      CGA              EGAVGA   EGAVGA           IBM8514  IBM8514          HERC     HERC             ATT      ATT              PC3270   PC3270                                                                                                                   xxxx     No Error                                                                                            Bad Mode                                No error (BGI) graphics not installed Graphics hardware not detected Device driver file not found ( Invalid device driver file ( Not enough memory to load driver Out of memory in scan fill Out of memory in flood fill Font file not found ( Not enough memory to load font Invalid graphics mode for selected driver Graphics error Graphics I/O error Invalid font file ( Invalid font number Invalid Printer Initialize Printer Module Not Linked Invalid File Version Number Graphics error ( ) 
BGI Error: Not in graphics mode

$ 
BGI Error: Graphics not initialized (use 'initgraph')

$ .BGI .CHR                        !!!!!                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                                                                                                    	            
         ,           <  C         L  B         \                                                                                                                                                                                                                                                 ```                               @     ),(((((),(((),#,*((((**#(#%(     (null)   	

                  COMPAQ print scanf : floating point formats not linked
 R	              /<1G3H"HK/1I2F/<1G3H"HK/1I2F/<1G3H"HK/1I2F}5s5}55+7!77+777879M8899_9?3??????&@0123456789abcdef0123456789ABCDEF- + 0X 0x 0 0X 0x 0 + HHGzJH"HHIIBJFHHGzJH"HHIIBJFJp              J(---    J   b   +    ,   ,    .-                                                                                                                                                                                                                                                                                                                                                                              R+  /8k        @                      ` y,                                       _      r                     	      
                                 V      e      w                                                                                  !      "      #      $      %   r   &   u   '   u   (      )      *      +      ,      -      .      /      0      1      2      3      4   $   5   ;   6 L   7   r   8      9   T   :      ;   ,   <      =      >      ?      @    A   >   B   q   C      D   J   E   g   F    G    H      I      J      K      L   8   M   D   N   P   O   ^   P      Q      R   -   S   ?   T      U      V       W   S    X   f    Y   !   Z   !   [   I"   \ #   ]   #   ^   #   _   #   `   #   a   $   b   $   c   E$   d   c$   e   $   f   u%   g   %   h   &   i   &   j   0(   k   }(   l   E)   m   H)   n   *   o   .*   p   4+   q   n+   r   q+   s   ,   t c-   u   }-   v   -   w   }.   x   /   y   K/   z   +0   {   <1   |   1   }   2   ~   3      	5      }5      5    t)6      6    ~+7      7      7       8      W8      8      9      i9    O9    Y:      +=      >      >      =?      ?      ?      0@    A      FB      C      D      D    D      F      $G      xG      G      "H      H      H      H      H      I      hI      I      I      I      I      BJ      zJ      J      J      J      (K      fK      L      8L      x          )                    q      	                    <  n      3            ?    f                                ;    v            .  K              A    m                      *            2    g            c      s                    
    N    z                8    [                m                       C   c             T     	   
        !   B   ^   }               K {          (    U  v                "         t  !  x  "  |  #    $    %    &    '    (    )    *    +    ,    -    .    /    0    1    2    3    4    5    6   7   8  A 9  E :   ;   <   =   >   ?   @   A   B   C   D  
 E  
 F   G   H   I   J  \ K  ^ L   M   N   O   P   Q   R  V S  X T  g U   V   W   X   Y   Z  [   \   ]   ^   _   `   a   b   c   d e> f  d g   h   i   j   k   n   o   o   p x  q   r   s   t   u   v   w   x   y   z   {   |   }   ~                              
            
    
            
    
            
        q                  !                                  &        X     (                              
                                                            Y     !     m	&     l]m?@           5 t }    ! " # $ % & ( (+ 1, 7- >. D/ K0 Q1 V2 \3 a5 j6 s7 8 9 : ; < = > @ B C &D 9E NF WG jH I J K L N P Q R S 
T U &V ;W PX YY nZ w\ ^ _ ` a b c d e f !g *i ?o Er Ws \t _u hv {x y z { | ~           ( 5 > E s z      
	 	 A	 O	 w	 z	 	 	 	 	 	 	 	 	 	 	 	 	 
 
 
 
 
 
 "
 (
 -
 2
 5
 :
 =
 B
 E
 J
 M
 V
 x
 
 
 
 
 
  . 5 ; D I [ ` s |            / 4 G P e r  	
6?Qf) ktw[\]^ghop        
p    
o    E&l    {n                               
   
                                                                    	    
       
                       
          (                              +  
         .P       .&           #      4    .J   ."   "     ? "     D "     L    ! -     ( !      -      !     -      !      -      !      -      !      -      !     -      !      -      !      -      !      -      !      -      !      -      !      -      !      -      !     -      !      -      !      -      !      -      !      -      !      -      !      -      !         -     S !      -      !         Y .   -     X Y     -     X Y      -      Y     -     X Y    -     X Y      -     X Y      -      Y      -      Y      -      Y      -      Y      -      Y      -      Y    -      Y    -      Y      -      Y    -      Y      -      Y      -      Y     -      Y 
   -      Y    -      Y      -      Y    -      Y    -      Y    -      Y          -      Y      -      Y      -      Y      -      Y      -      Y      -      Y      -      Y      -      Y      -      Y      -      Y     -      Y     -      Y      -      Y      -      Y     -      Y      -      Y      -      Y      -      Y    -      Y     -     X Y      -      Y      P-     X !      -      !      -      !      4    -      !      4   S -      !      -      !      -      !      -     ( !     -      !     -      !         #          -      !      -     ( !      -      !      P     -             -            -             -             -            -            -             -             -                 .$   -         v  -         w  -            -            -         x  -            -            -         z  -            -         u  -            -        y  -        ~  -        }  -        |  -     X   {  -                 -             -             .(      -          -          -          -          -          -          -           -           -           4   -     &     -     &     -           -           -     &     -     &     -     &     -     &     -     &     -     &     -     &     -     &     -     &     -           -           -           -     &     -     &     -     &     -     &     P-     &    P-     &     -     &     P-     &     P-     &     P-     &    P-     &    P-     &     P-     &     P-     &     P-     &     P-     &     P-     &     P-     &     P-         -          -               -     q      -     q     -     q     -     q      -     q      -     q      -           -            -            -            #      .&   -            -           -            -            -            -            -           -            -            -            -            -            -            -           P-            -            -            -           p-            -           P-           P-            -            -            P-           p-            -            P-            P-           p-            P-           -           -           -              -         -          4   -          P-         P.(  	    -         -          4   -          P-         P#      #      #      #      #      #     #     #     #     #     #     #     #     #    
 #     #     #     #     #      #      #      #      #      #        .T  
 .,      -          -           -          -          -          -          -          -          #      #      #      #      #        .N   -          -          -          -          -          #     4    .,       -     !      -            -           P#      #      #      #      #      #      #      #      p" p$ p& `[[`\\`]]J) M + H- H/ H1 H 3 H5 H7 H9 H; H= H? HA H C HE HG HI HK HM HO H Q KT HV H H H H H H H @    X                         J  H  H  `kk`^^`__    H J H "                            @        J Z J\ M ^ L ` Hb H	d Hf Hh Hj Hl Hn L p L r Ht L v Hx Hz H | L ~ L  H! L  L  L  H& H( H* H, H. H0 H2 H4 H6 H8 H  H  H< H> H  HA HB HD L  @    F  G  H  I  J  K  L  M  N  O H  JQ HR    JS J  JT JU M  H  HX HZ H\ H^H`@    a J   `ZZJv  Jw  Jb Jc Mx  He Hg Hz  Hi Hu  Hl Ly L~ L} L| L{ 	@    r  s  t  u  v Hx y$   JzM J{J|J}H H H"H$H'H)H+H-H/H1H3H5H7H9H;H=H?HAHCHEHGHIHKHMH OHQHSHUHWH YH [H]H_HaHcHeHgHiJ kH m@     Ho(   JrJ tJ vJxJzJ|M ~HHHP   JM JJHHH HHHHHHH HHHH HH H HHHH HHHH HH H J H &   J M HH &   J M HH (   JMJ,   JJJJ	JJMHHHT   JJJJJJMHHHN   J"M$H&H,                            O                           	      )    4                    17>DKQV\aj?ENW{Eclsz									





"
(
-
2
5
:
=
B
E
J
M






5;DIR[&/&/6kt    __turboCrt __cvtfak __AHSHIFT __cleanup __checknull __terminate __restorezero _abort DGROUP@ __MMODEL _main @ostream@$blsh$qpxzc @ostream@$blsh$qi @ostream@$blsh$qpqr7ostream$r7ostream _atexit @$bdele$qpv _exit __exit __cexit __c_exit F_LXMUL@ LXMUL@ F_SCOPY@ SCOPY@ N_LDIV@ F_LDIV@ LDIV@ N_LUDIV@ F_LUDIV@ LUDIV@ N_LMOD@ F_LMOD@ LMOD@ N_LUMOD@ LUMOD@ F_LUMOD@ N_LXLSH@ LXLSH@ F_LXLSH@ N_LXURSH@ LXURSH@ F_LXURSH@ __IOERROR __DOSERROR _isatty __AHINCR __LONGTOA __UTOA _lseek @set_new_handler$qpqv$v @$bnew$qui N_LXMUL@ _srand _rand __read __setupio __VPRINTER __VPTR __VRAM ___brk ___sbrk _brk _sbrk _clrscr __CPUTN _cprintf __VideoInt __c0crtinit __crtinit _delay _getch __Ngetche _getche __Nungetch _ungetch __graphexit __graphfreemem __graphgetmem _gettext _puttext _ioctl _kbhit _movetext _free _malloc _realloc _putch __REALCVT __SCREENIO __VALIDATEXY __SCROLL _sound _nosound __wherexy _wherex _wherey __chmod _close __close _fflush _flushall _fseek _ftell _memcpy _open __open ___read _read _setvbuf _strlen ___write __write _write __xfflush @Iostream_delete$qv @endl$qr7ostream @filebuf@close$qv @filebuf@$bctr$qv @filebuf@$bctr$qi @filebuf@$bdtr$qv @filebuf@overflow$qi @filebuf@open$qpxzcii @filebuf@setbuf$qpzci @filebuf@seekoff$ql8seek_diri @filebuf@sync$qv @filebuf@underflow$qv @fstreambase@$bctr$qpxzcii @fstreambase@$bdtr$qv @fstreambase@open$qpxzcii @ifstream@$bctr$qpxzcii @ifstream@$bctr$qpxucii @ifstream@$bdtr$qv @istream_withassign@$basg$qp9streambuf @istream@$bctr$qv @istream_withassign@$bctr$qv @istream@ipfx$qi @istream@$bdtr$qv @istream_withassign@$bdtr$qv @istream@eatwhite$qv @istream@$brsh$qpzc @istream@$brsh$qri @istream@$brsh$qrl @ostream_withassign@$basg$qp9streambuf @ostream@$bctr$qv @ostream_withassign@$bctr$qv @ostream@$bdtr$qv @ostream_withassign@$bdtr$qv @ostream@flush$qv @ostream@$blsh$ql @ostream@$blsh$qul @ostream@$blsh$qzc @ostream@do_opfx$qv @ostream@do_osfx$qv @ostream@outstr$qpxzct1 @streambuf@doallocate$qv @streambuf@$bctr$qv @streambuf@do_snextc$qv @streambuf@do_sgetn$qpzci @streambuf@do_sputn$qpxzci @streambuf@$bdtr$qv @streambuf@overflow$qi @streambuf@pbackfail$qi @streambuf@setbuf$qpzci @streambuf@setb$qpzct1i @streambuf@setg$qpzct1t1 @streambuf@setp$qpzct1 @streambuf@seekoff$ql8seek_diri @streambuf@seekpos$qli @streambuf@sputn$qpxzci @streambuf@sync$qv @streambuf@underflow$qv @ios@clear$qi @ios@$bctr$qv @ios@$bdtr$qv @ios@init$qp9streambuf @ios@setf$ql @ios@setstate$qi @ios@tie$qp7ostream ___move _grapherrormsg _graphresult __GraphNotInstalled _registerfarbgidriver _registerfarbgifont _setgraphbufsize _getmoderange _detectgraph _graphdefaults _initgraph _installuserdriver _installuserfont _setgraphmode _getgraphmode _restorecrtmode _closegraph _cleardevice _setviewport _getviewsettings _clearviewport _moveto _moverel _getx _gety _getmaxx _getmaxy _getdrivername _getmodename _lineto _linerel _getlinesettings _setlinestyle _rectangle _getfillsettings _setfillstyle _getfillpattern _setfillpattern _arc _circle _getaspectratio _setaspectratio _pieslice _setbkcolor _getcolor _getbkcolor _setallpalette _setpalette _getpalette _imagesize _putimage _gettextsettings _outtext _settextjustify _settextstyle _setusercharsize _textheight @DGROUP _postdevice __installdevice __reinstalldevice __gr_setviewport __gr_setgraphmode __gr_restorecrtmode _setvisualpage _setactivepage _setwritemode __gr_setfillpattern __gr_settextjustify __gr_imagesize __autodetect __gr_detectgraph __initdevice __gr_cleardevice __gr_moveto __gr_lineto _line _drawpoly _fillpoly _bar _bar3d _ellipse _fillellipse _sector _getarccoords _setcolor _getmaxcolor _getpalettesize _getdefaultpalette __gr_getmodename _getmaxmode __gr_setbkcolor _setrgbpalette __gr_setpalette __gr_setallpalette __gr_setlinestyle _floodfill __gr_setfillstyle _outtextxy __gr_settextstyle __gr_setusercharsize _textwidth __gr_textheight _getpixel _putpixel _getimage __gr_putimage __GRP_ovr DATASEG@ __Int0Vector __Int4Vector __Int5Vector __Int6Vector __C0argc __C0argv __C0environ __envLng __envseg __envSize __psp __osversion __osmajor __version __osminor _errno __StartTime ___heapbase ___brklvl __heapbase __brklvl __heaptop __BGI_ovr __BGI_auto __DDO_ADD __BGI_ADD __gr_ErrCode __FON_ADD __StatOfs __StatSeg __drawcolor __fillcolor __backcolor __linestyle __fillstyle __OverScanColor __atexitcnt __ctype __exitbuf __exitfopen __exitopen __streams __nfile __openfd __fmode __notUmask __heaplen __doserrno __dosErrorToSV __stklen __wscroll __video _directvideo __cFlag __cChar __first __last __rover @filebuf@openprot @ios@basefield @ios@adjustfield @ios@floatfield @ios@nextbit @ios@usercount __RealCvtVector __ScanTodVector __atexittbl __new_handler _cin _cout _cerr _clog ___stdin_streambuf ___stdout_streambuf ___stderr_streambuf @ios@stdioflush JOC2.CPP JOC2 j i nume g opt_2 c_sel c_nsel c_2_2 c_2_1 bkg color nr_cerc tasta_2 y_cerc_2 x_cerc_2 punctaj y_cerc_1 x_cerc_1 ok opt tasta errorcode gmode gdriver _s this _i _f ios io_state open_mode seek_dir streambuf fstreambase filebuf istream ifstream ostream ostream_withassign istream_withassign iostream fstream ofstream iostream_withassign Pfstream Pofstream Pifstream Pfstreambase Pfilebuf Riostream_withassign Piostream_withassign Rostream_withassign Postream_withassign Ristream_withassign Pistream_withassign Piostream Rostream Postream Ristream Pistream Pstreambuf Pios streamoff streampos ptrdiff_t fpos_t wchar_t size_t ios_user_union @ios@$bctr$qp9streambuf @ios@flags @ios@flags$qv @ios@flags$ql @ios@setf @ios@setf$qll @ios@unsetf @ios@unsetf$ql @ios@width @ios@width$qv @ios@width$qi @ios@fill @ios@fill$qv @ios@fill$qzc @ios@precision @ios@precision$qi @ios@precision$qv @ios@tie @ios@tie$qv @ios@rdstate @ios@rdstate$qv @ios@eof @ios@eof$qv @ios@fail @ios@fail$qv @ios@bad @ios@bad$qv @ios@good @ios@good$qv @ios@clear @ios@$opv$qv @ios@$bnot$qv @ios@rdbuf @ios@rdbuf$qv @ios@bitalloc @ios@bitalloc$qv @ios@xalloc @ios@xalloc$qv @ios@iword @ios@iword$qi @ios@pword @ios@pword$qi @ios@sync_with_stdio @ios@sync_with_stdio$qv @ios@skip @ios@skip$qi bp x_tie state ispecial ospecial x_flags x_precision x_width x_fill isfx_special osfx_special delbuf assign_private @ios@init @ios@setstate userwords nwords @ios@usersize @ios@usersize$qi @ios@$bctr$qr3ios @ios@$basg$qr3ios @ios@goodbit @ios@eofbit @ios@failbit @ios@badbit @ios@hardfail @ios@in @ios@out @ios@ate @ios@app @ios@trunc @ios@nocreate @ios@noreplace @ios@binary @ios@beg @ios@cur @ios@end @streambuf@$bctr$qpzci @streambuf@setbuf @streambuf@setbuf$qpuci @streambuf@setbuf$qpzcii @streambuf@sgetc @streambuf@sgetc$qv @streambuf@snextc @streambuf@snextc$qv @streambuf@sbumpc @streambuf@sbumpc$qv @streambuf@stossc @streambuf@stossc$qv @streambuf@sgetn @streambuf@sgetn$qpzci @streambuf@do_sgetn @streambuf@underflow @streambuf@sputbackc @streambuf@sputbackc$qzc @streambuf@pbackfail @streambuf@in_avail @streambuf@in_avail$qv @streambuf@sputc @streambuf@sputc$qi @streambuf@sputn @streambuf@do_sputn @streambuf@overflow @streambuf@out_waiting @streambuf@out_waiting$qv @streambuf@seekoff @streambuf@seekpos @streambuf@sync @streambuf@dbp @streambuf@dbp$qv @streambuf@base @streambuf@base$qv @streambuf@ebuf @streambuf@ebuf$qv @streambuf@blen @streambuf@blen$qv @streambuf@pbase @streambuf@pbase$qv @streambuf@pptr @streambuf@pptr$qv @streambuf@epptr @streambuf@epptr$qv @streambuf@eback @streambuf@eback$qv @streambuf@gptr @streambuf@gptr$qv @streambuf@egptr @streambuf@egptr$qv @streambuf@setp @streambuf@setg @streambuf@pbump @streambuf@pbump$qi @streambuf@gbump @streambuf@gbump$qi @streambuf@setb @streambuf@unbuffered @streambuf@unbuffered$qi @streambuf@unbuffered$qv @streambuf@allocate @streambuf@allocate$qv @streambuf@doallocate alloc_ unbuf_ base_ ebuf_ pbase_ pptr_ epptr_ eback_ gptr_ egptr_ @streambuf@do_snextc @streambuf@$bctr$qr9streambuf @streambuf@$basg$qr9streambuf @fstreambase@$bctr$qv @fstreambase@$bctr$qi @fstreambase@$bctr$qipzci @fstreambase@open @fstreambase@attach @fstreambase@attach$qi @fstreambase@close @fstreambase@close$qv @fstreambase@setbuf @fstreambase@setbuf$qpzci @fstreambase@rdbuf @fstreambase@rdbuf$qv @fstreambase@verify @fstreambase@verify$qi buf @filebuf@$bctr$qipzci @filebuf@$bctr$qipuci @filebuf@is_open @filebuf@is_open$qv @filebuf@fd @filebuf@fd$qv @filebuf@open @filebuf@open$qpxucii @filebuf@close @filebuf@attach @filebuf@attach$qi @filebuf@overflow @filebuf@underflow @filebuf@sync @filebuf@seekoff @filebuf@setbuf xfd mode opened last_seek in_start @filebuf@last_op @filebuf@last_op$qv lahead @istream@$bctr$qp9streambuf @istream@$bctr$qp9streambufip7ostream @istream@$bctr$qipzci @istream@$bctr$qiip7ostream @istream@ipfx @istream@ipfx0 @istream@ipfx0$qv @istream@ipfx1 @istream@ipfx1$qv @istream@isfx @istream@isfx$qv @istream@seekg @istream@seekg$ql @istream@seekg$ql8seek_dir @istream@tellg @istream@tellg$qv @istream@sync @istream@sync$qv @istream@get @istream@get$qpzcizc @istream@get$qpucizc @istream@read @istream@read$qpzci @istream@read$qpuci @istream@getline @istream@getline$qpzcizc @istream@getline$qpucizc @istream@get$qr9streambufzc @istream@get$qruc @istream@get$qrzc @istream@get$qv @istream@peek @istream@peek$qv @istream@gcount @istream@gcount$qv @istream@putback @istream@putback$qzc @istream@ignore @istream@ignore$qii @istream@$brsh$qpqr7istream$r7istream @istream@$brsh$qpqr3ios$r3ios @istream@$brsh$qpuc @istream@$brsh$qruc @istream@$brsh$qrzc @istream@$brsh$qrs @istream@$brsh$qrus @istream@$brsh$qrui @istream@$brsh$qrul @istream@$brsh$qrf @istream@$brsh$qrd @istream@$brsh$qrg @istream@$brsh$qp9streambuf @istream@eatwhite gcount_ @istream@do_get @istream@do_get$qv @ifstream@$bctr$qv @ifstream@$bctr$qi @ifstream@$bctr$qipzci @ifstream@$bctr$qipuci @ifstream@rdbuf @ifstream@rdbuf$qv @ifstream@open @ifstream@open$qpxzcii @ifstream@open$qpxucii @ostream@$bctr$qp9streambuf @ostream@$bctr$qi @ostream@$bctr$qipzc @ostream@opfx @ostream@opfx$qv @ostream@osfx @ostream@osfx$qv @ostream@flush @ostream@seekp @ostream@seekp$ql @ostream@seekp$ql8seek_dir @ostream@tellp @ostream@tellp$qv @ostream@put @ostream@put$qzc @ostream@write @ostream@write$qpxzci @ostream@write$qpxuci @ostream@$blsh$quc @ostream@$blsh$qs @ostream@$blsh$qus @ostream@$blsh$qui @ostream@$blsh$qf @ostream@$blsh$qd @ostream@$blsh$qg @ostream@$blsh$qpxuc @ostream@$blsh$qpv @ostream@$blsh$qp9streambuf @ostream@$blsh$qpqr3ios$r3ios @ostream@do_opfx @ostream@do_osfx @ostream@outstr @ostream_withassign@$basg$qr7ostream @istream_withassign@$basg$qr7istream @iostream@$bctr$qp9streambuf @iostream@$bdtr$qv @iostream@$bctr$qv @fstream@$bctr$qv @fstream@$bctr$qpxzcii @fstream@$bctr$qpxucii @fstream@$bctr$qi @fstream@$bctr$qipzci @fstream@$bctr$qipuci @fstream@$bdtr$qv @fstream@rdbuf @fstream@rdbuf$qv @fstream@open @fstream@open$qpxzcii @fstream@open$qpxucii @ofstream@$bctr$qv @ofstream@$bctr$qpxzcii @ofstream@$bctr$qpxucii @ofstream@$bctr$qi @ofstream@$bctr$qipzci @ofstream@$bctr$qipuci @ofstream@$bdtr$qv @ofstream@rdbuf @ofstream@rdbuf$qv @ofstream@open @ofstream@open$qpxzcii @ofstream@open$qpxucii @iostream_withassign@$bctr$qv @iostream_withassign@$bdtr$qv @iostream_withassign@$basg$qr3ios @iostream_withassign@$basg$qp9streambuf C:\BORLANDC\BIN\IOSTREAM.H /*  values.h

    Symbolic names for important constants, including machine
    dependencies. A System V compatible header.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__VALUES_H)
#define __VALUES_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef _VALUES_H
#define _VALUES_H

#define BITSPERBYTE 8
#define MAXSHORT    0x7FFF
#define MAXINT      0x7FFF
#define MAXLONG     0x7FFFFFFFL
#define HIBITS      0x8000
#define HIBITI      0x8000
#define HIBITL      0x80000000

#define DMAXEXP     308
#define FMAXEXP     38
#define DMINEXP     -307
#define FMINEXP     -37

#define MAXDOUBLE   1.797693E+308
#define MAXFLOAT    3.37E+38
#define MINDOUBLE   2.225074E-308
#define MINFLOAT    8.43E-37

#define DSIGNIF     53
#define FSIGNIF     24

#define DMAXPOWTWO  0x3FF
#define FMAXPOWTWO  0x7F
#define _DEXPLEN    11
#define _FEXPLEN    8
#define _EXPBASE    2
#define _IEEE       1
#define _LENBASE    1
#define HIDDENBIT   1
#define LN_MAXDOUBLE    7.0978E+2
#define LN_MINDOUBLE    -7.0840E+2

#endif

#endif  /* __VALUES_H */

MZ            >    Pjr                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          &.50!. , ڣ   . => ǋعaC&8ùى   +>R
 s >R
@r(>r"G;r>R
 t> u ;wډ   +؎JW!_ҋ3.5R@+   3&ؾFR .5.r. 6 6 6 P.&ؾRR .5.5r 3/  F-\t	 /  LF! H   5!t v 5!x z 5!| ~ 5!   %ʎں\! %t !%x !%| !% !ô׋;t?t
8gwgӃ;t ? .5t&_&Wô@ !ù V .5 P   U>  t6 9YXX6XPYY PY]UVvNI2܈$vv6TF;Ft~t   ^]U PHPYY]UVWZZ  F PdYFFFv PV3vF  P PYYt( P)YFFFv PVvF@Z P6ZYY_^]URX>  u[ P PwYYu[
 PTPYY]UVW~WYF6ZFF  FFFFvWVXv   F
 P6ZyYY_^]UVWRFF  r~ s~ 6ZF FFWV6V;t 6 .YX6XP	YY PY P6ZYY)~~~ w_^]U POPYY]U/PE	Y1P=	YwP5	YP-	YP%	YP	Y8P	Y:P	YEP	YcPYPYPY P2Y]U\VWvPY~}v3F\?-t\?/u\GFۀ~ft	~FtGGFN~~7C08PYY8PYFPFPPFP8Pu
~ t	~| F  ;Fں  F؍FP^7'YYu~ tFP^7YYt	Fڃ~|~u(C0PYY9PY|PY PY~ u^wFPPFP8P
߃? u(߃S^؋[ ~ tP߃0AYY~|3^wPYY~ t0PP  ߃0Y߃0P[YYP8PYYV=u8PPYY PEY6VeYVF~|u~ rPY PYFRFPFPPFP߃0
~ t߃0FPYYPFPPFPFP
PPFPT=uFPPKYY PYPYZu)P+Y PpY~~f P߃0 P| PXYƇ   PY~~b P߃0 PH P$YƇ   P[Y20~ t*FPPYY PPdYYP PYYET t	PYv6V Y6Ty YtFP8P6RKP<PuP-YY~ t PPYYPY3PW Y_^]U> u F\3]UVv||	 PǇVY^]U
\uvY]UVWvuo g9tt_< |)D u
 9D
u   9D
uDD
1/D@)<WDD
PDP;tD uL 3_^]ULLVWF   D tVcYFOuF_^]UVWv~t= t
GF:F~ t#^? tvVYY|\t
|/t\F~
 tv
VYY~ tvVtYY _^]UVWv~t$WY;FrvWV^  WVqYY_^] ULLVv|.uNNފF .;FtCC.g| u 3^]   / : \ 



UVVWF  ~ t^ ~ t^ ~
 t^
 ~ t^ FF^? tvY=P ~P  FWvV 3NފF r.;FtCC.gu| uVuF uāN vV P 믍F;utFހ? tN vVA P NIuGFހ? tN v
V Pe N< t#<:tXF;tNtEN =<:u~ tN vFP PF_^]  * . / : ? \ <<U,PvvFP&]ULLVWNك? }G@	ً3+FG@ t2ً
? }!O߀?
uFNuG?
uFNuF_^] UVWv~
V>YtGu< ~Vj)FVd_  DD
WvvDPu
=u3_^]UVvDPYVF< }VFVV)FVVF^]UV ;`}>  | ㋷5
VvC
PP^]U,PPvFP]UVvVFP YY^]UVvF<}4\
D
D t>
t>uV
Yt  D uD uL L | tD< tVYtǋD؉\
D
D t>
t>uVYtH>
uD@ u PL
PDP= u PPDP= t
D ub ^]UVvPVYY^]ULLVW~v~D t&V^FPYY=u3 Ou D@ u | te9|s(< tVYtWvDP;s |< u
+DVYtWvt
^ǉ|
pWvDP;sfX| t<1}\
D
S^F[ V^FPYY=u+OuWvDPe;sF_^] PYu& P t 3P3PP8 PuYu& P t 3P3PP UVWv~
9tu~v >P
 uuP
 >N
 uuN
 < t P33PRVD ttYdD   DD
~t=v9~ uW>YFtL mFD
D|~uL 3_^]UVW~vWv4< _^] U^ PFPvFP]U^ PFPvv]UVW~vOY@PvW'_^]ULLVW~v;>`}|㋇FFT
t< tvVb
PPavj
PPN_^] U6 v]Uv3P]U P33PRvw]U VWF@= s3 ^ tvvv ^でFFFFWN^FF<
uFFFv+Ё |3+ЋWPvWF;t~ sLF+F?Bv~ uv+Ћv(WvPvF;t~ s뷋FF+F_^]VW D tVYOu_^UFԁ ;s 3	  ]UFV  u r
;s 	  ]UvY]UFRPYY]UNCFV!rP ]U>^!rǇ3Pj ]UB^33!r$RPB33!FVZYr B!rVFP, ]UDF^N
V!r~ uP ]UVv|X~W 6n
p
؋#n
6 ^] U D^!% ]U^でBF
^NV!rP]U"VW~
^$wXrSFN}~ t-G؃ v+F	+FuNN,
s:F F
_^] UVWv~
uƙ3RPvWPaP[_^]Uvvvv
 PaP?]UVv
vvvV
u 3PaP^]UVW؎~vNsF_^]UN<V!rPi] U^++Ҵ@!] UVWv u%  tz!FFu P3PvuYYF=u)F t3 F t)v3Pn}  t#P P WIYvvE}j F  Vv YY|S3PWxYYF t   t%   P PWU
 tW~ t t PPv| t 3ցЋ㉗_^]ULLN u
 u V"N
=!rF^F% FP]UVWF@= r^ t3 vvv F@= r^ tFbNv<t-<tS PFPv; [F;u S PPQv^く [+_^]U?^NV!rP]UVW~2u~+ tIs_^]UVW؎3؋~2ыvD]+_^]UVW؎~2ы~F_^]UW؎~3H_]UVW؎~2^+ً~F_^]UVv,a<wAD"u^]Ê  '@'U VWF  FP F  FW2I_6GNu/SQRj+jPWvV
uF FP ~jZY[j~~v
t<%t6GNv<%t~3ɉNNNFF2Ћ؀ `s
v.W wNЀ wNŀ w~+tV뵃fN 맀 wMF u)ND~6Fsy؃NFou׉FbsʵFU,0wF|F3uFtFNeN fY


F V3҈V~6
FV~6GGvF t6GG~~u/u+~ u)~NtF% t0 	INRPWǘPFPSFV  Vv~^67CC^F  t6CC^{:Zr6 F fN+ϋV; vV~6F~26  vV~F  u6=F6=Fu
3;NvNuvV~N} WQ^SR #FPF t	 F
F PO~F tV~&=-uI+~VF
t
&=-tO&~^ #F= ufou~ F xtXuN@KKn}F  NF u mK;F@ t0\FVV~'++&<-t< t<+u&7IK0,+&6GN~	˰ 	Iv~F  u6=F6=FP *FF&F tGG&  
v~%
u~P}~ tF_^] \chosw]}'''U^ t P33PRvt@^NV!rP^く XP]VW\r;4tB  _^92t#wt64 ;62tT G43246S[;2twu?u2 ?t\ߋ;t>6wu|6  Ë66t|\]wÉ6__VWDtR r6%= s >2 t6t9s_;uf !  397sk _^P3PP[[% t	3RP[[XP3SP[[=t؉24X@[3P3SP[[=tء4G4X@X3)7@\uËSPQP[tvVF$[^Ë;w5;4uSP[[]+)|Bˋ7كVWU^F
t7t-IЃs ;rwOPeS3[]_^&F  <>@.I!6B>D  2&@Ň֓6 FF > r 2nP@%+r\QI2ً݇ËC wr@ w< t<t<	u2tB
uC2I,"t"<\u<"uIY.I!8Cۋ+r.:v 6
t3F .I!6B>D6@6>8 : &<        Borland C++ - Copyright 1991 Borland Intl. Null pointer assignment
Divide error
Abnormal program termination
                                      @@            _TEXT                          CODE                           ^bgsz
 %*:?DQV[hmr ::  t h   CGA .BGI _CGA_driver EGAVGA .BGI _EGAVGA_driver IBM8514 .BGI _IBM8514_driver HERC .BGI _Herc_driver ATT .BGI _ATT_driver PC3270 .BGI _PC3270_driver TRIP .CHR _triplex_font LITT .CHR _small_font SANS .CHR _sansserif_font GOTH .CHR _gothic_font SCRI .CHR _script_font SIMP .CHR _simplex_font TSCR .CHR _triplex_scr_font LCOM .CHR _complex_font EURO .CHR _euro_font BOLD .CHR _bold_font out of disk space Error writing output file : %s
 Error reading input file : %s
 
 Syntax:   BGIOBJ  [/F]  <source>  <destination[.OBJ]>  <public name>
                         <segment-name>  <segment-class>
 
 The <source> parameter is required, the rest is optional.
 /F selects 'far' version (please read the documentation before using /F).
 
 Examples:
           BGIOBJ        GOTH
           BGIOBJ   /F   CGA
           BGIOBJ        HERC.BGI  HERCDRV  _HERC_fdriver  HERC_TEXT
 
 BGI to OBJ Converter  Version 4.0 Copyright (c) 1987, 1992 Borland International
 
Unknown source filename '%s'.
 Please correct, or specify full source filename and public name.

 Enter BGIOBJ with no parameters to receive help.

 F _far '%s' : unable to open file
 Input file is too large. Maximum size = 65535 bytes.
 .OBJ '%s' : unable to open file
 Not enough memory to run BGIOBJ.
 
%d bytes from '%s' converted into '%s',
 public name = '%s' , segment name = '%s' .

   <	<	<	  	            
                      C           B                                   
                          *             :             J             Z             j             z                                                                                  @  bj	%	9	H	\	  i	x							                    

!
$ Error 0 Invalid function number No such file or directory Path not found Too many open files Permission denied Bad file number Memory arena trashed Not enough memory Invalid memory block address Invalid environment Invalid format Invalid access code Invalid data No such device Attempted to remove current directory Not same device No more files Invalid argument Arg list too big Exec format error Cross-device link Math argument Result too large File already exists Unknown error %s: %s
        Unknown error %s: %s
 %s
    ### (null)   	

                      Y   K!pkBGI Device Driver (IBM8514) 2.00 - Mar 21 1988
Copyright (c) 1987,1988 Borland International
   i                    i IBM8514              U ]CB      Á/k  H 	tF     !]r                 ')+-Û         ø :  $.PS[Xȋ           f        f2                   
          	&CC&CC xP&CC&CC[X6.
            "y+@t2䣦êª <u  &GC&؋                                au640 x 480  8514/A AI 1024 x 768 8514/A AI   (#X'  (#X'                                                                      > t%UWVAtS2&^_]UWV  5!ts	^_]    &+-2&
ģ }o	ã0 gd  2 R<u <u25Ê2@/
Q
21%G+G- Ìȣ3G% DG
               $$      p H  444  p    p  pp p   pp  $          SQ	 kY[ð  _ã:tPCXà      QRȋӇ	 ZYËƋ؀>u ]MU  >u^ <tN<t<s{"u<d  ád= r"    d  1 d= r dpÀ> t>d<sf]d_O =rKK&S   /[ UWVS2&^_]  S3ACC&CCu[  <r,2ྰ> <t2> ȣ6,    >                >uK&$t*SQY[>uKC " ;"x0&>
 tSQY[                 <t  PSQRZY[X  s;r;r@I;wCJ;w]+AM+BU             CE3҈G?A!#PS3ҹZ 3= r [X;tSPZ GXS0 X[) ?APS[X!#CE+>=#u 66QR6WSSPP X X !X #_666!P3>=s)S!#A	26 d- rd dL>G uG?A_V _V ЋË Ëȋ Q<t!2؊ Y ð#t3ҹ "x* B4 B#u  ȣ 2
"y2
"x                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     @8px<iZ-KB$$B3333     "  "         U* F
^FڋF^F ;FFFFuFFuFF^;wd s F܉Vދ^FV3FFFF܋Vދ^^FVs s +FVމFV։~v o F^F^F^;^|
u;Fr l F;F|uF;Fr / F^F^;^
u;Fw5 T F tы] FFFFFFF+FFFFFFFFFFFFFFFFNF)FFFF+FFFFFËVv~F u$ 	  WVv~5r~ ^_ 	  ދƋ ~ u;F|;F~;F};F~
x
x+؋p
x++t3ɇʑËȋrËƋ;? ?@??  0    @        U ?????      &"uÈ"u#x>+;s#x>-;sSQ _^&F UQ Y]Eu        <0uO2<Ar<{rn a> tA&F &^&N&V6 ֖Muڽ6sC2ûf2Ҷ&tr	u	
uu݉6]>_7 22[gYVWUȣea_^Ê22tfQ.F CEuYu
            f    8l  ||    |~  x00000x |     ||  || x`0x 000000 | l8  l8l f< 0` <00000< `0 <<  8l           00       |~~    |~ ~v   |~ 0|0000   ~v|  8<  8 8<         ||     ~v  np```   || 00|000   ~   l8   l   l8l   v|  0`          ;w'a:l !H#l%')+-/2468:<> @ACEGjI<KMNPFRSUKWXZ\]_`bycd9fghjYklmnoqrsttuvwGxyyhz
{{2||3}}~l~~L UFZUF   F}V 3ҹh= ~- V =Z ~ @3Ѓ~  t
Ѓ  ]_P2X=/*****************************************************************************\
*                                                                             *
* penwin.h -    Pen Windows functions, types, and definitions                 *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef __PENWIN_H      /* prevent multiple includes */
#define __PENWIN_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define WINAPI      FAR PASCAL
#define LPARAM      LONG
#define WPARAM      WORD
#endif  /* WIN3.0 */

/****** General Pen Windows Definitions *************************************/

typedef int                    REC;
typedef LONG                   SYV;
typedef SYV FAR                *LPSYV;
typedef HANDLE                 HREC;
typedef int                    CL;
typedef LONG                   ALC;
typedef UINT                   HKP;
typedef int (CALLBACK * LPDF)(int, LPVOID, LPVOID, int, DWORD, DWORD);

#define BITPENUP               0x8000
#define FPenUpX(x)             (((x) & BITPENUP)!=0)

/* Default pen cursor to indicate writing, points northwest */
#define IDC_PEN                MAKEINTRESOURCE(32631)

/* alternate select cursor: upsidedown standard arrow, points southeast */
#define IDC_ALTSELECT          MAKEINTRESOURCE(32501)

#define RC_WDEFAULT            (0xFFFF)
#define RC_LDEFAULT            (0xFFFFFFFFL)
#define RC_WDEFAULTFLAGS       (0x8000)
#define RC_LDEFAULTFLAGS       (0x80000000L)

/* HIWORD(SYV) defines and detection macros */

#define SYVHI_SPECIAL          0
#define FIsSpecial(syv)        (HIWORD((syv))==SYVHI_SPECIAL)
#define SYVHI_ANSI             1
#define FIsAnsi(syv)           (HIWORD((syv))==SYVHI_ANSI)
#define SYVHI_GESTURE          2
#define FIsGesture(syv)        (HIWORD((syv))==SYVHI_GESTURE)
#define SYVHI_KANJI            3
#define FIsKanji(syv)          (HIWORD((syv))==SYVHI_KANJI)
#define SYVHI_SHAPE            4
#define FIsShape(syv)          (HIWORD((syv))==SYVHI_SHAPE)
#define SYVHI_UNICODE          5
#define FIsUniCode(syv)        (HIWORD((syv))==SYVHI_UNICODE)
#define SYVHI_VKEY             6
#define FIsVKey(syv)           (HIWORD((syv))==SYVHI_VKEY)

/* Macros to convert between SYV and ANSI */

#define ChSyvToAnsi(syv)       ((BYTE) (LOBYTE(LOWORD((syv)))))
#define SyvCharacterToSymbol(c) ((LONG)(unsigned char)(c) | 0x00010000)
#define SyvKanjiToSymbol(c) ((LONG)(WORD)(c) | 0x00030000)

/* SYV values with special meanings to Pen Windows */

#define SYV_NULL               0x00000000L
#define SYV_UNKNOWN            0x00000001L
#define SYV_EMPTY              0x00000003L
#define SYV_BEGINOR            0x00000010L
#define SYV_ENDOR              0x00000011L
#define SYV_OR                 0x00000012L
#define SYV_SOFTNEWLINE        0x00000020L
#define SYV_SPACENULL          SyvCharacterToSymbol('\0')

/* SYV values for gestures (map into UNICODE space) */

#define SYV_KKCONVERT          0x0002FFD4L
#define SYV_CLEAR              0x0002FFD5L
#define SYV_EXTENDSELECT       0x0002FFD8L
#define SYV_UNDO               0x0002FFD9L
#define SYV_COPY               0x0002FFDAL
#define SYV_CUT                0x0002FFDBL
#define SYV_PASTE              0x0002FFDCL
#define SYV_CLEARWORD          0x0002FFDDL
#define SYV_USER               0x0002FFDEL      /* ;Reserved */
#define SYV_CORRECT            0x0002FFDFL

#define SYV_BACKSPACE          0x00020008L
#define SYV_TAB                0x00020009L
#define SYV_RETURN             0x0002000DL
#define SYV_SPACE              0x00020020L

#define FIsStdGesture(syv)     \
     ((syv) == SYV_CLEAR       \
   || (syv) == SYV_EXTENDSELECT\
   || (syv) == SYV_UNDO        \
   || (syv) == SYV_COPY        \
   || (syv) == SYV_CUT         \
   || (syv) == SYV_PASTE       \
   || (syv) == SYV_CLEARWORD   \
   || (syv) == SYV_KKCONVERT   \
   || (syv) == SYV_USER        \
   || (syv) == SYV_CORRECT)

#define FIsAnsiGesture(syv)    \
     ((syv) == SYV_BACKSPACE   \
   || (syv) == SYV_TAB         \
   || (syv) == SYV_RETURN      \
   || (syv) == SYV_SPACE)

/* Application specific gestures, Circle a-z and Circle A-Z */

#define SYV_APPGESTUREMASK     0x00020000L
#define SYV_CIRCLEUPA          0x000224B6L
#define SYV_CIRCLEUPZ          0x000224CFL
#define SYV_CIRCLELOA          0x000224D0L
#define SYV_CIRCLELOZ          0x000224E9L

/* Gesture Macros */

#define FIsLoAppGesture(syv)   (syv >= SYV_CIRCLELOA && syv <= SYV_CIRCLELOZ)
#define FIsUpAppGesture(syv)   (syv >= SYV_CIRCLEUPA && syv <= SYV_CIRCLEUPZ)
#define FIsAppGesture(syv)     (syv>=SYV_CIRCLEUPA && syv<=SYV_CIRCLELOZ)

#define SyvAppGestureFromLoAnsi(ansi) ((DWORD)(BYTE)ansi- 'a' + SYV_CIRCLELOA)
#define SyvAppGestureFromUpAnsi(ansi) ((DWORD)(BYTE)ansi- 'A' + SYV_CIRCLEUPA)
#define AnsiFromSyvAppGesture(syv) ChSyvToAnsi( \
    syv-(FIsUpAppGesture(syv)? SYV_CIRCLEUPA-(SYV)'A': SYV_CIRCLELOA-(SYV)'a'))

/* SYV definitions for shapes */

#define SYV_SHAPELINE          0x00040001L
#define SYV_SHAPEELLIPSE       0x00040002L
#define SYV_SHAPERECT          0x00040003L
#define SYV_SHAPEMIN           SYV_SHAPELINE
#define SYV_SHAPEMAX           SYV_SHAPERECT

/****** Recognition Error Codes *********************************************/

#define REC_OEM                (-1024)
#define REC_LANGUAGE           (-48)
#define REC_GUIDE              (-47)
#define REC_PARAMERROR         (-46)
#define REC_INVALIDREF         (-45)
#define REC_RECTEXCLUDE        (-44)
#define REC_RECTBOUND          (-43)
#define REC_PCM                (-42)
#define REC_RESULTMODE         (-41)
#define REC_HWND               (-40)
#define REC_ALC                (-39)
#define REC_ERRORLEVEL         (-38)
#define REC_CLVERIFY           (-37)
#define REC_DICT               (-36)
#define REC_HREC               (-35)
#define REC_BADEVENTREF        (-33)
#define REC_NOCOLLECTION       (-32)

#define REC_DEBUG              (-32)

#define REC_POINTEREVENT       (-31)
#define REC_BADHPENDATA        (-9)
#define REC_OOM                (-8)
#define REC_NOINPUT            (-7)
#define REC_NOTABLET           (-6)
#define REC_BUSY               (-5)
#define REC_BUFFERTOOSMALL     (-4)
#define REC_ABORT              (-3)

#define REC_OVERFLOW           (-1)

#define REC_OK                 0
#define REC_TERMBOUND          1
#define REC_TERMEX             2
#define REC_TERMPENUP          3
#define REC_TERMRANGE          4
#define REC_TERMTIMEOUT        5
#define REC_DONE               6
#define REC_TERMOEM            512

/****** Pen Driver Structures and Entry points ******************************/

typedef struct tagOEMPENINFO
   {
   UINT wPdt;
   UINT wValueMax;
   UINT wDistinct;
   }
   OEMPENINFO, FAR *LPOEMPENINFO;

#define PDT_NULL               0
#define PDT_PRESSURE           1
#define PDT_HEIGHT             2
#define PDT_ANGLEXY            3
#define PDT_ANGLEZ             4
#define PDT_BARRELROTATION     5
#define PDT_OEMSPECIFIC        16

#define MAXOEMDATAWORDS        6

typedef struct tagPENPACKET
   {
   UINT wTabletX;
   UINT wTabletY;
   UINT wPDK;
   UINT rgwOemData[MAXOEMDATAWORDS];
   }
   PENPACKET, FAR *LPPENPACKET;

typedef BOOL (CALLBACK * LPFNRAWHOOK)(LPPENPACKET);

typedef struct tagPENINFO
   {
   UINT cxRawWidth;
   UINT cyRawHeight;
   UINT wDistinctWidth;
   UINT wDistinctHeight;
   int nSamplingRate;
   int nSamplingDist;
   LONG lPdc;
   int cPens;
   int cbOemData;
   OEMPENINFO rgoempeninfo[MAXOEMDATAWORDS];
   UINT rgwReserved[8];
   }
   PENINFO, FAR *LPPENINFO;

#define PDC_INTEGRATED         0x00000001L
#define PDC_PROXIMITY          0x00000002L
#define PDC_RANGE              0x00000004L
#define PDC_INVERT             0x00000008L
#define PDC_RELATIVE           0x00000010L
#define PDC_BARREL1            0x00000020L
#define PDC_BARREL2            0x00000040L
#define PDC_BARREL3            0x00000080L

typedef struct tagSTROKEINFO
   {
   UINT cPnt;
   UINT cbPnts;
   UINT wPdk;
   DWORD dwTick;
   }
   STROKEINFO, FAR *LPSTROKEINFO;

typedef struct tagCALBSTRUCT
   {
   int wOffsetX;
   int wOffsetY;
   int wDistinctWidth;
   int wDistinctHeight;
   }
   CALBSTRUCT, FAR *LPCALBSTRUCT;

/****** DRV_ values for pen driver specific messages ************************/

#define DRV_SetPenDriverEntryPoints    DRV_RESERVED+1
#define DRV_RemovePenDriverEntryPoints DRV_RESERVED+2
#define DRV_SetPenSamplingRate         DRV_RESERVED+3
#define DRV_SetPenSamplingDist         DRV_RESERVED+4
#define DRV_GetName                    DRV_RESERVED+5
#define DRV_GetVersion                 DRV_RESERVED+6
#define DRV_GetPenInfo                 DRV_RESERVED+7
#define DRV_GetCalibration             DRV_RESERVED+11
#define DRV_SetCalibration             DRV_RESERVED+12

VOID WINAPI UpdatePenInfo(LPPENINFO);
BOOL WINAPI EndPenCollection(REC);
REC  WINAPI GetPenHwData(LPPOINT, LPVOID, int, UINT, LPSTROKEINFO);
REC  WINAPI GetPenHwEventData(UINT, UINT, LPPOINT, LPVOID, int, LPSTROKEINFO);
VOID WINAPI PenPacket(VOID);
BOOL WINAPI SetPenHook(HKP, LPFNRAWHOOK);

/****** Pen Hardware Constants **********************************************/

#define PDK_UP                 0x0000
#define PDK_DOWN               0x0001
#define PDK_BARREL1            0x0002
#define PDK_BARREL2            0x0004
#define PDK_BARREL3            0x0008
#define PDK_TRANSITION         0x0010
#define PDK_INVERTED           0x0080
#define PDK_OUTOFRANGE         0x4000
#define PDK_DRIVER             0x8000
#define PDK_TIPMASK            0x0001
#define PDK_SWITCHES           (PDK_DOWN|PDK_BARREL1|PDK_BARREL2|PDK_BARREL3)

#define PCM_PENUP              0x00000001L
#define PCM_RANGE              0x00000002L
#define PCM_INVERT             0x00000020L
#define PCM_RECTEXCLUDE        0x00002000L
#define PCM_RECTBOUND          0x00004000L
#define PCM_TIMEOUT            0x00008000L
#define PCM_ADDDEFAULTS        RC_LDEFAULTFLAGS /* 0x80000000L */

/****** Virtual Event Layer *************************************************/

VOID WINAPI PostVirtualKeyEvent(UINT, BOOL);
VOID WINAPI PostVirtualMouseEvent(UINT, int, int);
VOID WINAPI AtomicVirtualEvent(BOOL);

#define VWM_MOUSEMOVE          0x0001
#define VWM_MOUSELEFTDOWN      0x0002
#define VWM_MOUSELEFTUP        0x0004
#define VWM_MOUSERIGHTDOWN     0x0008
#define VWM_MOUSERIGHTUP       0x0010

/****** RC Definition *************************************************************/

#define CL_NULL                0
#define CL_MINIMUM             1
#define CL_MAXIMUM             100
#define INKWIDTH_MINIMUM       0
#define INKWIDTH_MAXIMUM       15
#define ENUM_MINIMUM           1
#define ENUM_MAXIMUM           4096
#define MAXDICTIONARIES        16

typedef struct tagGUIDE
   {
   int xOrigin;
   int yOrigin;
   int cxBox;
   int cyBox;
   int cxBase;
   int cyBase;
   int cHorzBox;
   int cVertBox;
   int cyMid;
   }
   GUIDE, FAR *LPGUIDE;

typedef BOOL (CALLBACK * RCYIELDPROC)(VOID);

#define cbRcLanguageMax        44
#define cbRcUserMax            32
#define cbRcrgbfAlcMax         32
#define cwRcReservedMax        8

typedef struct tagRC
   {
   HREC hrec;
   HWND hwnd;
   UINT wEventRef;
   UINT wRcPreferences;
   LONG lRcOptions;
   RCYIELDPROC lpfnYield;
   BYTE lpUser[cbRcUserMax];
   UINT wCountry;
   UINT wIntlPreferences;
   char lpLanguage[cbRcLanguageMax];
   LPDF rglpdf[MAXDICTIONARIES];
   UINT wTryDictionary;
   CL clErrorLevel;
   ALC alc;
   ALC alcPriority;
   BYTE rgbfAlc[cbRcrgbfAlcMax];
   UINT wResultMode;
   UINT wTimeOut;
   LONG lPcm;
   RECT rectBound;
   RECT rectExclude;
   GUIDE guide;
   UINT wRcOrient;
   UINT wRcDirect;
   int nInkWidth;
   COLORREF rgbInk;
   DWORD dwAppParam;
   DWORD dwDictParam;
   DWORD dwRecognizer;
   UINT rgwReserved[cwRcReservedMax];
   }
   RC, FAR *LPRC;

typedef HANDLE HPENDATA;

typedef struct tagSYC
   {
   UINT wStrokeFirst;
   UINT wPntFirst;
   UINT wStrokeLast;
   UINT wPntLast;
   BOOL fLastSyc;
   }
   SYC, FAR *LPSYC;

#define wPntAll                (UINT)0xFFFF
#define iSycNull               (-1)

typedef struct tagSYE
   {
   SYV syv;
   LONG lRecogVal;
   CL cl;
   int iSyc;
   }
   SYE, FAR *LPSYE;

#define MAXHOTSPOT             8

typedef struct tagSYG
   {
   POINT rgpntHotSpots[MAXHOTSPOT];
   int cHotSpot;
   int nFirstBox;
   LONG lRecogVal;
   LPSYE lpsye;
   int cSye;
   LPSYC lpsyc;
   int cSyc;
   }
   SYG, FAR *LPSYG;

typedef int (CALLBACK *ENUMPROC)(LPSYV, int, VOID FAR *);

typedef struct tagRCRESULT
   {
   SYG syg;
   UINT wResultsType;
   int cSyv;
   LPSYV lpsyv;
   HANDLE hSyv;
   int nBaseLine;
   int nMidLine;
   HPENDATA hpendata;
   RECT rectBoundInk;
   POINT pntEnd;
   LPRC lprc;
   }
   RCRESULT, FAR *LPRCRESULT;

#define RCRT_DEFAULT           0x0000
#define RCRT_UNIDENTIFIED      0x0001
#define RCRT_GESTURE           0x0002
#define RCRT_NOSYMBOLMATCH     0x0004
#define RCRT_PRIVATE           0x4000
#define RCRT_NORECOG           0x8000
#define RCRT_ALREADYPROCESSED  0x0008
#define RCRT_GESTURETRANSLATED 0x0010
#define RCRT_GESTURETOKEYS     0x0020

#define HKP_SETHOOK            0
#define HKP_UNHOOK             0xFFFF
#define HWR_RESULTS            0
#define HWR_APPWIDE            1

#define PEN_NOINKWIDTH         0
#define LPDFNULL               ((LPDF)NULL)

#define RPA_DEFAULT            1

/* GetGlobalRC return codes */
#define GGRC_OK                0
#define GGRC_DICTBUFTOOSMALL   1
#define GGRC_PARAMERROR        2

/* SetGlobalRC return code flags */
#define SGRC_OK                0x0000
#define SGRC_USER              0x0001
#define SGRC_PARAMERROR        0x0002
#define SGRC_RC                0x0004
#define SGRC_RECOGNIZER        0x0008
#define SGRC_DICTIONARY        0x0010
#define SGRC_INIFILE           0x0020

#define GetWEventRef()         (LOWORD(GetMessageExtraInfo()))

HREC WINAPI InstallRecognizer(LPSTR);
VOID WINAPI UninstallRecognizer(HREC);
UINT WINAPI GetGlobalRC(LPRC, LPSTR, LPSTR, int);
UINT WINAPI SetGlobalRC(LPRC, LPSTR, LPSTR);
VOID WINAPI RegisterPenApp(UINT, BOOL);
UINT WINAPI IsPenAware(VOID);
BOOL WINAPI SetRecogHook(UINT, UINT, HWND);
VOID WINAPI InitRC(HWND, LPRC);
REC  WINAPI Recognize(LPRC);
REC  WINAPI RecognizeData(LPRC, HPENDATA);
BOOL WINAPI TrainInk(LPRC, HPENDATA, LPSYV);
BOOL WINAPI TrainContext(LPRCRESULT, LPSYE, int, LPSYC, int);
REC  WINAPI ProcessWriting(HWND, LPRC);
BOOL WINAPI CorrectWriting(HWND, LPSTR, UINT, LPRC, DWORD, DWORD);
VOID WINAPI EmulatePen(BOOL);
int  WINAPI GetSymbolMaxLength(LPSYG);
int  WINAPI GetSymbolCount(LPSYG);
VOID WINAPI FirstSymbolFromGraph(LPSYG, LPSYV, int, int FAR *);
UINT WINAPI EnumSymbols(LPSYG, WORD, ENUMPROC, LPVOID);

/****** Miscellaneous Functions *********************************************/

BOOL WINAPI TPtoDP(LPPOINT, int);
BOOL WINAPI DPtoTP(LPPOINT, int);
VOID WINAPI BoundingRectFromPoints(LPPOINT, int, LPRECT);
BOOL WINAPI SymbolToCharacter(LPSYV, int, LPSTR, LPINT);
int  WINAPI CharacterToSymbol(LPSTR, int, LPSYV);
UINT WINAPI GetVersionPenWin(VOID);
BOOL WINAPI ExecuteGesture(HWND, SYV, LPRCRESULT);

/****** RC Options and Flags  ***********************************************/

#define ALC_ALL                0x000043FFL
#define ALC_DEFAULT            0x00000000L
#define ALC_LCALPHA            0x00000001L
#define ALC_UCALPHA            0x00000002L
#define ALC_ALPHA              0x00000003L
#define ALC_NUMERIC            0x00000004L
#define ALC_ALPHANUMERIC       0x00000007L
#define ALC_PUNC               0x00000008L
#define ALC_MATH               0x00000010L
#define ALC_MONETARY           0x00000020L
#define ALC_OTHER              0x00000040L
#define ALC_WHITE              0x00000100L
#define ALC_NONPRINT           0x00000200L
#define ALC_GESTURE            0x00004000L
#define ALC_USEBITMAP          0x00008000L
#define ALC_DBCS               0x00000400L
#define ALC_HIRAGANA           0x00010000L
#define ALC_KATAKANA           0x00020000L
#define ALC_KANJI              0x00040000L
#define ALC_OEM                0x0FF80000L
#define ALC_RESERVED           0xF0003800L
#define ALC_NOPRIORITY         0x00000000L
#define ALC_SYSMINIMUM (ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE | ALC_GESTURE)

#define MpAlcB(lprc,i) ((lprc)->rgbfAlc[((i) & 0xff) >> 3])
#define MpIbf(i)       ((BYTE)(1 << ((i) & 7)))

#define SetAlcBitAnsi(lprc,i)      do {MpAlcB(lprc,i) |= MpIbf(i);} while (0)
#define ResetAlcBitAnsi(lprc,i)    do {MpAlcB(lprc,i) &= ~MpIbf(i);} while (0)
#define IsAlcBitAnsi(lprc, i)      ((MpAlcB(lprc,i) & MpIbf(i)) != 0)

#define RCD_DEFAULT            0
#define RCD_LR                 1
#define RCD_RL                 2
#define RCD_TB                 3
#define RCD_BT                 4

#define RCO_NOPOINTEREVENT     0x00000001L
#define RCO_SAVEALLDATA        0x00000002L
#define RCO_SAVEHPENDATA       0x00000004L
#define RCO_NOFLASHUNKNOWN     0x00000008L
#define RCO_TABLETCOORD        0x00000010L
#define RCO_NOSPACEBREAK       0x00000020L
#define RCO_NOHIDECURSOR       0x00000040L
#define RCO_NOHOOK             0x00000080L
#define RCO_BOXED              0x00000100L
#define RCO_SUGGEST            0x00000200L
#define RCO_DISABLEGESMAP      0x00000400L
#define RCO_NOFLASHCURSOR      0x00000800L
#define RCO_COLDRECOG          0x00008000L

#define RCP_LEFTHAND           0x0001
#define RCP_MAPCHAR            0x0004

#define RCOR_NORMAL            1
#define RCOR_RIGHT             2
#define RCOR_UPSIDEDOWN        3
#define RCOR_LEFT              4

#define RRM_STROKE             0
#define RRM_SYMBOL             1
#define RRM_WORD               2
#define RRM_NEWLINE            3
#define RRM_COMPLETE           16

#define RCIP_ALLANSICHAR       0x0001
#define RCIP_MASK              0x0001

#define CWR_STRIPCR            0x00000001L
#define CWR_STRIPLF            0x00000002L
#define CWR_STRIPTAB           0x00000004L
#define CWR_SINGLELINEEDIT     0x00000007L
#define CWR_TITLE              0x00000010L
#define CWR_KKCONVERT          0x00000020L

#define MAP_GESTOGES                            (RCRT_GESTURE|RCRT_GESTURETRANSLATED)
#define MAP_GESTOVKEYS                  (RCRT_GESTURETOKEYS|RCRT_ALREADYPROCESSED)

#define IsGestureToGesture(lprcresult)  (((lprcresult)->wResultstype & MAP_GESTOGES \
                                                                                                         ) == MAP_GESTOGES)

#define IsGestureToVkeys(lprcresult)    (((lprcresult)->wResultstype & MAP_GESTOVKEYS \
                                                                                                         ) == MAP_GESTOVKEYS)

#define SetAlreadyProcessed(lprcresult) ((lprcresult)->wResultsType = ((lprcresult)->wResultsType \
                                                                                                                & ~RCRT_GESTURETOKEYS) | RCRT_ALREADYPROCESSED)

/****** Pen Data Type *******************************************************/

typedef struct tagPENDATAHEADER
   {
   UINT wVersion;
   UINT cbSizeUsed;
   UINT cStrokes;
   UINT cPnt;
   UINT cPntStrokeMax;
   RECT rectBound;
   UINT wPndts;
   int  nInkWidth;
   DWORD rgbInk;
   }
   PENDATAHEADER, FAR *LPPENDATAHEADER, FAR *LPPENDATA;

#define PDTS_LOMETRIC          0x0000
#define PDTS_HIMETRIC          0x0001
#define PDTS_HIENGLISH         0x0002
#define PDTS_SCALEMAX          0x0003
#define PDTS_DISPLAY           0x0003
#define PDTS_ARBITRARY         0x0004
#define PDTS_SCALEMASK         0x000F
#define PDTS_STANDARDSCALE     PDTS_HIENGLISH

#define PDTS_NOPENINFO         0x0100
#define PDTS_NOUPPOINTS        0x0200
#define PDTS_NOOEMDATA         0x0400
#define PDTS_NOCOLINEAR        0x0800
#define PDTS_COMPRESSED        0x8000
#define PDTS_COMPRESSMETHOD    0x00F0
#define PDTS_COMPRESS2NDDERIV  0x0010

#define PDTT_DEFAULT           0x0000
#define PDTT_PENINFO           PDTS_NOPENINFO
#define PDTT_UPPOINTS          PDTS_NOUPPOINTS
#define PDTT_OEMDATA           PDTS_NOOEMDATA
#define PDTT_COLINEAR          PDTS_NOCOLINEAR
#define PDTT_COMPRESS          PDTS_COMPRESSED
#define PDTT_DECOMPRESS        0x4000
#define PDTT_ALL (PDTT_PENINFO|PDTT_UPPOINTS|PDTT_OEMDATA|PDTT_COLINEAR)

#define DestroyPenData(hpendata) (GlobalFree(hpendata)==NULL)
#define EndEnumStrokes(hpendata) GlobalUnlock(hpendata)

BOOL WINAPI IsPenEvent(UINT, LONG);
BOOL WINAPI GetPenAsyncState(UINT);

BOOL WINAPI GetPenDataInfo(HPENDATA, LPPENDATAHEADER, LPPENINFO, DWORD);
BOOL WINAPI GetPenDataStroke(LPPENDATA, UINT, LPPOINT FAR *, LPVOID FAR *, LPSTROKEINFO );
BOOL WINAPI GetPointsFromPenData(HPENDATA, UINT, UINT, UINT, LPPOINT);
VOID WINAPI DrawPenData(HDC, LPRECT, HPENDATA);
BOOL WINAPI MetricScalePenData(HPENDATA, UINT);
BOOL WINAPI ResizePenData(HPENDATA, LPRECT);
BOOL WINAPI OffsetPenData(HPENDATA, int, int);
BOOL WINAPI RedisplayPenData(HDC, HPENDATA, LPPOINT, LPPOINT, int, DWORD);
HPENDATA  WINAPI CompactPenData(HPENDATA, UINT );
HPENDATA  WINAPI DuplicatePenData(HPENDATA, UINT);
HPENDATA  WINAPI CreatePenData(LPPENINFO, int, UINT, UINT);
HPENDATA  WINAPI AddPointsPenData(HPENDATA, LPPOINT, LPVOID, LPSTROKEINFO);
LPPENDATA WINAPI BeginEnumStrokes(HPENDATA );

/****** New Windows Messages ************************************************/

#define WM_RCRESULT            (WM_PENWINFIRST+1)
#define WM_HOOKRCRESULT        (WM_PENWINFIRST+2)
#define WM_GLOBALRCCHANGE      (WM_PENWINFIRST+3)
#define WM_SKB                 (WM_PENWINFIRST+4)
#define WM_HEDITCTL            (WM_PENWINFIRST+5)

/****** Dictionary **********************************************************/

#define cbDictPathMax          255
#define DIRQ_QUERY             1
#define DIRQ_DESCRIPTION       2
#define DIRQ_CONFIGURE         3
#define DIRQ_OPEN              4
#define DIRQ_CLOSE             5
#define DIRQ_SETWORDLISTS      6
#define DIRQ_STRING            7
#define DIRQ_SUGGEST           8
#define DIRQ_ADD               9
#define DIRQ_DELETE            10
#define DIRQ_FLUSH             11
#define DIRQ_RCCHANGE          12
#define DIRQ_SYMBOLGRAPH       13
#define DIRQ_INIT              14
#define DIRQ_CLEANUP           15
#define DIRQ_COPYRIGHT         16


#define DIRQ_USER              4096

BOOL WINAPI DictionarySearch(LPRC, LPSYE, int, LPSYV, int);

/****** Handwriting Edit Control ********************************************/

#define HE_GETRC               3
#define HE_SETRC               4
#define HE_GETINFLATE          5
#define HE_SETINFLATE          6
#define HE_GETUNDERLINE        7
#define HE_SETUNDERLINE        8
#define HE_GETINKHANDLE        9
#define HE_SETINKMODE          10
#define HE_STOPINKMODE         11
#define HE_GETRCRESULTCODE     12
#define HE_DEFAULTFONT         13
#define HE_CHARPOSITION        14
#define HE_CHAROFFSET          15

#define HE_GETRCRESULT         22

#define HE_KKCONVERT           30
#define HE_GETKKCONVERT        31
#define HE_CANCELKKCONVERT     32
#define HE_FIXKKCONVERT        33

#define HEKK_DEFAULT           0
#define HEKK_CONVERT           1
#define HEKK_CANDIDATE         2

#define HEP_NORECOG            0
#define HEP_RECOG              1
#define HEP_WAITFORTAP         2

#define HN_ENDREC              4
#define HN_DELAYEDRECOGFAIL    5

#define HN_RCRESULT            20

#define HN_ENDKKCONVERT        30

typedef struct tagRECTOFS
   {
   int dLeft;
   int dTop;
   int dRight;
   int dBottom;
   }
   RECTOFS, FAR *LPRECTOFS;

/****** Boxed Edit Control **************************************************/

typedef struct tagBOXLAYOUT
   {
   int cyCusp;
   int cyEndCusp;
   UINT style;
   DWORD rgbText;
   DWORD rgbBox;
   DWORD rgbSelect;
   }
   BOXLAYOUT, FAR *LPBOXLAYOUT;

#define BXS_NONE               0U
#define BXS_RECT               1U
#define BXS_ENDTEXTMARK        2U
#define BXS_MASK               3U

#define HE_GETBOXLAYOUT        20
#define HE_SETBOXLAYOUT        21

#define BXD_CELLWIDTH          12
#define BXD_CELLHEIGHT         16
#define BXD_BASEHEIGHT         13
#define BXD_BASEHORZ           0
#define BXD_CUSPHEIGHT         2
#define BXD_ENDCUSPHEIGHT      4

/****** Screen Keyboard *****************************************************/

typedef struct tagSKBINFO
   {
   HWND hwnd;
   UINT nPad;
   BOOL fVisible;
   BOOL fMinimized;
   RECT rect;
   DWORD dwReserved;
   }
   SKBINFO, FAR *LPSKBINFO;

#define SKB_QUERY              0x0000
#define SKB_SHOW               0x0001
#define SKB_HIDE               0x0002
#define SKB_CENTER             0x0010
#define SKB_MOVE               0x0020
#define SKB_MINIMIZE           0x0040
#define SKB_FULL               0x0100
#define SKB_BASIC              0x0200
#define SKB_NUMPAD             0x0400

#define OBM_SKBBTNUP           32767
#define OBM_SKBBTNDOWN         32766
#define OBM_SKBBTNDISABLED     32765

#define SKN_CHANGED            1

#define SKN_POSCHANGED         1
#define SKN_PADCHANGED         2
#define SKN_MINCHANGED         4
#define SKN_VISCHANGED         8
#define SKN_TERMINATED         0xffff

BOOL WINAPI ShowKeyboard(HWND, UINT, LPPOINT, LPSKBINFO);

/****** New ComboBox Notifications  *****************************************/

#define CBN_ENDREC             16
#define CBN_DELAYEDRECOGFAIL   17
#define CBN_RCRESULT           18


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __PENWIN_H */
/*  string.h

    Definitions for memory and string functions.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __STRING_H
#define __STRING_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef NULL
#include <_null.h>
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifdef __cplusplus
extern "C" {
#endif
void _FAR * _Cdecl _FARFUNC memchr  (const void _FAR *__s, int __c, size_t __n);
int         _Cdecl _FARFUNC memcmp(const void _FAR *__s1,
                          const void _FAR *__s2, size_t __n);
void _FAR * _Cdecl _FARFUNC memcpy(void _FAR *__dest, const void _FAR *__src,
                          size_t __n);
void _FAR * _CType _FARFUNC memmove(void _FAR *__dest, const void _FAR *__src,
                           size_t __n);
void _FAR * _CType _FARFUNC memset(void _FAR *__s, int __c, size_t __n);
char _FAR * _CType _FARFUNC strcat(char _FAR *__dest, const char _FAR *__src);
char _FAR * _CType _FARFUNC strchr(const char _FAR *__s, int __c);
int         _CType _FARFUNC strcmp(const char _FAR *__s1, const char _FAR *__s2);
int         _Cdecl strcoll(const char _FAR *__s1, const char _FAR *__s2);
char _FAR * _CType _FARFUNC strcpy(char _FAR *__dest, const char _FAR *__src);
size_t      _Cdecl _FARFUNC strcspn(const char _FAR *__s1, const char _FAR *__s2);
char _FAR * _Cdecl _FARFUNC strerror(int __errnum);
size_t      _CType _FARFUNC strlen(const char _FAR *__s);
char _FAR * _CType _FARFUNC strncat(char _FAR *__dest, const char _FAR *__src,
               size_t __maxlen);
int         _CType _FARFUNC strncmp(const char _FAR *__s1, const char _FAR *__s2,
               size_t __maxlen);
char _FAR * _CType _FARFUNC strncpy(char _FAR *__dest, const char _FAR *__src,
                           size_t __maxlen);
char _FAR * _CType _FARFUNC strpbrk(const char _FAR *__s1, const char _FAR *__s2);
char _FAR * _CType _FARFUNC strrchr(const char _FAR *__s, int __c);
size_t      _Cdecl _FARFUNC strspn(const char _FAR *__s1, const char _FAR *__s2);
char _FAR * _Cdecl _FARFUNC strstr(const char _FAR *__s1, const char _FAR *__s2);
char _FAR * _CType _FARFUNC strtok(char _FAR *__s1, const char _FAR *__s2);
size_t      _Cdecl strxfrm(char _FAR *__s1, const char _FAR *__s2,
               size_t __n );
char _FAR * _Cdecl _FARFUNC _strerror(const char _FAR *__s);


#if !__STDC__
/* compatibility with other compilers */
#define strcmpi(s1,s2)      stricmp(s1,s2)
#define strncmpi(s1,s2,n)   strnicmp(s1,s2,n)

void _FAR * _Cdecl _FARFUNC memccpy(void _FAR *__dest, const void _FAR *__src,
               int __c, size_t __n);
int         _Cdecl _FARFUNC memicmp(const void _FAR *__s1, const void _FAR *__s2,
                           size_t __n);
void        _Cdecl _FARFUNC movedata(unsigned __srcseg,unsigned __srcoff,
                            unsigned __dstseg,unsigned __dstoff, size_t __n);
char _FAR * _CType stpcpy(char _FAR *__dest, const char _FAR *__src);
char _FAR * _Cdecl _stpcpy(char _FAR *__dest, const char _FAR *__src);
char _FAR * _Cdecl _FARFUNC strdup(const char _FAR *__s);
int         _CType _FARFUNC stricmp(const char _FAR *__s1, const char _FAR *__s2);
char _FAR * _CType _FARFUNC strlwr(char _FAR *__s);
int         _CType _FARFUNC strnicmp(const char _FAR *__s1, const char _FAR *__s2,
                size_t __maxlen);
char _FAR * _Cdecl _FARFUNC strnset(char _FAR *__s, int __ch, size_t __n);
char _FAR * _Cdecl _FARFUNC strrev(char _FAR *__s);
char _FAR * _Cdecl _FARFUNC strset(char _FAR *__s, int __ch);
char _FAR * _CType _FARFUNC strupr(char _FAR *__s);

void    far * _FARCALL cdecl _fmemccpy(void far *__dest, const void far *__src,
                int c, size_t __n);
void    far * _FARCALL cdecl _fmemchr(const void far *__s, int c, size_t __n);
int           _FARCALL cdecl _fmemcmp(const void far *__s1, const void far *__s2,
                size_t __n);
void    far * _FARCALL cdecl _fmemcpy(void far *__dest, const void far *__src,
                size_t __n);
int           _FARCALL cdecl _fmemicmp(const void far *__s1, const void far *__s2,
                size_t __n);
void    far * _FARCALL cdecl _fmemmove(void far *__dest, const void far *__src,
                size_t __n);
void    far * _FARCALL cdecl _fmemset(void far *__s, int c, size_t __n);
void          _FARCALL cdecl _fmovmem(const void far *__src, void far *__dest,
                unsigned __length);
void          _FARCALL cdecl _fsetmem(void far *__dest,unsigned __length,
                char __value);

char    far * _FARCALL cdecl _fstrcat(char far *__dest, const char far *__src);
char    far * _FARCALL cdecl _fstrchr(const char far *__s, int c);
int           _FARCALL cdecl _fstrcmp(const char far *__s1, const char far *__s2);
char    far * _FARCALL cdecl _fstrcpy(char far *__dest, const char far *__src);
size_t        _FARCALL cdecl _fstrcspn(const char far *__s1, const char far *__s2);
char    far * _FARCALL cdecl _fstrdup(const char far *__s);
int           _FARCALL cdecl _fstricmp(const char far *__s1, const char far *__s2);
size_t        _FARCALL cdecl _fstrlen(const char far *__s);
char    far * _FARCALL cdecl _fstrlwr(char far *__s);
char    far * _FARCALL cdecl _fstrncat(char far *__dest, const char far *__src,
             size_t maxlen);
int           _FARCALL cdecl _fstrncmp(const char far *__s1, const char far *__s2,
             size_t maxlen);
char    far * _FARCALL cdecl _fstrncpy(char far *__dest, const char far *__src,
             size_t maxlen);
int           _FARCALL cdecl _fstrnicmp(const char far *__s1, const char far *__s2,
              size_t maxlen);
char    far * _FARCALL cdecl _fstrnset(char far *__s, int ch, size_t __n);
char    far * _FARCALL cdecl _fstrpbrk(const char far *__s1, const char far *__s2);
char    far * _FARCALL cdecl _fstrrchr(const char far *__s, int c);
char    far * _FARCALL cdecl _fstrrev(char far *__s);
char    far * _FARCALL cdecl _fstrset(char far *__s, int ch);
size_t        _FARCALL cdecl _fstrspn(const char far *__s1, const char far *__s2);
char    far * _FARCALL cdecl _fstrstr(const char far *__s1, const char far *__s2);
char    far * _FARCALL cdecl _fstrtok(char far *__s1, const char far *__s2);
char    far * _FARCALL cdecl _fstrupr(char far *__s);

#ifdef __MSC
#define _stricmp(s1,s2) stricmp(s1,s2)
#define _strdup(s1)     strdup(s1)
#define _strupr(s1)     strupr(s1)
#define _strlwr(s1)     strlwr(s1)
#define _strrev(s1)     strrev(s1)
#endif

#endif  /* ! __STDC__ */

/* Intrinsic functions */

#if !defined(__MEM_H)
void _FAR * _Cdecl _FARFUNC __memchr__  (const void _FAR *__s, int __c, size_t __n);
int         _Cdecl _FARFUNC __memcmp__(const void _FAR *__s1,
                          const void _FAR *__s2, size_t __n);
void _FAR * _Cdecl _FARFUNC __memcpy__(void _FAR *__dest, const void _FAR *__src,
                          size_t __n);
void _FAR * _CType _FARFUNC __memset__(void _FAR *__s, int __c, size_t __n);
#endif
char _FAR * _Cdecl __stpcpy__(char _FAR *__dest, const char _FAR *__src);
char _FAR * _CType _FARFUNC __strcat__(char _FAR *__dest, const char _FAR *__src);
char _FAR * _Cdecl _FARFUNC __strchr__(const char _FAR *__s, int __c);
int         _CType _FARFUNC __strcmp__(const char _FAR *__s1, const char _FAR *__s2);
char _FAR * _CType _FARFUNC __strcpy__(char _FAR *__dest, const char _FAR *__src);
size_t      _CType _FARFUNC __strlen__(const char _FAR *__s);
char _FAR * _Cdecl _FARFUNC __strncat__(char _FAR *__dest, const char _FAR *__src,
               size_t __maxlen);
int         _Cdecl _FARFUNC __strncmp__(const char _FAR *__s1, const char _FAR *__s2,
               size_t __maxlen);
char _FAR * _CType _FARFUNC __strncpy__(char _FAR *__dest, const char _FAR *__src,
                           size_t __maxlen);
char _FAR * _Cdecl _FARFUNC __strnset__(char _FAR *__s, int __ch, size_t __n);
char _FAR * _CType _FARFUNC __strrchr__(const char _FAR *__s, int __c);
char _FAR * _Cdecl _FARFUNC __strset__(char _FAR *__s, int __ch);

#ifdef __cplusplus
}
#endif

#endif
/*  constrea.h

    Defines the class constream, which writes output to the screen
    using the iostream interface.

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__CONSTREA_H)
#define __CONSTREA_H

#if defined( _Windows )
#error constream not available for Windows
#endif

#if !defined(__IOSTREAM_H)
#include <iostream.h>
#endif  // __IOSTREAM_H

#if !defined(__IOMANIP_H)
#include <iomanip.h>
#endif  // __IOMANIP_H

#if !defined(__CONIO_H)
#include <conio.h>
#endif  // __CONIO_H

class conbuf : public streambuf
{

public:

    conbuf();
    ~conbuf();
    virtual int _Cdecl overflow( int = EOF );

    void _Cdecl clreol();

    void _Cdecl setcursortype( int );

    void _Cdecl highvideo();
    void _Cdecl lowvideo();
    void _Cdecl normvideo();

    void _Cdecl textattr( int );
    void _Cdecl textbackground( int );
    void _Cdecl textcolor( int );

    void _Cdecl gotoxy( int, int );
    int  _Cdecl wherex();
    int  _Cdecl wherey();

    void _Cdecl delline();
    void _Cdecl insline();

    void _Cdecl clrscr();
    void _Cdecl window( int, int, int, int );

    static void _Cdecl textmode( int );

    void activate();
    void deactivate();

private:

    virtual void makeActive();
    virtual void makeInactive();
    virtual void swap();

    text_info data;
    int cursortype;
    static conbuf *current;

};

inline conbuf::~conbuf()
{
    current = 0;
}

inline void conbuf::clreol()
{
    activate();
    ::clreol();
}

inline void conbuf::setcursortype( int t )
{
    activate();
    cursortype = t;
    ::_setcursortype( t );
}

inline void _Cdecl conbuf::highvideo()
{
    activate();
    ::highvideo();
}

inline void _Cdecl conbuf::lowvideo()
{
    activate();
    ::lowvideo();
}

inline void _Cdecl conbuf::normvideo()
{
    activate();
    ::normvideo();
}

inline void conbuf::gotoxy( int x, int y )
{
    activate();
    ::gotoxy( x, y );
}

inline int _Cdecl conbuf::wherex()
{
    activate();
    return ::wherex();
}

inline int _Cdecl conbuf::wherey()
{
    activate();
    return ::wherey();
}

inline void conbuf::textattr( int a )
{
    activate();
    ::textattr( a );
}

inline void _Cdecl conbuf::textbackground(int newcolor)
{
    activate();
    ::textbackground( newcolor );
}

inline void _Cdecl conbuf::textcolor(int newcolor)
{
    activate();
    ::textcolor( newcolor );
}

inline void _Cdecl conbuf::delline()
{
    activate();
    ::delline();
}

inline void _Cdecl conbuf::insline()
{
    activate();
    ::insline();
}

inline void conbuf::clrscr()
{
    activate();
    ::clrscr();
}

inline void conbuf::window(int left, int top, int right, int bottom)
{
    activate();
    ::window( left, top, right, bottom );
}

inline void _Cdecl conbuf::textmode( int mode )
{
    ::textmode( mode );
}

inline void conbuf::activate()
{
    if( current != this )
        swap();
}

inline void conbuf::deactivate()
{
    makeInactive();
}

class constream : public ostream
{

public:

    constream();

    conbuf* _Cdecl rdbuf();     // get the assigned conbuf

    void    _Cdecl clrscr();
    void    _Cdecl window( int, int, int, int );
    void    _Cdecl textmode( int );

    static int _Cdecl isCon( ostream& );

private:

    static long isCon_;
    conbuf buf;

};

inline conbuf* _Cdecl constream::rdbuf()
{
    return (conbuf *)ostream::rdbuf();
}

inline void _Cdecl constream::clrscr()
{
    rdbuf()->clrscr();
}

inline void _Cdecl constream::window( int l, int t, int r, int b )
{
    rdbuf()->window( l, t, r, b );
}

inline void _Cdecl constream::textmode( int m )
{
    rdbuf()->textmode( m );
}

inline int _Cdecl constream::isCon( ostream& o )
{
    return (o.flags() & isCon_) != 0;
}

class omanip_int_int
{

public:
    omanip_int_int(ostream& (*_f)(ostream&, int, int ), int _z1, int _z2 ) :
        _fn(_f), _ag1(_z1), _ag2(_z2) { }
    friend ostream& _Cdecl operator<<(ostream& _s, omanip_int_int& _f)
        { return(*_f._fn)(_s, _f._ag1, _f._ag2); }

private:
    ostream& _Cdecl (*_fn)(ostream&, int, int);
    int _ag1;
    int _ag2;
};

ostream& _Cdecl clreol( ostream& );
ostream& _Cdecl highvideo( ostream& );
ostream& _Cdecl lowvideo( ostream& );
ostream& _Cdecl normvideo( ostream& );
ostream& _Cdecl delline( ostream& );
ostream& _Cdecl insline( ostream& );

omanip_int cdecl setcrsrtype( int );
omanip_int cdecl setattr( int );
omanip_int cdecl setbk( int );
omanip_int cdecl setclr( int );
omanip_int_int cdecl setxy( int, int );

#endif  // __CONSTREA_H

/*  locale.h

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __LOCALE_H
#define __LOCALE_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef NULL
#include <_null.h>
#endif

#define LC_ALL      0
#define LC_COLLATE  1
#define LC_CTYPE    2
#define LC_MONETARY 3
#define LC_NUMERIC  4
#define LC_TIME     5

struct lconv
   {
   char _FAR *decimal_point;
   char _FAR *thousands_sep;
   char _FAR *grouping;
   char _FAR *int_curr_symbol;
   char _FAR *currency_symbol;
   char _FAR *mon_decimal_point;
   char _FAR *mon_thousands_sep;
   char _FAR *mon_grouping;
   char _FAR *positive_sign;
   char _FAR *negative_sign;
   char int_frac_digits;
   char frac_digits;
   char p_cs_precedes;
   char p_sep_by_space;
   char n_cs_precedes;
   char n_sep_by_space;
   char p_sign_posn;
   char n_sign_posn;
   };

#ifdef __cplusplus
extern "C" {
#endif
char _FAR * _Cdecl _FARFUNC setlocale( int __category, const char _FAR *__locale );
struct lconv _FAR * _Cdecl _FARFUNC localeconv( void );
#ifdef __cplusplus
}
#endif

#endif
/*****************************************************************************\
*                                                                             *
* custcntl.h -  Custom Control Library header file                            *
*                                                                             *
\*****************************************************************************/

#ifndef __CUSTCNTL_H    /* prevent multiple includes */
#define __CUSTCNTL_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* WIN3.0 */

/*
 * Every custom control DLL must have three functions present,
 * and they must be exported by the following ordinals.
 */
#define CCINFOORD       2       /* information function ordinal */
#define CCSTYLEORD      3       /* styles function ordinal */
#define CCFLAGSORD      4       /* translate flags function ordinal */

/* general size definitions */
#define CTLTYPES        12      /* max number of control types */
#define CTLDESCR        22      /* max size of description */
#define CTLCLASS        20      /* max size of class name */
#define CTLTITLE        94      /* max size of control text */

/*
 * CONTROL STYLE DATA STRUCTURE
 *
 * This data structure is used by the class style dialog function
 * to set and/or reset various control attributes.
 *
 */
typedef struct tagCTLSTYLE
{
    UINT    wX;                 /* x origin of control */
    UINT    wY;                 /* y origin of control */
    UINT    wCx;                /* width of control */
    UINT    wCy;                /* height of control */
    UINT    wId;                /* control child id */
    DWORD   dwStyle;            /* control style */
    char    szClass[CTLCLASS];  /* name of control class */
    char    szTitle[CTLTITLE];  /* control text */
} CTLSTYLE;
typedef CTLSTYLE *      PCTLSTYLE;
typedef CTLSTYLE FAR*   LPCTLSTYLE;

/*
 * CONTROL DATA STRUCTURE
 *
 * This data structure is returned by the control options function
 * when inquiring about the capabilities of a particular control.
 * Each control may contain various types (with predefined style
 * bits) under one general class.
 *
 * The width and height fields are used to provide the host
 * application with a suggested size.  The values in these fields
 * are in rc coordinates.
 *
 */
typedef struct tagCTLTYPE
{
    UINT    wType;              /* type style */
    UINT    wWidth;             /* suggested width */
    UINT    wHeight;            /* suggested height */
    DWORD   dwStyle;            /* default style */
    char    szDescr[CTLDESCR];  /* description */
} CTLTYPE;

typedef struct tagCTLINFO
{
    UINT    wVersion;           /* control version */
    UINT    wCtlTypes;          /* control types */
    char    szClass[CTLCLASS];  /* control class name */
    char    szTitle[CTLTITLE];  /* control title */
    char    szReserved[10];     /* reserved for future use */
    CTLTYPE Type[CTLTYPES];     /* control type list */
} CTLINFO;
typedef CTLINFO *       PCTLINFO;
typedef CTLINFO FAR*    LPCTLINFO;

/* These two function prototypes are used by the dialog editor */
#ifdef STRICT
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPCSTR);
#else
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPSTR);
#endif
typedef UINT    (CALLBACK* LPFNIDTOSTR)(UINT, LPSTR, UINT);

/* function  prototypes left out of the original custcntl.h */

typedef HGLOBAL (CALLBACK *LPFNINFO)( void );
typedef BOOL            (CALLBACK *LPFNSTYLE)
(
  HWND    hWnd,
  HGLOBAL hCntlStyle,
  LPFNSTRTOID lpfnSID,
  LPFNIDTOSTR lpfnIDS
);

typedef UINT   (CALLBACK *LPFNFLAGS)
(
  DWORD   dwStyle,
  LPSTR   lpBuff,
  UINT    wBuffLength
);

/*****************************************************************************

  Resource Workshop has extended the MS Dialog editor's custom control
  API in three main areas:

  1) More than 1 custom control can be placed in a single DLL

  2) The "Info" data structure has been extended to allow custom controls
     to be added to the RW toolbox

  3) The style data structure has been extended to allow custom controls
     access to the CTLDATA field. This field contains up to 255 bytes
     of binary data. A pointer to this data is passed to the control
     in the WM_CREATE message at runtime.


*****************************************************************************/

/*****************************************************************************

  Two new fields have been added to the CTLTYPE data structure to
  make the RWCTLTYPE structure:

  hToolBit is a handle to a 24X24 bitmap which is added to the
  RW toolbox. If this field is 0, no button will be added for this style,
  and it will only be selectable via the Custom control dialog. This bitmap
  is "owned" by RW, and will be freed by RW when the dialog editor is
  unloaded.

  hDropCurs is a handle to a cursor which is used by RW when a user
  selects the control from the toolbox. If 0, a cross cursor will be used.


*****************************************************************************/

#define TOOLBIT_SIZE  24

typedef struct
{
   UINT       wType;                  /* type style */
   UINT       wWidth;                 /* suggested width */
   UINT       wHeight;                /* suggested height */
   DWORD      dwStyle;                /* default style */
   char       szDescr[CTLDESCR];      /* dialog name */
   HBITMAP    hToolBit;               // Toolbox bitmap
   HCURSOR    hDropCurs;              // Drag and drop cursor

} RWCTLTYPE, FAR * LPRWCTLTYPE;

/*****************************************************************************

  This structure reflects the RWCTLTYPE data structure

*****************************************************************************/


typedef struct
{
   UINT       wVersion;              /* control version */
   UINT       wCtlTypes;             /* control types */
   char       szClass[CTLCLASS];     /* control class name */
   char       szTitle[CTLTITLE];     /* control title */
   char       szReserved[10];        /* reserved for future use */
   RWCTLTYPE  Type[CTLTYPES];        /* Resource Workshop control type list */

} RWCTLINFO;

typedef RWCTLINFO *             PRWCTLINFO;
typedef RWCTLINFO FAR *         LPRWCTLINFO;

/*****************************************************************************

  Two new fields have been added to the CTLSTYLE data structure to make
  the RWCTLSTYLE data structure:

  CtlDataSize is the size of
  CtlData, which is an array of bytes passed to the control in the
  WM_CREATE message.


*****************************************************************************/

#define CTLDATALENGTH 255            // 255 bytes + Length Byte

typedef struct {
  UINT    wX;                       /* x origin of control */
  UINT    wY;                       /* y origin of control */
  UINT    wCx;                      /* width of control */
  UINT    wCy;                      /* height of control */
  UINT    wId;                      /* control child id */
  DWORD   dwStyle;                            /* control style */
  char    szClass[CTLCLASS];        /* name of control class */
  char    szTitle[CTLTITLE];        /* control text */
  BYTE    CtlDataSize;              // Control data Size
  BYTE    CtlData[ CTLDATALENGTH];  // Control data

} RWCTLSTYLE;

typedef RWCTLSTYLE *              PRWCTLSTYLE;
typedef RWCTLSTYLE FAR *          LPRWCTLSTYLE;

/*****************************************************************************

  In order to use RW's extensions to the custom controls, a custom
  control DLL *must* implement the ListClasses function. This function
  returns a global memory handle to an initialized CTLCLASSLIST data
  structure. All function pointers *must* point to valid functions.


*****************************************************************************/

typedef struct
{
  LPFNINFO  fnRWInfo;           // RW Info function
  LPFNSTYLE fnRWStyle;          // RW Style function
  LPFNFLAGS fnFlags;            // Flags function
  char  szClass[ CTLCLASS];

} RWCTLCLASS, FAR *LPRWCTLCLASS;

typedef struct
{
  short       nClasses;
#if defined (__cplusplus)
  RWCTLCLASS Classes[1];
#else
  RWCTLCLASS Classes[];
#endif

} CTLCLASSLIST, FAR *LPCTLCLASSLIST;

#ifdef STRICT
typedef HGLOBAL   (CALLBACK *LPFNLOADRES)( LPCSTR szType, LPCSTR szId);
typedef BOOL      (CALLBACK *LPFNEDITRES)( LPCSTR szType, LPCSTR szId);
#else
typedef HGLOBAL   (CALLBACK *LPFNLOADRES)( LPSTR szType, LPSTR szId);
typedef BOOL      (CALLBACK *LPFNEDITRES)( LPSTR szType, LPSTR szId);
#endif

#ifdef STRICT
typedef HGLOBAL (CALLBACK *LPFNLIST)
(
  LPSTR       szAppName,
  UINT        wVersion,
  LPFNLOADRES fnLoad,
  LPFNEDITRES fnEdit
);
#else
typedef HGLOBAL (CALLBACK *LPFNLIST)
(
  LPCSTR      szAppName,
  UINT        wVersion,
  LPFNLOADRES fnLoad,
  LPFNEDITRES fnEdit
);
#endif

#define DLGCUSTCLASSNAME   "_BorDlg_DlgEditChild"
#define DLGTESTCLASSNAME   "_BorDlg_DlgEditTest"


// Rw version 1.02 and above send a message to a control
// when the user is about to delete it. The message id
// is that returned by RegisterWindowMessage, with the following
// name:

#define RWDELETEMSGNAME "Rws_deletecontrol"

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __CUSTCNTL_H */
PKBGI Stroked Font V1.1 - Jun 5, 1989
Copyright (c) 1987,1988 Borland International
 LITT                             +               * J f         
 0Bfr$.:DXv(:JTbn (:JV^jt| 4DTbx .DPfn(@^|"@Tz	,	J	b	|						

$
6
L
`
x






  Dr 0>LV`n|$@P`p
$6Hbz*Hd"0>Zn	
		                                                                                                                                                                                                                                               ~          ~                       ~   ~                                                                                                     	                                    		   		                                                                                     ~~                                                                                                                                                                                                                                                   ;**************************************************************************
;*  TOOLHELP.INC
;*
;*      Assembly-language public include file for TOOLHELP.DLL
;*
;**************************************************************************

;** General symbol values
MAX_DATA        EQU     11
MAX_PATH        EQU     255
MAX_MODULE_NAME EQU     8 + 1           ;Leave room for the zero and padding
MAX_CLASSNAME   EQU     255

; ----- Global heap walking -----

GLOBALENTRY STRUC
ge_dwSize       DD      ?               ;Structure version
ge_dwAddress    DD      ?               ;This block's address
ge_dwBlockSize  DD      ?               ;This block's size
ge_hBlock       DW      ?               ;This block's handle
ge_wcLock       DW      ?               ;Lock count
ge_wcPageLock   DW      ?               ;Page lock count
ge_wFlags       DW      ?               ;Block flags
ge_wHeapPresent DW      ?               ;Size of available local heap
ge_hOwner       DW      ?               ;Owner handle
ge_wType        DW      ?               ;Block type
ge_wData        DW      ?               ;Type-specific data
ge_dwNext       DD      ?               ;Pointer to next block
ge_dwNextAlt    DD      ?               ;Next free/LRU block in chain
GLOBALENTRY ENDS

; ** GlobalFirst()/GlobalNext() flags
GLOBAL_ALL      EQU     0
GLOBAL_LRU      EQU     1
GLOBAL_FREE     EQU     2

; ** GLOBALENTRY.ge_wType entries
GT_UNKNOWN      EQU     0
GT_DGROUP       EQU     1
GT_DATA         EQU     2
GT_CODE         EQU     3
GT_TASK         EQU     4
GT_RESOURCE     EQU     5
GT_MODULE       EQU     6
GT_FREE         EQU     7
GT_INTERNAL     EQU     8
GT_SENTINEL     EQU     9
GT_BURGERMASTER EQU     10

; ** if GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData:
GD_USERDEFINED          EQU     0
GD_CURSORCOMPONENT      EQU     1
GD_BITMAP               EQU     2
GD_ICONCOMPONENT        EQU     3
GD_MENU                 EQU     4
GD_DIALOG               EQU     5
GD_STRING               EQU     6
GD_FONTDIR              EQU     7
GD_FONT                 EQU     8
GD_ACCELERATORS         EQU     9
GD_RCDATA               EQU     10
GD_ERRTABLE             EQU     11
GD_CURSOR               EQU     12
GD_ICON                 EQU     14
GD_NAMETABLE            EQU     15
GD_MAX_RESOURCE         EQU     15

;** GLOBALENTRY.wFlags
GF_PDB_OWNER    EQU     100h            ;Low byte is KERNEL flags

; ----- Local heap walking -----

LOCALENTRY STRUC
le_dwSize       DD      ?
le_hHandle      DW      ?
le_wAddress     DW      ?
le_wSize        DW      ?
le_wFlags       DW      ?
le_wcLock       DW      ?
le_wType        DW      ?
le_hHeap        DW      ?
le_wHeapType    DW      ?
le_wNext        DW      ?
LOCALENTRY ENDS

; ** LOCALENTRY.wHeapType flags
NORMAL_HEAP     EQU     0
USER_HEAP       EQU     1
GDI_HEAP        EQU     2

;** LOCALENTRY.wFlags
LF_FIXED                EQU     1
LF_FREE                 EQU     2
LF_MOVEABLE             EQU     4

;** LOCALENTRY.wType
LT_NORMAL               EQU     0
LT_GDI_PEN              EQU     1
LT_GDI_BRUSH            EQU     2
LT_GDI_FONT             EQU     3
LT_GDI_PALETTE          EQU     4
LT_GDI_BITMAP           EQU     5
LT_GDI_RGN              EQU     6
LT_GDI_DC               EQU     7
LT_GDI_DISABLED_DC      EQU     8
LT_GDI_METADC           EQU     9
LT_GDI_METAFILE         EQU     10
LT_GDI_MAX              EQU     LT_GDI_METAFILE
LT_FREE                 EQU     0ffh

; ----- Stack tracing -----

STACKTRACEENTRY STRUC
st_dwSize       DD      ?
st_hTask        DW      ?
st_wSS          DW      ?
st_wBP          DW      ?
st_wCS          DW      ?
st_wIP          DW      ?
st_hModule      DW      ?
st_wSegment     DW      ?
st_wFlags       DW      ?
STACKTRACEENTRY ENDS

;** STACKTRACEENTRY.wFlags values
FRAME_FAR       EQU     0
FRAME_NEAR      EQU     1

; ----- Module list walking -----

MODULEENTRY STRUC
me_dwSize       DD      ?
me_szModule     DB      MAX_MODULE_NAME + 1 DUP(?)
me_hModule      DW      ?
me_wcUsage      DW      ?
me_szExePath    DB      MAX_PATH + 1 + 1 DUP(?)
me_wNext        DW      ?
MODULEENTRY ENDS

; ----- Task list walking -----

TASKENTRY STRUC
te_dwSize               DD      ?
te_hTask                DW      ?
te_hTaskParent          DW      ?
te_hInst                DW      ?
te_hModule              DW      ?
te_wSS                  DW      ?
te_wSP                  DW      ?
te_wStackTop            DW      ?
te_wStackMinimum        DW      ?
te_wStackBottom         DW      ?
te_wcEvents             DW      ?
te_hQueue               DW      ?
te_szModule             DB      MAX_MODULE_NAME + 1 DUP(?)
te_wPSPOffset           DW      ?
te_hNext                DW      ?
TASKENTRY ENDS

;** TaskSwitch() return values
TS_ERROR    EQU         0
TS_NEW      EQU         1
TS_OLD      EQU         2

; ----- Window Class enumeration -----

CLASSENTRY STRUC
ce_dwSize               DD      ?
ce_hInst                DW      ?
ce_szClassName          DB      MAX_CLASSNAME + 1 DUP(?)
ce_wNext                DW      ?
CLASSENTRY ENDS

; ----- Information functions -----

VMEMMANINFO STRUC
vmm_dwSize              DD      ?
vmm_dwLargestFreeBlock  DD      ?
vmm_dwMaxPagesAvailable DD      ?
vmm_dwMaxPagesLockable  DD      ?
vmm_dwTotalLinearSpace  DD      ?
vmm_dwTotalUnlockedPages DD     ?
vmm_dwFreePages         DD      ?
vmm_dwTotalPages        DD      ?
vmm_dwFreeLinearSpace   DD      ?
vmm_dwSwapFilePages     DD      ?
vmm_wPageSize           DW      ?
VMEMMANINFO ENDS

SYSHEAPINFO STRUC
si_dwSize               DD      ?
si_wUserFreePercent     DW      ?
si_wGDIFreePercent      DW      ?
si_hUserSegment         DW      ?
si_hGDISegment          DW      ?
SYSHEAPINFO ENDS

; ----- Notifications -----

;* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
;*      should ignore these.
;*
NFY_UNKNOWN     EQU     0

;** NFY_LOADSEG:  dwData points to a NFYLOADSEG structure
NFY_LOADSEG     EQU     1
NFYLOADSEG STRUC
nls_dwSize              DD      ?
nls_wSelector           DW      ?
nls_wSegNum             DW      ?
nls_wType               DW      ?       ;Low bit set for DATA, clear for CODE
nls_wcInstance          DW      ?       ;Instance count ONLY VALID FOR DATA!
nls_lpstrModuleName     DD      ?
NFYLOADSEG ENDS

;** NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed
NFY_FREESEG     EQU     2

;** NFY_STARTDLL:  dwData points to a NFYSTARTDLL structure
NFY_STARTDLL    EQU     3
NFYSTARTDLL STRUC
nsd_dwSize              DD      ?
nsd_hModule             DW      ?
nsd_wCS                 DW      ?
nsd_wIP                 DW      ?
NFYSTARTDLL ENDS

;** NFY_STARTTASK:  dwData is the CS:IP of the task start address
NFY_STARTTASK   EQU     4

;** NFY_EXITTASK:  The low byte of dwData contains the program exit code
NFY_EXITTASK    EQU     5

;** NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed
NFY_DELMODULE   EQU     6

;** NFY_RIP:  LOWORD(dwData) is the fatal exit code
;** NFY_RIP:  dwData points to a NFYRIP structure
NFY_RIP         EQU     7
NFYRIP STRUC
nrp_dwSize      DD      ?
nrp_wIP         DW      ?
nrp_wCS         DW      ?
nrp_wSS         DW      ?
nrp_wBP         DW      ?
nrp_wExitCode   DW      ?
NFYRIP ENDS

;** NFY_TASKIN:  No data.  Callback should do GetCurrentTask()
NFY_TASKIN      EQU     8

;** NFY_TASKOUT:  No data.  Callback should do GetCurrentTask()
NFY_TASKOUT     EQU     9

;** NFY_INCHAR:  Return value of callback is used.  If FALSE, mapped to 'i'
NFY_INCHAR      EQU     10

;** NFY_OUTSTR:  dwData points to the string to be displayed
NFY_OUTSTR      EQU     11

;** NFY_LOGERROR:  dwData points to a NFYLOGERROR struct
NFY_LOGERROR    EQU     12
NFYLOGERROR STRUC
nle_dwSize      DD      ?
nle_wErrCode    DW      ?
nle_lpInfo      DD      ?       ;Error-code dependent
NFYLOGERROR ENDS

;** NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct
NFY_LOGPARAMERROR EQU   13
NFYLOGPARAMERROR STRUC
nlp_dwSize              DD      ?
nlp_wErrCode            DW      ?
nlp_lpfnErrorAddr       DD      ?
nlp_lpBadParam          DD      ?
NFYLOGPARAMERROR ENDS

;** NotifyRegister() flags
NF_NORMAL       EQU     0
NF_TASKSWITCH   EQU     1
NF_RIP          EQU     2

;** TerminateApp() flag values
UAE_BOX         EQU     0
NO_UAE_BOX      EQU     1

TIMERINFO STRUC
ti_dwSize               DD      ?
ti_dwmsSinceStart       DD      ?
ti_dwmsThisVM           DD      ?
TIMERINFO ENDS

/*  float.h

    Defines implementation specific macros for dealing with
    floating point.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __FLOAT_H
#define __FLOAT_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#define FLT_RADIX           2
#define FLT_ROUNDS          1
#define FLT_GUARD           1
#define FLT_NORMALIZE       1

#define DBL_DIG             15
#define FLT_DIG             6
#define LDBL_DIG            19

#define DBL_MANT_DIG        53
#define FLT_MANT_DIG        24
#define LDBL_MANT_DIG       64

#define DBL_EPSILON         2.2204460492503131E-16
#define FLT_EPSILON         1.19209290E-07F
#define LDBL_EPSILON        1.084202172485504E-19

/* smallest positive IEEE normal numbers */
#define DBL_MIN             2.2250738585072014E-308
#define FLT_MIN             1.17549435E-38F
#define LDBL_MIN            _tiny_ldble

#define DBL_MAX             _huge_dble
#define FLT_MAX             _huge_flt
#define LDBL_MAX            _huge_ldble

#define DBL_MAX_EXP         +1024
#define FLT_MAX_EXP         +128
#define LDBL_MAX_EXP        +16384

#define DBL_MAX_10_EXP      +308
#define FLT_MAX_10_EXP      +38
#define LDBL_MAX_10_EXP     +4932

#define DBL_MIN_10_EXP      -307
#define FLT_MIN_10_EXP      -37
#define LDBL_MIN_10_EXP     -4931

#define DBL_MIN_EXP         -1021
#define FLT_MIN_EXP         -125
#define LDBL_MIN_EXP        -16381

extern float        _Cdecl _huge_flt;
extern double       _Cdecl _huge_dble;
extern long double  _Cdecl _huge_ldble;
extern long double  _Cdecl _tiny_ldble;

#ifdef __cplusplus
extern "C" {
#endif
unsigned int _Cdecl _FARFUNC _clear87(void);
unsigned int _Cdecl _FARFUNC _control87(unsigned int __newcw, unsigned int __mask);
void         _Cdecl _FARFUNC _fpreset(void);
unsigned int _Cdecl _FARFUNC _status87(void);
#ifdef __cplusplus
}
#endif

#if !__STDC__

/* 8087/80287 Status Word format   */

#define SW_INVALID      0x0001  /* Invalid operation            */
#define SW_DENORMAL     0x0002  /* Denormalized operand         */
#define SW_ZERODIVIDE   0x0004  /* Zero divide                  */
#define SW_OVERFLOW     0x0008  /* Overflow                     */
#define SW_UNDERFLOW    0x0010  /* Underflow                    */
#define SW_INEXACT      0x0020  /* Precision (Inexact result)   */

/* 8087/80287 Control Word format */

#define MCW_EM              0x003f  /* interrupt Exception Masks*/
#define     EM_INVALID      0x0001  /*   invalid                */
#define     EM_DENORMAL     0x0002  /*   denormal               */
#define     EM_ZERODIVIDE   0x0004  /*   zero divide            */
#define     EM_OVERFLOW     0x0008  /*   overflow               */
#define     EM_UNDERFLOW    0x0010  /*   underflow              */
#define     EM_INEXACT      0x0020  /*   inexact (precision)    */

#define MCW_IC              0x1000  /* Infinity Control */
#define     IC_AFFINE       0x1000  /*   affine         */
#define     IC_PROJECTIVE   0x0000  /*   projective     */

#define MCW_RC          0x0c00  /* Rounding Control     */
#define     RC_CHOP     0x0c00  /*   chop               */
#define     RC_UP       0x0800  /*   up                 */
#define     RC_DOWN     0x0400  /*   down               */
#define     RC_NEAR     0x0000  /*   near               */

#define MCW_PC          0x0300  /* Precision Control    */
#define     PC_24       0x0000  /*    24 bits           */
#define     PC_53       0x0200  /*    53 bits           */
#define     PC_64       0x0300  /*    64 bits           */

/* 8087/80287 Initial Control Word */
/* use affine infinity, mask underflow and precision exceptions */

#define CW_DEFAULT  _default87
extern unsigned int _Cdecl _default87;

/*
    SIGFPE signal error types (for integer & float exceptions).
*/
#define FPE_INTOVFLOW       126 /* 80x86 Interrupt on overflow  */
#define FPE_INTDIV0         127 /* 80x86 Integer divide by zero */

#define FPE_INVALID         129 /* 80x87 invalid operation      */
#define FPE_ZERODIVIDE      131 /* 80x87 divide by zero         */
#define FPE_OVERFLOW        132 /* 80x87 arithmetic overflow    */
#define FPE_UNDERFLOW       133 /* 80x87 arithmetic underflow   */
#define FPE_INEXACT         134 /* 80x87 precision loss         */
#define FPE_STACKFAULT      135 /* 80x87 stack overflow         */
#define FPE_EXPLICITGEN     140 /* When SIGFPE is raise()'d     */

/*
            SIGSEGV signal error types.
*/
#define SEGV_BOUND          10  /* A BOUND violation (SIGSEGV)  */
#define SEGV_EXPLICITGEN    11  /* When SIGSEGV is raise()'d    */

/*
            SIGILL signal error types.
*/
#define ILL_EXECUTION       20  /* Illegal operation exception  */
#define ILL_EXPLICITGEN     21  /* When SIGILL is raise()'d     */

#endif  /* !__STDC__ */

#endif
/*  iostream.h -- basic stream I/O declarations

    Copyright (c) 1990, 1992 by Borland International
    All rights reserved.

    There are some inline functions here which generate a LOT of code
    (as much as 300 bytes), but are available inline because AT&T did
    it that way.  We have also made them true functions in the library
    and conditionally deleted the inline code from this header.

    If you really want these big functions to be inline, #define the
    macro name _BIG_INLINE_ before including this header.

    Programs will compile and link correctly even if some modules are
    compiled with _BIG_INLINE_ and some are not.
*/

#ifndef __cplusplus
#error Must use C++ for the type iostream.
#endif

#ifndef __IOSTREAM_H
#define __IOSTREAM_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(__MEM_H)
#include <mem.h>    // to get memcpy and NULL
#endif

#pragma option -Vo-
#if defined(__BCOPT__) && !defined(_RTL_ALLOW_po)
#pragma option -po-
#endif

// Definition of EOF must match the one in <stdio.h>
#define EOF (-1)

// extract a char from int i, ensuring that zapeof(EOF) != EOF
#define zapeof(i) ((unsigned char)(i))

typedef long streampos;
typedef long streamoff;

_CLASSDEF(ios)
_CLASSDEF(streambuf)
_CLASSDEF(istream)
_CLASSDEF(ostream)
_CLASSDEF(iostream)
_CLASSDEF(istream_withassign)
_CLASSDEF(ostream_withassign)
_CLASSDEF(iostream_withassign)

class _CLASSTYPE ios {
public:
    // stream status bits
    enum io_state   {
        goodbit  = 0x00,    // no bit set: all is ok
        eofbit   = 0x01,    // at end of file
        failbit  = 0x02,    // last I/O operation failed
        badbit   = 0x04,    // invalid operation attempted
        hardfail = 0x80     // unrecoverable error
        };

    // stream operation mode
    enum open_mode  {
        in   = 0x01,        // open for reading
        out  = 0x02,        // open for writing
        ate  = 0x04,        // seek to eof upon original open
        app  = 0x08,        // append mode: all additions at eof
        trunc    = 0x10,    // truncate file if already exists
        nocreate = 0x20,    // open fails if file doesn't exist
        noreplace= 0x40,    // open fails if file already exists
        binary   = 0x80     // binary (not text) file
        };

    // stream seek direction
    enum seek_dir { beg=0, cur=1, end=2 };

    // formatting flags
    enum    {
        skipws    = 0x0001, // skip whitespace on input
        left      = 0x0002, // left-adjust output
        right     = 0x0004, // right-adjust output
        internal  = 0x0008, // padding after sign or base indicator
        dec   = 0x0010,     // decimal conversion
        oct   = 0x0020,     // octal conversion
        hex   = 0x0040,     // hexadecimal conversion
        showbase  = 0x0080, // use base indicator on output
        showpoint = 0x0100, // force decimal point (floating output)
        uppercase = 0x0200, // upper-case hex output
        showpos   = 0x0400, // add '+' to positive integers
        scientific= 0x0800, // use 1.2345E2 floating notation
        fixed     = 0x1000, // use 123.45 floating notation
        unitbuf   = 0x2000, // flush all streams after insertion
        stdio     = 0x4000  // flush stdout, stderr after insertion
        };

    // constants for second parameter of seft()
static  const long basefield;       // dec | oct | hex
static  const long adjustfield;     // left | right | internal
static  const long floatfield;      // scientific | fixed

    // constructor, destructor
        _Cdecl ios(streambuf _FAR *);
virtual _Cdecl ~ios();

    // for reading/setting/clearing format flags
    long    _Cdecl flags();
    long    _Cdecl flags(long);
    long    _Cdecl setf(long _setbits, long _field);
    long    _Cdecl setf(long);
    long    _Cdecl unsetf(long);

    // reading/setting field width
    int     _Cdecl width();
    int     _Cdecl width(int);

    // reading/setting padding character
    char    _Cdecl fill();
    char    _Cdecl fill(char);

    // reading/setting digits of floating precision
    int     _Cdecl precision(int);
    int     _Cdecl precision();

    // reading/setting ostream tied to this stream
    ostream _FAR * _Cdecl tie(ostream _FAR *);
    ostream _FAR * _Cdecl tie();

    // find out about current stream state
    int     _Cdecl rdstate();       // return the stream state
    int     _Cdecl eof();           // non-zero on end of file
    int     _Cdecl fail();          // non-zero if an operation failed
    int     _Cdecl bad();           // non-zero if error occurred
    int     _Cdecl good();          // non-zero if no state bits set
    void    _Cdecl clear(int = 0);  // set the stream state
            _Cdecl operator void _FAR * (); // zero if state failed
    int     _Cdecl operator! ();    // non-zero if state failed

    streambuf _FAR * _Cdecl rdbuf();        // get the assigned streambuf

    // for declaring additional flag bits and user words
static long _Cdecl bitalloc();  // acquire a new flag bit, value returned
static int  _Cdecl xalloc();    // acquire a new user word, index returned
    long  _FAR & _Cdecl iword(int);  // return the nth user word as an int
    void _FAR * _FAR & _Cdecl pword(int);  // return the nth user word as a pointer

static void _Cdecl sync_with_stdio();

    // obsolete, for streams 1.2 compatibility
    int     _Cdecl skip(int);

protected:
    // additional state flags for ispecial and ospecial
    enum { skipping = 0x100, tied = 0x200 };

    streambuf _FAR * bp;    // the associated streambuf
    ostream _FAR * x_tie;   // the tied ostream, if any
    int     state;          // status bits
    int     ispecial;       // istream status bits  ***
    int     ospecial;       // ostream status bits  ***
    long    x_flags;        // formatting flag bits
    int     x_precision;    // floating-point precision on output
    int     x_width;        // field width on output
    int     x_fill;         // padding character on output
    int     isfx_special;   // unused       ***
    int     osfx_special;   // unused       ***
    int     delbuf;         // unused       ***
    int     assign_private; // unused       ***
/*
 * The data members marked with *** above are not documented in the AT&T
 * release of streams, so we cannot guarantee compatibility with any
 * other streams release in the use or values of these data members.
 * If you can document any expected behavior of these data members, we
 * will try to adjust our implementation accordingly.
 */

            _Cdecl ios();       // null constructor, does not initialize

    void    _Cdecl init(streambuf _FAR *);  // the actual initialization

    void    _Cdecl setstate(int);       // set all status bits

static  void _Cdecl (*stdioflush)();

private:
    // for extra flag bits and user words
static  long    nextbit;
static  int usercount;
    union ios_user_union _FAR *userwords;
    int     nwords;
    void    _Cdecl usersize(int);

    // these declarations prevent automatic copying of an ios
            _Cdecl ios(ios _FAR &);           // declared but not defined
    void    _Cdecl operator= (ios _FAR &);    // declared but not defined

};
inline streambuf _FAR * _Cdecl ios::rdbuf() { return bp; }
inline ostream _FAR * _Cdecl ios::tie() { return x_tie; }
inline char     _Cdecl ios::fill() { return x_fill; }
inline int      _Cdecl ios::precision() { return x_precision; }
inline int      _Cdecl ios::rdstate() { return state; }
inline int      _Cdecl ios::eof() { return state & eofbit; }
inline int      _Cdecl ios::fail()
                        { return state & (failbit | badbit | hardfail); }
inline int      _Cdecl ios::bad() { return state & (badbit | hardfail); }
inline int      _Cdecl ios::good() { return state == 0; }
inline long     _Cdecl ios::flags() { return x_flags; }
inline int      _Cdecl ios::width() { return x_width; }
inline int      _Cdecl ios::width(int _w)
                        { int _i = x_width; x_width = _w; return _i; }
inline char     _Cdecl ios::fill(char _c)
                        { char _x = x_fill; x_fill = _c; return _x; }
inline int      _Cdecl ios::precision(int _p)
                        { int _x = x_precision; x_precision = _p; return _x; }
inline          _Cdecl ios::operator void _FAR *()
                        { return fail() ? 0 : this; }
inline int      _Cdecl ios::operator! () { return fail(); }


class _CLASSTYPE streambuf {
public:
    // constructors and destructors
        _Cdecl streambuf();                 // make empty streambuf
        _Cdecl streambuf(char _FAR *, int); // make streambuf with
                                            // given char array
virtual _Cdecl ~streambuf();

    // use the provided char array for the buffer if possible
virtual streambuf _FAR * _Cdecl setbuf(  signed char _FAR *, int);
    // WARNING:  this function is not virtual; do not override
    streambuf _FAR *  _Cdecl setbuf(unsigned char _FAR *, int);

    // obsolete, for streams 1.2 compatibility
    streambuf _FAR *  _Cdecl setbuf(char _FAR *, int, int);

    // getting (extracting) characters
    int     _Cdecl sgetc();         // peek at next char
    int     _Cdecl snextc();        // advance to and return next char
    int     _Cdecl sbumpc();        // return current char and advance
    void    _Cdecl stossc();        // advance to next character
    int     _Cdecl sgetn(char _FAR *, int);     // get next n chars
virtual int _Cdecl do_sgetn(char _FAR *, int);  // implementation of sgetn
virtual int _Cdecl underflow();     // fill empty buffer
    int     _Cdecl sputbackc(char); // return char to input
virtual int _Cdecl pbackfail(int);  // implementation of sputbackc
    int     _Cdecl in_avail();      // number of avail chars in buffer

    // putting (inserting) characters
    int     _Cdecl sputc(int);          // put one char
    int     _Cdecl sputn(const char _FAR *, int); // put n chars from string
virtual int _Cdecl do_sputn(const char _FAR * s, int n); // implementation of sputn
virtual int _Cdecl overflow(int = EOF); // flush buffer and make more room
    int     _Cdecl out_waiting();       // number of unflushed chars

    // moving around in stream
virtual streampos _Cdecl seekoff(streamoff, ios::seek_dir,
                                 int = (ios::in | ios::out));
virtual streampos _Cdecl seekpos(streampos, int = (ios::in | ios::out));
virtual int _Cdecl sync();

    void    _Cdecl dbp();       // for debugging streambuf implementations

protected:
    char _FAR * _Cdecl base();  // return start of buffer area
    char _FAR * _Cdecl ebuf();  // return end+1 of buffer area
    int     _Cdecl blen();      // return length of buffer area
    char _FAR * _Cdecl pbase(); // return start of put area
    char _FAR * _Cdecl pptr();  // return next location in put area
    char _FAR * _Cdecl epptr(); // return end+1 of put area
    char _FAR * _Cdecl eback(); // return base of putback section of get area
    char _FAR * _Cdecl gptr();  // return next location in get area
    char _FAR * _Cdecl egptr(); // return end+1 of get area
    void    _Cdecl setp(char _FAR *, char _FAR *); // initialize the put pointers
    void    _Cdecl setg(char _FAR *, char _FAR *, char _FAR *); // initialize the get pointers
    void    _Cdecl pbump(int);  // advance the put pointer
    void    _Cdecl gbump(int);  // advance the get pointer
    void    _Cdecl setb(char _FAR *, char _FAR *, int = 0 );    // set the buffer area
    void    _Cdecl unbuffered(int);// set the buffering state
    int     _Cdecl unbuffered();    // non-zero if not buffered
    int     _Cdecl allocate();  // set up a buffer area
virtual int _Cdecl doallocate();    // implementation of allocate

private:
    short   alloc_;     // non-zero if buffer should be deleted
    short   unbuf_;     // non-zero if unbuffered
    char _FAR * base_;  // start of buffer area
    char _FAR * ebuf_;  // end+1 of buffer area
    char _FAR * pbase_; // start of put area
    char _FAR * pptr_;  // next put location
    char _FAR * epptr_; // end+1 of put area
    char _FAR * eback_; // base of putback section of get area
    char _FAR * gptr_;  // next get location
    char _FAR * egptr_; // end+1 of get area

    int     _Cdecl do_snextc(); // implementation of snextc

    // these declarations prevent copying of a streambuf
            _Cdecl streambuf(streambuf _FAR &);   // declared but not defined
    void    _Cdecl operator= (streambuf _FAR &);  // declared but not defined
};
inline char _FAR * _Cdecl streambuf::base()  { return base_; }
inline char _FAR * _Cdecl streambuf::pbase() { return pbase_; }
inline char _FAR * _Cdecl streambuf::pptr()  { return pptr_; }
inline char _FAR * _Cdecl streambuf::epptr() { return epptr_; }
inline char _FAR * _Cdecl streambuf::gptr()  { return gptr_; }
inline char _FAR * _Cdecl streambuf::egptr() { return egptr_; }
inline char _FAR * _Cdecl streambuf::eback() { return eback_; }
inline char _FAR * _Cdecl streambuf::ebuf()  { return ebuf_; }
inline int   _Cdecl streambuf::unbuffered()  { return unbuf_; }
inline int   _Cdecl streambuf::blen() { return (int)(ebuf_ - base_);}
inline streambuf _FAR *
            _Cdecl streambuf::setbuf(unsigned char _FAR * _p, int _len)
                { // call the virtual function
                    return setbuf((signed char _FAR *)_p, _len); }
inline void _Cdecl streambuf::pbump(int _n) { pptr_ += _n; }
inline void _Cdecl streambuf::gbump(int _n) { gptr_ += _n; }
inline void _Cdecl streambuf::unbuffered(int _unb) { unbuf_ = (_unb != 0); }
inline int  _Cdecl streambuf::in_avail()
                { return (egptr_ > gptr_) ? (int)(egptr_ - gptr_) : 0; }
inline int  _Cdecl streambuf::out_waiting()
                { return pptr_ ? (int)(pptr_ - pbase_) : 0; }
inline int  _Cdecl streambuf::allocate() {
                return (base_ || unbuf_) ? 0 : doallocate();
                }
inline int  _Cdecl streambuf::sgetc() {
                return (gptr_ >= egptr_) ? underflow() :
                   (unsigned char)(*gptr_);
                }
inline int  _Cdecl streambuf::snextc() {
                return (! gptr_ || (++gptr_ >= egptr_)) ?
                    do_snextc() :
                    (unsigned char)(*gptr_);
                }
inline int  _Cdecl streambuf::sbumpc() {
                return (gptr_ >= egptr_ && underflow() == EOF) ?
                    EOF :
                    (unsigned char)(*gptr_++);
                }
inline void _Cdecl streambuf::stossc() {
                if( gptr_ >= egptr_ ) underflow();
                else ++gptr_;
                }
inline int  _Cdecl streambuf::sputbackc(char _c) {
                return (gptr_ > eback_) ?
                    (unsigned char)(*--gptr_ = _c) :
                    pbackfail(_c);
                }
inline int  _Cdecl streambuf::sputc(int _c) {
                return (pptr_ >= epptr_) ?
                    overflow((unsigned char)_c) :
                    (unsigned char)(*pptr_++ = _c);
                }
#ifdef _BIG_INLINE_
inline int  _Cdecl streambuf::sputn(const char _FAR * _s, int _n) {
                if( _n <= (epptr_ - pptr_) ) {
                    memcpy(pptr_, _s, _n);
                    pbump(_n);
                    return _n;
                }
                return do_sputn(_s, _n);
                }
inline int  _Cdecl streambuf::sgetn(char _FAR * _s, int _n) {
                if( _n <= (egptr_ - gptr_) ) {
                    memcpy(_s, gptr_, _n);
                    gbump(_n);
                    return _n;
                }
                return do_sgetn(_s, _n);
                }
#endif


class _CLASSTYPE istream : virtual public ios {
public:
    // constructor and destructor
        _Cdecl istream(streambuf _FAR *);
virtual _Cdecl ~istream();

    // Obsolete constructors, for streams 1.2 compatibility
        // obsolete: set skip via format, tie via tie() function
        _Cdecl istream(streambuf _FAR *, int _sk, ostream _FAR * _t=0);
        // obsolete: use strstream
        _Cdecl istream(int _sz, char _FAR *, int _sk=1);
        // obsolete: use fstream
        _Cdecl istream(int _fd, int _sk=1, ostream _FAR * _t=0);

    int _Cdecl ipfx(int = 0);       // input prefix function
    int _Cdecl ipfx0();     // same as ipfx(0)
    int _Cdecl ipfx1();     // same as ipfx(1)
    void _Cdecl isfx()      { } // unused input suffix function

    // set/read the get pointer's position
    istream _FAR & _Cdecl seekg(streampos);
    istream _FAR & _Cdecl seekg(streamoff, ios::seek_dir);
    streampos _Cdecl tellg();

    int _Cdecl sync();

    /*
     * Unformatted extraction operations
     */
    // extract characters into an array
    istream _FAR & _Cdecl get(  signed char _FAR *, int, char = '\n');
    istream _FAR & _Cdecl get(unsigned char _FAR *, int, char = '\n');
    istream _FAR & _Cdecl read(  signed char _FAR *, int);
    istream _FAR & _Cdecl read(unsigned char _FAR *, int);

    // extract characters into an array up to termination char
    istream _FAR & _Cdecl getline(  signed char _FAR *, int, char = '\n');
    istream _FAR & _Cdecl getline(unsigned char _FAR *, int, char = '\n');

    // extract characters into a streambuf up to termination char
    istream _FAR & _Cdecl get(streambuf _FAR &, char = '\n');

    // extract a single character
    istream _FAR & _Cdecl get(unsigned char _FAR &);
    istream _FAR & _Cdecl get(  signed char _FAR &);
    int      _Cdecl get();

    int      _Cdecl peek();     // return next char without extraction
    int      _Cdecl gcount();   // number of unformatted chars last extracted
    istream _FAR & _Cdecl putback(char);  // push back char into input

    // extract and discard chars but stop at delim
    istream _FAR & _Cdecl ignore(int = 1, int = EOF);

    /*
     * Formatted extraction operations
     */
    istream _FAR & _Cdecl operator>> (istream _FAR & (_Cdecl *_f)(istream _FAR &));
    istream _FAR & _Cdecl operator>> (ios _FAR & (_Cdecl *_f)(ios _FAR &) );
    istream _FAR & _Cdecl operator>> (  signed char _FAR *);
    istream _FAR & _Cdecl operator>> (unsigned char _FAR *);
    istream _FAR & _Cdecl operator>> (unsigned char _FAR &);
    istream _FAR & _Cdecl operator>> (  signed char _FAR &);
    istream _FAR & _Cdecl operator>> (short _FAR &);
    istream _FAR & _Cdecl operator>> (int _FAR &);
    istream _FAR & _Cdecl operator>> (long _FAR &);
    istream _FAR & _Cdecl operator>> (unsigned short _FAR &);
    istream _FAR & _Cdecl operator>> (unsigned int _FAR &);
    istream _FAR & _Cdecl operator>> (unsigned long _FAR &);
    istream _FAR & _Cdecl operator>> (float _FAR &);
    istream _FAR & _Cdecl operator>> (double _FAR &);
    istream _FAR & _Cdecl operator>> (long double _FAR &);

    // extract from this istream, insert into streambuf
    istream _FAR & _Cdecl operator>> (streambuf _FAR *);

protected:
            _Cdecl istream();
    void    _Cdecl eatwhite();      // extract consecutive whitespace

private:
    int gcount_;    // chars extracted by last unformatted operation
    signed char _Cdecl do_get();    // implementation of get
};
inline int  _Cdecl istream::gcount() { return gcount_; }
inline int  _Cdecl istream::ipfx0()  { return ipfx(0); }
inline int  _Cdecl istream::ipfx1()  { return ipfx(1); }
#ifdef _BIG_INLINE_
inline istream _FAR & _Cdecl istream::operator>> (unsigned char _FAR & _c) {
                if( ipfx0() )
                    _c = bp->in_avail() ? bp->sbumpc() : do_get();
                return *this;
                }
inline istream _FAR & _Cdecl istream::operator>> (signed char _FAR & _c) {
                if( ipfx0() )
                    _c = bp->in_avail() ? bp->sbumpc() : do_get();
                return *this;
                }
#endif
inline istream _FAR & _Cdecl istream::operator>> (unsigned char _FAR *_p) {
                return *this >> (signed char _FAR *)_p;
                }
inline istream _FAR & _Cdecl istream::get(unsigned char _FAR *_p, int _l, char _t) {
                return get((signed char _FAR *)_p, _l, _t);
                }
inline istream _FAR & _Cdecl istream::read(unsigned char _FAR *_p, int _l) {
                return read((signed char _FAR *)_p, _l);
                }
inline istream _FAR & _Cdecl istream::getline(unsigned char _FAR *_p, int _l, char _t) {
                return getline((signed char _FAR *) _p, _l, _t);
                }
inline int      _Cdecl istream::sync() { return bp->sync(); }
inline istream _FAR & _Cdecl istream::operator>> (istream _FAR & (_Cdecl *_f)(istream _FAR &)) {
                return (*_f)(*this);
                }
#ifdef _BIG_INLINE_
inline istream _FAR & _Cdecl istream::get(unsigned char _FAR & _c) {
                if( ipfx1() )
                    if( bp->in_avail() ) {
                        gcount_ = 1;
                        _c = bp->sbumpc();
                    }
                else _c = do_get();
                return *this;
                }
inline istream _FAR & _Cdecl istream::get(signed char _FAR & _c) {
                if( ipfx1() )
                    if( bp->in_avail()) {
                        gcount_ = 1;
                        _c = bp->sbumpc();
                    }
                else _c = do_get();
                return *this;
                }
inline int      _Cdecl istream::get() {
                if( ipfx1() ) {
                    int _c = bp->sbumpc();
                    if( _c == EOF ) setstate(eofbit);
                    else gcount_ = 1;
                    return _c;
                }
                else return EOF;
                }
#endif
inline int  _Cdecl istream::peek() { return ipfx1() ? bp->sgetc() : EOF; }


class _CLASSTYPE ostream : virtual public ios {
public:
    // constructors and destructor
        _Cdecl ostream(streambuf _FAR *);
virtual _Cdecl ~ostream();
    // Obsolete constructors, for streams 1.2 compatibility
        _Cdecl ostream(int _fd); // obsolete, use fstream
        _Cdecl ostream(int _sz, char _FAR *); // obsolete, use strstream

    int _Cdecl opfx();      // output prefix function
    void _Cdecl osfx();     // output suffix function
    ostream _FAR & _Cdecl flush();

    // set/read the put pointer's position
    ostream _FAR & _Cdecl seekp(streampos);
    ostream _FAR & _Cdecl seekp(streamoff, ios::seek_dir);
    streampos _Cdecl tellp();

    /*
     * Unformatted insertion operations
     */
    ostream _FAR & _Cdecl put(char);  // insert the character
    ostream _FAR & _Cdecl write(const   signed char _FAR *, int); // insert the string
    ostream _FAR & _Cdecl write(const unsigned char _FAR *, int); // insert the string

    /*
     * Formatted insertion operations
     */
    // insert the character
    ostream _FAR & _Cdecl operator<< (  signed char);
    ostream _FAR & _Cdecl operator<< (unsigned char);

    // for the following, insert character representation of numeric value
    ostream _FAR & _Cdecl operator<< (short);
    ostream _FAR & _Cdecl operator<< (unsigned short);
    ostream _FAR & _Cdecl operator<< (int);
    ostream _FAR & _Cdecl operator<< (unsigned int);
    ostream _FAR & _Cdecl operator<< (long);
    ostream _FAR & _Cdecl operator<< (unsigned long);
    ostream _FAR & _Cdecl operator<< (float);
    ostream _FAR & _Cdecl operator<< (double);
    ostream _FAR & _Cdecl operator<< (long double);

    // insert the null-terminated string
    ostream _FAR & _Cdecl operator<< (const   signed char _FAR *);
    ostream _FAR & _Cdecl operator<< (const unsigned char _FAR *);

    // insert character representation of the value of the pointer
    ostream _FAR & _Cdecl operator<< (void _FAR *);

    // extract from streambuf, insert into this ostream
    ostream _FAR & _Cdecl operator<< (streambuf _FAR *);

    // manipulators
    ostream _FAR & _Cdecl operator<< (ostream _FAR & (_Cdecl *_f)(ostream _FAR &));
    ostream _FAR & _Cdecl operator<< (ios _FAR & (_Cdecl *_f)(ios _FAR &));

protected:
    int     _Cdecl do_opfx();   // implementation of opfx
    void    _Cdecl do_osfx();   // implementation of osfx
            _Cdecl ostream();

private:
    void    _Cdecl outstr(const signed char _FAR *, const signed char _FAR *);
};
inline int  _Cdecl ostream::opfx() { return ospecial ? do_opfx() : 1; }
inline void _Cdecl ostream::osfx() { if( x_flags & (stdio | unitbuf) ) do_osfx(); }
#ifdef _BIG_INLINE_
inline ostream _FAR & _Cdecl ostream::operator<< (signed char _c) {
                if( opfx() )
                    if( bp->sputc(_c) == EOF ) setstate(badbit);
                        osfx();
                return *this;
                }
#endif
inline ostream _FAR & _Cdecl ostream::operator<< (unsigned char _c) {
                return *this << (signed char)_c;
                }
inline ostream _FAR & _Cdecl ostream::operator<< (const signed char _FAR * _s) {
                outstr(_s, (const signed char _FAR *)0);
                return *this;
                }
inline ostream _FAR & _Cdecl ostream::operator<< (const unsigned char _FAR * _s) {
                outstr((const signed char _FAR *)_s, (const signed char _FAR *)0);
                return *this;
                }
inline ostream _FAR & _Cdecl ostream::operator<< (short _i)
                { return *this << (long) _i; }
inline ostream _FAR & _Cdecl ostream::operator<< (unsigned short _i)
                { return *this << (unsigned long) _i; }
inline ostream _FAR & _Cdecl ostream::operator<< (int _i)
                { return *this << (long) _i; }
inline ostream _FAR & _Cdecl ostream::operator<< (unsigned int _i)
                { return *this << (unsigned long) _i; }
inline ostream _FAR & _Cdecl ostream::operator<< (float _f)
                { return *this << (long double) _f; }
inline ostream _FAR & _Cdecl ostream::operator<< (double _d)
                { return *this << (long double) _d; }
inline ostream _FAR & _Cdecl ostream::operator<< (ostream _FAR & (_Cdecl *_f)(ostream _FAR &))
                { return (*_f)(*this); }
inline ostream _FAR & _Cdecl ostream::write(const unsigned char _FAR * _s, int _n)
                { return write((const signed char _FAR *)_s, _n); }
inline ostream _FAR & _Cdecl ostream::put(char _c) {
                if( bp->sputc(_c) == EOF ) setstate(badbit);
                return *this;
                }
#ifdef _BIG_INLINE_
inline ostream _FAR & _Cdecl ostream::write(const signed char _FAR * _s, int _n) {
                if( ! fail() )
                    if( bp->sputn((const char _FAR *)_s, _n) != _n )
                        setstate(badbit);
                return *this;
                }
#endif


class _CLASSTYPE iostream : public istream, public ostream {
public:
        _Cdecl iostream(streambuf _FAR *);
virtual _Cdecl ~iostream();

protected:
        _Cdecl iostream();
};


class _CLASSTYPE istream_withassign : public istream {
public:
        // does no initialization
        _Cdecl istream_withassign();

virtual _Cdecl ~istream_withassign();

    // gets buffer from istream and does entire initialization
    istream_withassign _FAR & _Cdecl operator= (istream _FAR &);

    // associates streambuf with stream and does entire initialization
    istream_withassign _FAR & _Cdecl operator= (streambuf _FAR *);
};


class _CLASSTYPE ostream_withassign : public ostream {
public:
        // does no initialization
        _Cdecl ostream_withassign();

virtual _Cdecl ~ostream_withassign();

    // gets buffer from istream and does entire initialization
    ostream_withassign _FAR & _Cdecl operator= (ostream _FAR &);

    // associates streambuf with stream and does entire initialization
    ostream_withassign _FAR & _Cdecl operator= (streambuf _FAR *);
};


class _CLASSTYPE iostream_withassign : public iostream {
public:
        // does no initialization
        _Cdecl iostream_withassign();

virtual _Cdecl ~iostream_withassign();

    // gets buffer from stream and does entire initialization
    iostream_withassign _FAR & _Cdecl operator= (ios _FAR &);

    // associates streambuf with stream and does entire initialization
    iostream_withassign _FAR & _Cdecl operator= (streambuf _FAR *);
};


/*
 * The predefined streams
 */
extern istream_withassign _Cdecl cin;
extern ostream_withassign _Cdecl cout;
extern ostream_withassign _Cdecl cerr;
extern ostream_withassign _Cdecl clog;

/*
 * Manipulators
 */
ostream _FAR & _Cdecl endl(ostream _FAR &); // insert newline and flush
ostream _FAR & _Cdecl ends(ostream _FAR &); // insert null to terminate string
ostream _FAR & _Cdecl flush(ostream _FAR &);// flush the ostream
ios _FAR &     _Cdecl dec(ios _FAR &);      // set conversion base to decimal
ios _FAR &     _Cdecl hex(ios _FAR &);      // set conversion base to hexadecimal
ios _FAR &     _Cdecl oct(ios _FAR &);      // set conversion base to octal
istream _FAR & _Cdecl ws(istream _FAR &);   // extract whitespace characters

/*
 * Initialization call for Easy Windows
 */
extern "C" void  _Cdecl _InitEasyWin(void);

#pragma option -Vo.
#if defined(__BCOPT__)
#pragma option -po.
#endif

#endif
/*  malloc.h

    memory management functions and variables.

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#include <alloc.h>

#if defined(__TINY__) || defined(__SMALL__) || defined(__MEDIUM__)

/* Near heap functions currently allowed only in small data models */

#define _nmalloc(size)          malloc(size)
#define _nfree(block)           free(block)
#define _nrealloc(block,size)   realloc(block,size)
#define _ncalloc(num,size)      calloc(num,size)
#define _nheapmin()             0
#define _memavl()               coreleft()

#endif  /* small data models */

/* Model-independent functions */

#define _fmalloc(size)          farmalloc((unsigned long)(size))
#define _ffree(block)           farfree(block)
#define _frealloc(block,size)   farrealloc(block,(unsigned long)(size))
#define _fcalloc(num,size)      farcalloc((unsigned long)(num),(unsigned long)(size))
#define halloc(num,size)        (void huge *)farmalloc((unsigned long)(num)*(size))
#define hfree(block)            farfree((void far *)(block))
#define _heapmin()              0
#define _fheapmin()             0

/* Prototypes */

#ifdef __cplusplus
extern "C" {
#endif
void *      _Cdecl alloca     (size_t __size);
void *      _Cdecl __alloca__ (size_t __size);
#if defined(__BCOPT__ ) && !defined(_Windows)
#define     alloca  __alloca__
#endif
size_t      _Cdecl stackavail (void);
#ifdef __cplusplus
}
#endif
/*  signal.h

    Definitions for ANSI defined signaling capability

    Copyright (c) 1988, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __SIGNAL_H
#define __SIGNAL_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

typedef int sig_atomic_t;   /* Atomic entity type (ANSI) */
typedef void _Cdecl (_FARFUNC * _CatcherPTR)();

#define SIG_DFL ((_CatcherPTR)0)   /* Default action   */
#define SIG_IGN ((_CatcherPTR)1)   /* Ignore action    */
#define SIG_ERR ((_CatcherPTR)-1)  /* Error return     */

#define SIGABRT 22
#define SIGFPE  8       /* Floating point trap  */
#define SIGILL  4       /* Illegal instruction  */
#define SIGINT  2
#define SIGSEGV 11      /* Memory access violation */
#define SIGTERM 15

#ifdef __cplusplus
extern "C" {
#endif
int _Cdecl _FARFUNC raise(int __sig);
#ifdef __cplusplus
void _Cdecl (* _Cdecl _FARFUNC signal(int __sig, void _Cdecl (* _FARFUNC __func)(int))) (int);
}
#else
void _Cdecl _FARFUNC (* _Cdecl _FARFUNC signal(int __sig, void _Cdecl _FARFUNC (* func)())) (int);
#endif

#endif
PKBGI Stroked Font V1.1 - May 17, 1989
Copyright (c) 1987,1988 Borland International
 EUROw                             +    -          6 J v     *6FN\d",\4Bf (2@Lr&4@NZfnz8Jr6Vj.:J	B	x			
8
d






Lh.T*Tx2Fr 4Dh
,@T`p"2FZr~*:DN^p,Xz>Vfv
(FTj#6(
   	          % "##! *"$ ' !#5##! (%"%%01$!%$%+"%%$$$$$$$$....!$$#$/!		#   *    *&&   *    #0   &*       **   *   *   **   "              *          "   #         "   *               "      "                                 $    *           *   *                              **   *   *   *    *   *   *   /   *   /      ~   /             *          y        &   v&                       v             &                       '   ~   (   "       !   &&   )   "   ""   )   (&      "   ""   )    ""    "    )    ..    1/    )   
    *)    "    ##    )   "   )}    ""    //   *22    &   )    0      &   )    )    )   )    #    ,   %        *           +"   +"    *   ###   ##   "%%~~~(++"%%~~~(++   "%%~~~(++"%%~~~(++"%%~~~(++"%%~~~(++   '**'**$$$!$$'**'**!$$		   }  }  )******$$$!$$!$$		   }  }     +   +   ~   ++         ++   ++      ++                     +      +   ~   ++               ++      ++                           ++   +   +   ~   +++++++++++++++++++++++++++++++            ++++++++++++++    ++++++++++++++   ++++++++++++++++++++++++++                          |      ++||   *          
    &   *            +    +    +   )      '       "           &   "   '         /*  _null.h

    Definition of NULL.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef NULL
#  if defined(__TINY__) || defined(__SMALL__) || defined(__MEDIUM__)
#    define NULL    0
#  else
#    define NULL    0L
#  endif
#endif
/*  errno.h

    Defines the system error variable errno and the error
    numbers set by system calls. Errors which exist in Unix(tm)
    but not MSDOS have value -1.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __ERRNO_H
#define __ERRNO_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

/*  Dos Error Codes */

#define EZERO    0      /* Error 0                  */
#define EINVFNC  1      /* Invalid function number  */
#define ENOFILE  2      /* File not found           */
#define ENOPATH  3      /* Path not found           */
#define ECONTR   7      /* Memory blocks destroyed  */
#define EINVMEM  9      /* Invalid memory block address */
#define EINVENV 10      /* Invalid environment      */
#define EINVFMT 11      /* Invalid format           */
#define EINVACC 12      /* Invalid access code      */
#define EINVDAT 13      /* Invalid data             */
#define EINVDRV 15      /* Invalid drive specified  */
#define ECURDIR 16      /* Attempt to remove CurDir */
#define ENOTSAM 17      /* Not same device          */
#define ENMFILE 18      /* No more files            */

#define ENOENT   2      /* No such file or directory*/
#define EMFILE   4      /* Too many open files      */
#define EACCES   5      /* Permission denied        */
#define EBADF    6      /* Bad file number          */
#define ENOMEM   8      /* Not enough core          */
#define EFAULT  14      /* Unknown error            */
#define ENODEV  15      /* No such device           */
#define EINVAL  19      /* Invalid argument         */
#define E2BIG   20      /* Arg list too long        */
#define ENOEXEC 21      /* Exec format error        */
#define EXDEV   22      /* Cross-device link        */
#define ENFILE  23      /* UNIX - not MSDOS         */
#define ECHILD  24      /* Unix/DOS                 */
#define ENOTTY  25      /* UNIX - not MSDOS         */
#define ETXTBSY 26      /* UNIX - not MSDOS         */
#define EFBIG   27      /* UNIX - not MSDOS         */
#define ENOSPC  28      /* UNIX - not MSDOS         */
#define ESPIPE  29      /* UNIX - not MSDOS         */
#define EROFS   30      /* UNIX - not MSDOS         */
#define EMLINK  31      /* UNIX - not MSDOS         */
#define EPIPE   32      /* UNIX - not MSDOS         */
#define EDOM    33      /* Math argument            */
#define ERANGE  34      /* Result too large         */
#define EEXIST  35      /* File already exists      */
#define EDEADLOCK 36    /* Locking violation        */
#define EPERM   37      /* UNIX - not MSDOS         */
#define ESRCH   38      /* UNIX - not MSDOS         */
#define EINTR   39      /* UNIX - not MSDOS         */
#define EIO     40      /* UNIX - not MSDOS         */
#define ENXIO   41      /* UNIX - not MSDOS         */
#define EAGAIN  42      /* UNIX - not MSDOS         */
#define ENOTBLK 43      /* UNIX - not MSDOS         */
#define EBUSY   44      /* UNIX - not MSDOS         */
#define ENOTDIR 45      /* UNIX - not MSDOS         */
#define EISDIR  46      /* UNIX - not MSDOS         */
#define EUCLEAN 47      /* UNIX - not MSDOS         */

#if !defined( _RTLDLL )
extern  int _Cdecl  errno;
extern  int _Cdecl  _doserrno;
#else

#ifdef __cplusplus
extern "C" {
#endif
int far * far _Cdecl __getErrno(void);
int far * far _Cdecl __getDOSErrno(void);
#ifdef __cplusplus
}
#endif
#define errno (*__getErrno())

#if !defined(__STDC__)
    #define _doserrno (*__getDOSErrno())
#endif

#endif

#if !__STDC__
#define _sys_nerr   48      /* highest defined system error number + 1 */
#endif

#endif
pkBGI Device Driver (CGA) 2.00 - Mar 21 1988
Copyright (c) 1987,1988 Borland International
                              CGA                  U ]CB      s S[o      "''SA  4   r _                Ø         .>z u ˸ ˴$.~ &CC&CC5z<s
2"t}2"y@uÀu>z tÀ> u>0&?<u &GC>Ë&؋ 	
<t  >z u N                               ? ? (#X   ? ? (#X     (#XG  (#X' 320 x 200 CGA C0   320 x 200 CGA C1   320 x 200 CGA C2   320 x 200 CGA C3   640 x 200 CGA      640 x 480 MCGA     <u<u2Ê2@2<s<r,Ȣ{z<sz 2~ &$> u{ <r<t#663ɶO22ø  K3À>z t3"t"tÉ|ó:v:vã|ãQRȋӇ ZYË6|>(    z}<rU,2
>z t   >}  Ъ ª2ҳs
uÀ>z t"t <t3ۃ3
                  >uK&"t*SQ5Y[>uKC"x-&  SQ|Y[ x<t
2؋                       ? (  =? (  A (  gP  m[Z  P  s]Z  y<r
؁GGGW2P Xش>t2$ø ø ø@ 0  33 @5-.[WW  3۹ PSQ؎ 2BJY3X󫺸X
@ ûe &"(6Vp4t  Á4tðÁ  ..+    QuZS$
2..[YQɀuZ    QuPS$
2.h[YQɀuP;w;w;w;vËv>;rډF^F ;rF쀑+F+ډ^/F^;rF^+؉^+؉^  ^F+ÉF+ÉF  ^V~vF$>{s$
F>z t@>~ t fnnEs t&0'
&"
&S{2"yCC[Muƀu֨@uŀuCs t&0'
&"
&Muƀu֨@uŀuCs t&0'
&"
&뽋NV{<s <rꡳр>z t"Ŋfz"uu{fv<sF t  ^<r^㎇.<uh     &&0
&  "&"
&;r;rڋ>z u+BS2÷ދ+â>z t@[PVQS ^[ .>z u.+
[ .#
].PSUW.>z t.uV/ ^ .>z t ;r_][X.uSM#t.GMu.>z t."*.>z u:Z}
.Gĳ".Ã.>z u? U2BW{<s <rꡳ؋ֹ?&z"t""uȆ[&{s
t  Àr㎇.uh                  @8px<iZ-KB$$B3333     "  "                          &%䀈& $"uÈ!"u"- &- (;|>+>&;s;|>+>(;sSQ _^.$.."PS&V  .! Ou[8 XuE.$uu7"
7.>z u"xCu.#.>{s
..#..#<0uO2<Ar<{r2<r#  |  &&Wt n 
>% tA&F &^&N&V* ֖Muڽ*|#|>z t"t3
"8l  ||    |~  x00000x |     ||  || x`0x 000000 | l8  l8l f< 0` <00000< `0 <<  8l           00       |~~    |~ ~v   |~ 0|0000   ~v|  8<  8 8<         ||     ~v  np```   || 00|000   ~   l8   l   l8l   v|  0` % 2QSQذaY^VQWS:X [SP.2>f "uE&'.[_GYXX                                                                ++BRQST_[u.>z t.+
.TPRV+ ^ZX.>{r...Ruԋìଊ#t	&%GJ"&%G   	&0&
& "&"
&+BRS2ދ+â>z t@[PVQST^[ .>z u.+
[ .#
Z.TPSRW _Z[X..RuSJ2#t.G嬊J.>z t."*.>z u:Z}.G2".Ã.>z uUUxg\(W22Ã>z t2拄&"
&Ëڋǃ玅hP ڋǃ玅.Z 拄&"
&øZ P RZ 拄&"
&p ΃A&$Ëǃ玅hP ǃ玅.Z ΀&$øZ P RZ R蜿P s  Ztr>z trBC&.J  ރ3
>z t"tRMMF +MMF 6:  >MMv F MM~ Zk&"":t2%[62:0>N EEu
&.JË~ EEv EE^ EE"SP$x Xtu>F u s5 % r+ ; 떡6@;u:H92~>@90á6H;t2;*s"F4;(t 02&-;6tN>z utOG&-"":t8""
;6t&N>z ut&-OG&-t& &-Fɀ>z utGG&-62àE&-:u&;6$|+6,OGa&-"":t8""
;6}&Fɀ>z ut&-GG&-t &-N60E&-:u&;6&s6,GGÀFɀ>z utGG &"":u^>Bu
&Gt>C t:Du
Ft
? u)":t!urMM^ MMv MM~ MMN ;60snJ&:u&0+,&:u;6,GG&"":t!0+,Q.E&:-u;s6,GGYÉ6KM>OQ
 &GHËÊBt3
؀>z t"tGPR% >z uZЀ>z t u&G[Ë6KM>OQH&G&>z uE2ƴtsE "t"uEÀuSQP2
C"u2XY[mP, >z t, ,$+,@&+(+*XEUEUEUejotPS2 G"[XKu  ÁCuǰÁ  KPCPKZCZà<r$<s SӃ<t4KSӃuZ..[CSӃuZKSӃuP.h[CSӃuP? ?@??  0    @       /*  ctype.h

    Defines the ctype macros.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __CTYPE_H
#define __CTYPE_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#define _IS_SP  1           /* is space */
#define _IS_DIG 2           /* is digit indicator */
#define _IS_UPP 4           /* is upper case */
#define _IS_LOW 8           /* is lower case */
#define _IS_HEX 16          /* [0..9] or [A-F] or [a-f] */
#define _IS_CTL 32          /* Control */
#define _IS_PUN 64          /* punctuation */

extern  char _Cdecl _ctype[];    /* Character type array */

#ifdef __cplusplus
extern "C" {
#endif
int _Cdecl isalnum (int __c);
int _Cdecl isalpha (int __c);
int _Cdecl isascii (int __c);
int _Cdecl iscntrl (int __c);
int _Cdecl isdigit (int __c);
int _Cdecl isgraph (int __c);
int _Cdecl islower (int __c);
int _Cdecl isprint (int __c);
int _Cdecl ispunct (int __c);
int _Cdecl isspace (int __c);
int _Cdecl isupper (int __c);
int _Cdecl isxdigit(int __c);
#ifdef __cplusplus
}
#endif

#define isalnum(c)  (_ctype[(c) + 1] & (_IS_DIG | _IS_UPP | _IS_LOW))
#define isalpha(c)  (_ctype[(c) + 1] & (_IS_UPP | _IS_LOW))
#define isascii(c)  ((unsigned)(c) < 128)
#define iscntrl(c)  (_ctype[(c) + 1] & _IS_CTL)
#define isdigit(c)  (_ctype[(c) + 1] & _IS_DIG)
#define isgraph(c)  ((c) >= 0x21 && (c) <= 0x7e)
#define islower(c)  (_ctype[(c) + 1] & _IS_LOW)
#define isprint(c)  ((c) >= 0x20 && (c) <= 0x7e)
#define ispunct(c)  (_ctype[(c) + 1] & _IS_PUN)
#define isspace(c)  (_ctype[(c) + 1] & _IS_SP)
#define isupper(c)  (_ctype[(c) + 1] & _IS_UPP)
#define isxdigit(c) (_ctype[(c) + 1] & (_IS_DIG | _IS_HEX))

#define toascii(c)  ((c) & 0x7f)

#if !__STDC__
#define _toupper(c) ((c) + 'A' - 'a')
#define _tolower(c) ((c) + 'a' - 'A')
#endif

#ifdef __cplusplus
extern "C" {
#endif
int _CType tolower(int __ch);
int _CType _ftolower(int __ch);
int _CType toupper(int __ch);
int _CType _ftoupper(int __ch);
#ifdef __cplusplus
}
#endif

#endif
 SETUP_AT.CPPЈ   TC86 Borland C++ 3.1   w  `m?SETUP_AT.CPPވ"  @C:\BORLANDC\BIN\IOSTREAM.H  @C:\BORLANDC\BIN\_DEFS.Hx  @C:\BORLANDC\BIN\MEM.H  @C:\BORLANDC\BIN\_NULL.H_!  @C:\BORLANDC\BIN\FSTREAM.H  @C:\BORLANDC\BIN\CONIO.H"  @C:\BORLANDC\BIN\GRAPHICS.H   @C:\BORLANDC\BIN\STDLIB.H5       c  g opt_2 c_sel c_nsel c_2_2 c_2_1 bkg gmode gdriver i  ׈  ׈     =    ˈ  @ostream@$blsh$qpxzc
    =
    S  _s
  this    Ĉ  this _s
     q   q          ʈ)  %@ostream@$blsh$qpqr7ostream$r7ostream
    4     #  ,
    9  _f
  this    È  this _f
     {   {          Ɉ  @ostream@$blsh$qi  _i
  this      this _i
     s   s            w  錈  	{(  _TEXTCODE_DATADATA_BSSBSSDGROUPј (~ HJ H   @ostream@$blsh$qpxzc e* %@ostream@$blsh$qpqr7ostream$r7ostream Ű @ostream@$blsh$qi ɚ U _setbkcolor Ĉ     # C   t 
_initgraph 8      # B    s _cleardevice   !   # A  ! r	 _getch   "   #  A  " q @ofstream@$bdtr$qv   $ios" .È
       |  %io_state "  ?  '	open_mode "  D2  )seek_dir "  L
  +  $!%  ,   -+ $ @ios@$bctr$qp9streambuf  .   - $ @ios@$bdtr$qvF  0   - 	$   2   - $ @ios@flags$ql
  4   - $ @ios@setf$qll  6   - $ @ios@setf$qlc  8   - $ @ios@unsetf$qlz  :   - 	$   <   - 	$   >   - 	$   @   - 	$   B   - 	$   D   - 	$ !  F   - $ @ios@tie$qp7ostreaml  H   - 	$ ͈  J   - 	$   L   - 	$ ވ  N   - 	$ ܈  P   - 	$ ڈ  R   - 	$ ؈  T   - $ @ios@clear$qi
  V    W   -V 	$   Y   - $ ͈  \	streambuf .
     O  -!  ]   -[ \ @streambuf@$bctr$qv$  _   -[ \ @streambuf@$bctr$qpzci!  a   - \ @streambuf@$bdtr$qvQ%  c   -[ \@streambuf@setbuf$qpzci  e   -[ 	\ 6&  g   -[ \ @streambuf@setbuf$qpzcii  i   - 	\   k   - 	\   m   - 	\   o   - 	\ $  q   - \ @streambuf@sgetn$qpzci'  s   - \@streambuf@do_sgetn$qpzcik%  u   - \@streambuf@underflow$qv)  w   - 	\ {%  y   - \@streambuf@pbackfail$qij  {   - 	\ w  }   - 	\ u%     - \ @streambuf@sputn$qpxzci)  、   - \@streambuf@do_sputn$qpxzciF%  〃   - \@streambuf@overflow$qi  々   - 	\ .  〇   - \@streambuf@seekoff$ql8seek_diri%  〉   - \@streambuf@seekpos$qli!  》   - \	@streambuf@sync$qv   」   - \ @streambuf@dbp$qvB  』  ^  【   - 	\ Ո  〒   - 	\ ӈ  〔   - 	\ ݈  〖   - 	\ ψ  〘   - 	\ ͈  〚   - 	\ ˈ  〜   - 	\ Ɉ  〞   - 	\ ǈ  〠   - 	\ ň%  〢   - \ @streambuf@setp$qpzct1!'  〤   - \ @streambuf@setg$qpzct1t1  〦   - 	\ Έ  〨   - 	\ ̈&  〪   - \ @streambuf@setb$qpzct1i  〬   - 	\ Ȉ  〮   - 	\ È  〰   - 	\ '  〲   - \
@streambuf@doallocate$qv &  〴   - \ @streambuf@do_snextc$qv{,  〶   -[ \ @streambuf@$bctr$qr9streambuf,  〸   - \ @streambuf@$basg$qr9streambufr
  [  \  〺   -[ 	$   〼   - $ @ios@bitalloc$qv  〾   - $ @ios@xalloc$qv}    4
     - $ @ios@iword$qi    4V     - $ @ios@pword$qi&     - $ @ios@sync_with_stdio$qv     - $ @ios@skip$qiP     -+ $ @ios@$bctr$qv %     - $ @ios@init$qp9streambuf5     - $ @ios@setstate$qi     #      ψ         - $ @ios@usersize$qi}      -+ $ @ios@$bctr$qr3ioss      - $ @ios@$basg$qr3ios  #fstreambaseJ .K         #%     - # @fstreambase@$bctr$qvp*     - # @fstreambase@$bctr$qpxzciiC%     - # @fstreambase@$bctr$qiy)     - # @fstreambase@$bctr$qipzci$     - # @fstreambase@$bdtr$qv(     - # @fstreambase@open$qpxzcii%     - # @fstreambase@attach$qi"$     - # @fstreambase@close$qvt(     - # @fstreambase@setbuf$qpzci  filebuf$ .ۈ       ["     -  @filebuf@$bctr$qv"     -  @filebuf@$bctr$qi&     -  @filebuf@$bctr$qipzci&     -  @filebuf@$bctr$qipuci!     -  @filebuf@$bdtr$qv     - 	 g     - 	 e&     -  @filebuf@open$qpxzcii     - 	 "      -  @filebuf@close$qv\#     -  @filebuf@attach$qi$     - @filebuf@overflow$qid%     - @filebuf@underflow$qv      - 	@filebuf@sync$qv-  
   - @filebuf@seekoff$ql8seek_diri%     -[ @filebuf@setbuf$qpzci#     -  @filebuf@last_op$qv׈
    ܈         - 	# /%     - # @fstreambase@verify$qiԈ  ostream& .     Ĉ*     -  @ostream@$bctr$qp9streambuf      -  @ostream@$bdtr$qv-      -  @ostream@$bctr$qi!#     -  @ostream@$bctr$qipzc̈     - 	      - 	    !   -  @ostream@flush$qv   #   -  @ostream@seekp$qlƈ)  %   -  @ostream@seekp$ql8seek_dir4   '   -  @ostream@tellp$qvǈ  )   - 	 o$  +   -  @ostream@write$qpxzci  -   - 	 k!  /   -  @ostream@$blsh$qzc  1   -  c  3   -  a  5   -  _   7   -  @ostream@$blsh$qi  9   -  [   ;   -  @ostream@$blsh$ql!  =   -  @ostream@$blsh$qul|  ?   -  U  A   -  S   C   -  @ostream@$blsh$qg#  E   -  @ostream@$blsh$qpxzc  G   -  M!  I   -  @ostream@$blsh$qpvk*  K   -  @ostream@$blsh$qp9streambufˈ4  M   -  %@ostream@$blsh$qpqr7ostream$r7ostream؈,  O   -  @ostream@$blsh$qpqr3ios$r3iosP"  Q   -  @ostream@do_opfx$qv͈"  S   -  @ostream@do_osfx$qvˈ   U   -  @ostream@$bctr$qv؈&  W   -  @ostream@outstr$qpxzct1  ofstreamN .         Y  }"  Z   -Y  @ofstream@$bctr$qv'  \   -Y  @ofstream@$bctr$qpxzcii~'  ^   -Y  @ofstream@$bctr$qpxucii"  `   -Y  @ofstream@$bctr$qi&  b   -Y  @ofstream@$bctr$qipzci&  d   -Y  @ofstream@$bctr$qipuci!  f   -  @ofstream@$bdtr$qvx  h   - 	   j   - 	 M  l   - 	 K  f  @ofstream@$bctr$qpxzcii g  \  @filebuf@openprot {    @endl$qr7ostream 5  n   #  Y  n  _cout M  oostream_withassign& .        p  o-  q   -p o @ostream_withassign@$bctr$qvV,  s   - o @ostream_withassign@$bdtr$qvD  u  4oi5  v   -u o $@ostream_withassign@$basg$qr7ostream7  x   -u o &@ostream_withassign@$basg$qp9streambufD  o  _cin Ј  {istream( .	-   	    |  {u,  }   -| { @istream@$bctr$qp9streambufވ!     - { @istream@$bdtr$qv6  ぁ   -| { %@istream@$bctr$qp9streambufip7ostream&  ぃ   -| { @istream@$bctr$qipzci7,  ぅ   -| { @istream@$bctr$qiip7ostreamԈ   ぇ   - { @istream@ipfx$qi  ぉ   - 	{ F  か   - 	{ D  き   - 	{ E  く  4{C"  ぐ   - { @istream@seekg$ql+  げ   - { @istream@seekg$ql8seek_dir !  ご   - { @istream@tellg$qv  ざ   - 	{ 9%  じ   - { @istream@get$qpzcizc,  ず   - 	{ ($  ぜ   - { @istream@read$qpzci  ぞ   - 	{ $)  だ   - { @istream@getline$qpzcizct  ぢ   - 	{  ,  つ   - { @istream@get$qr9streambufzcT"  て   - { @istream@get$qrucm"  と   - { @istream@get$qrzcf  な   - { @istream@get$qvN  ぬ   - 	{ #  の   - 	{ !%  ば   - { @istream@putback$qzc $  ひ   - { @istream@ignore$qii  ぴ   - { 
.  ぶ   - { @istream@$brsh$qpqr3ios$r3ios$  へ   - { @istream@$brsh$qpzc  ぺ   - { $  ぼ   - { @istream@$brsh$qruc$  ま   - { @istream@$brsh$qrzc#     - { @istream@$brsh$qrs#     - { @istream@$brsh$qri'#     - { @istream@$brsh$qrl"$     - { @istream@$brsh$qrus$     - { @istream@$brsh$qrui$     - { @istream@$brsh$qrul#     - { @istream@$brsh$qrf #     - { @istream@$brsh$qrd #     - { @istream@$brsh$qrg,     - { @istream@$brsh$qp9streambufn"     -| { @istream@$bctr$qv$     - { @istream@eatwhite$qv "     - { @istream@do_get$qv  zistream_withassign( .y     	 Ԉ    z-     - z @istream_withassign@$bctr$qv},     - z @istream_withassign@$bdtr$qvՈ    4z5     - z $@istream_withassign@$basg$qr7istreamE7     - z &@istream_withassign@$basg$qp9streambufk  z  @ostream@outstr$qpxzct1   W -  %@ostream@$blsh$qpqr7ostream$r7ostreamM *  @ostream@$blsh$qpxzcE ܌ @ostream@$blsh$ql   ; ֈ  @ostream@$blsh$qi7 L @istream@$brsh$qri    O  _main   Z     #          #       #       #       #       #       #       #       #    iostream, .A     	  ǈ    -     -  @iostream@$bctr$qp9streambuf"     -  @iostream@$bdtr$qv#     -  @iostream@$bctr$qv  fstreamT .
   
    "     -  @fstream@$bctr$qv'     -  @fstream@$bctr$qpxzciic'     -  @fstream@$bctr$qpxuciif"     -  @fstream@$bctr$qi&      -  @fstream@$bctr$qipzciֈ         #       #       #       #  s     #  ވ  ifstreamP .    )  	 #  	   -  @ifstream@$bctr$qv߈(     -  @ifstream@$bctr$qpxzcii(     -  @ifstream@$bctr$qpxucii#     -  @ifstream@$bctr$qi'     -  @ifstream@$bctr$qipzci&    [     #  T  iostream_withassign, .c    4      ?.     -  @iostream_withassign@$bctr$qv-     -  @iostream_withassign@$bdtr$qv2     -  !@iostream_withassign@$basg$qr3ios|    4"     #  :> wchar_t Pfstream 	PofstreamY 	Pifstream Pfstreambase Pfilebuf Riostream_withassign Piostream_withassign Rostream_withassignu Postream_withassignp Ristream_withassign Pistream_withassign 	Piostream Rostream Postream Ristream Pistream| 
Pstreambuf[ Pios+ 	streamoff 	streampos size_t
 	ptrdiff_t fstream ofstream ifstream fstreambase# filebuf ios_user_union iostream_withassign ostream_withassigno istream_withassignz iostream ostream istream{ 	streambuf\ ios$ 戽 pio_state%p	open_mode'pseek_dir)`@ios@basefield`@ios@adjustfield`@ios@floatfieldJ@ios@$bctr$qp9streambuf,M@ios@$bdtr$qv.H@ios@flags$qv0H@ios@flags$ql2H@ios@setf$qll4H@ios@setf$ql6H@ios@unsetf$ql8H@ios@width$qv:H@ios@width$qi<H@ios@fill$qv>H@ios@fill$qzc@H@ios@precision$qiBH@ios@precision$qvDH@ios@tie$qp7ostreamFH@ios@tie$qvHH@ios@rdstate$qvJH@ios@eof$qvLH@ios@fail$qvNH@ios@bad$qvPH@ios@good$qvRH@ios@clear$qiTK@ios@$opv$qvWH@ios@$bnot$qvYH@ios@rdbuf$qvH@ios@bitalloc$qvH@ios@xalloc$qvH@ios@iword$qiH@ios@pword$qiH@ios@sync_with_stdio$qvH@ios@skip$qi@    bp[ x_tie state ispecial ospecial x_flags x_precision x_width x_fill isfx_special osfx_special delbuf assign_privateJ@ios@$bctr$qvH@ios@init$qp9streambufH@ios@setstate$qi`@ios@stdioflush`@ios@nextbit`@ios@usercount 	userwords nwordsH@ios@usersize$qiJ@ios@$bctr$qr3iosH@ios@$basg$qr3ios"   R   @ios@goodbit   @ios@eofbit  @ios@failbit  @ios@badbit @ios@hardfail ,r   @ios@in  @ios@out  @ios@ate  @ios@app  
@ios@trunc  @ios@nocreate   @ios@noreplace@ @ios@binary '   @ios@beg   @ios@cur @ios@end  J@streambuf@$bctr$qv]J@streambuf@$bctr$qpzci_M@streambuf@$bdtr$qvaL@streambuf@setbuf$qpzcicH@streambuf@setbuf$qpucieH@streambuf@setbuf$qpzciigH@streambuf@sgetc$qviH@streambuf@snextc$qvkH@streambuf@sbumpc$qvmH@streambuf@stossc$qvoH@streambuf@sgetn$qpzciqL@streambuf@do_sgetn$qpzcisL@streambuf@underflow$qvuH@streambuf@sputbackc$qzcwL@streambuf@pbackfail$qiyH@streambuf@in_avail$qv{H@streambuf@sputc$qi}H@streambuf@sputn$qpxzciL@streambuf@do_sputn$qpxzciL@streambuf@overflow$qiH@streambuf@out_waiting$qvL@streambuf@seekoff$ql8seek_diriL@streambuf@seekpos$qliL@streambuf@sync$qvH@streambuf@dbp$qvH@streambuf@base$qvH@streambuf@ebuf$qvH@streambuf@blen$qvH@streambuf@pbase$qvH@streambuf@pptr$qvH@streambuf@epptr$qvH@streambuf@eback$qvH@streambuf@gptr$qvH@streambuf@egptr$qvH@streambuf@setp$qpzct1H@streambuf@setg$qpzct1t1H@streambuf@pbump$qiH@streambuf@gbump$qiH@streambuf@setb$qpzct1iH@streambuf@unbuffered$qiH@streambuf@unbuffered$qvH@streambuf@allocate$qvL@streambuf@doallocate$qv@    alloc_ unbuf_ base_ ebuf_ pbase_ pptr_ epptr_ eback_ gptr_ egptr_H@streambuf@do_snextc$qvJ@streambuf@$bctr$qr9streambufH@streambuf@$basg$qr9streambuf   : J@fstreambase@$bctr$qvJ@fstreambase@$bctr$qpxzciiJ@fstreambase@$bctr$qiJ@fstreambase@$bctr$qipzciM@fstreambase@$bdtr$qvH@fstreambase@open$qpxzciiH@fstreambase@attach$qiH@fstreambase@close$qvH@fstreambase@setbuf$qpzciH@fstreambase@rdbuf$qvH@fstreambase@verify$qi@    bufJ   # `@filebuf@openprotJ@filebuf@$bctr$qvJ@filebuf@$bctr$qiJ@filebuf@$bctr$qipzciJ@filebuf@$bctr$qipuciM@filebuf@$bdtr$qvH@filebuf@is_open$qvH@filebuf@fd$qvH@filebuf@open$qpxzciiH@filebuf@open$qpxuciiH@filebuf@close$qv H@filebuf@attach$qiL@filebuf@overflow$qiL@filebuf@underflow$qvL@filebuf@sync$qvL@filebuf@seekoff$ql8seek_diri
L@filebuf@setbuf$qpzci@    xfd mode opened 	last_seek in_startH@filebuf@last_op$qv lahead$   _- J@ostream@$bctr$qp9streambufM@ostream@$bdtr$qvJ@ostream@$bctr$qiJ@ostream@$bctr$qipzcH@ostream@opfx$qvH@ostream@osfx$qvH@ostream@flush$qv!H@ostream@seekp$ql#H@ostream@seekp$ql8seek_dir%H@ostream@tellp$qv'H@ostream@put$qzc)H@ostream@write$qpxzci+H@ostream@write$qpxuci-H@ostream@$blsh$qzc/H@ostream@$blsh$quc1H@ostream@$blsh$qs3H@ostream@$blsh$qus5H@ostream@$blsh$qi7H@ostream@$blsh$qui9H@ostream@$blsh$ql;H@ostream@$blsh$qul=H@ostream@$blsh$qf?H@ostream@$blsh$qdAH@ostream@$blsh$qgCH@ostream@$blsh$qpxzcEH@ostream@$blsh$qpxucGH@ostream@$blsh$qpvIH@ostream@$blsh$qp9streambufKH%@ostream@$blsh$qpqr7ostream$r7ostreamMH@ostream@$blsh$qpqr3ios$r3iosOH@ostream@do_opfx$qvQH@ostream@do_osfx$qvSJ@ostream@$bctr$qvUH@ostream@outstr$qpxzct1W&     J@ofstream@$bctr$qvZJ@ofstream@$bctr$qpxzcii\J@ofstream@$bctr$qpxucii^J@ofstream@$bctr$qi`J@ofstream@$bctr$qipzcibJ@ofstream@$bctr$qipucidM@ofstream@$bdtr$qvfH@ofstream@rdbuf$qvhH@ofstream@open$qpxzciijH@ofstream@open$qpxuciilN     J@ostream_withassign@$bctr$qvqM@ostream_withassign@$bdtr$qvsH$@ostream_withassign@$basg$qr7ostreamvH&@ostream_withassign@$basg$qp9streambufx&   v J@istream@$bctr$qp9streambuf}M@istream@$bdtr$qvJ%@istream@$bctr$qp9streambufip7ostreamJ@istream@$bctr$qipzciJ@istream@$bctr$qiip7ostreamH@istream@ipfx$qiH@istream@ipfx0$qvH@istream@ipfx1$qvH@istream@isfx$qvH@istream@seekg$qlH@istream@seekg$ql8seek_dirH@istream@tellg$qvH@istream@sync$qvH@istream@get$qpzcizcH@istream@get$qpucizcH@istream@read$qpzciH@istream@read$qpuciH@istream@getline$qpzcizcH@istream@getline$qpucizcH@istream@get$qr9streambufzcH@istream@get$qrucH@istream@get$qrzcH@istream@get$qvH@istream@peek$qvH@istream@gcount$qvH@istream@putback$qzcH@istream@ignore$qiiH%@istream@$brsh$qpqr7istream$r7istreamH@istream@$brsh$qpqr3ios$r3iosH@istream@$brsh$qpzcH@istream@$brsh$qpucH@istream@$brsh$qrucH@istream@$brsh$qrzcH@istream@$brsh$qrsH@istream@$brsh$qriH@istream@$brsh$qrlH@istream@$brsh$qrusH@istream@$brsh$qruiH@istream@$brsh$qrulH@istream@$brsh$qrfH@istream@$brsh$qrdH@istream@$brsh$qrgH@istream@$brsh$qp9streambufJ@istream@$bctr$qvH@istream@eatwhite$qv@    gcount_H@istream@do_get$qv(   |  J@istream_withassign@$bctr$qvM@istream_withassign@$bdtr$qvH$@istream_withassign@$basg$qr7istreamH&@istream_withassign@$basg$qp9streambuf(   (T  J@iostream@$bctr$qp9streambufM@iostream@$bdtr$qvJ@iostream@$bctr$qv,     J@fstream@$bctr$qvJ@fstream@$bctr$qpxzciiJ@fstream@$bctr$qpxuciiJ@fstream@$bctr$qiJ@fstream@$bctr$qipzci J@fstream@$bctr$qipuciM@fstream@$bdtr$qvH@fstream@rdbuf$qvH@fstream@open$qpxzciiH@fstream@open$qpxuciiT     J@ifstream@$bctr$qv	J@ifstream@$bctr$qpxzciiJ@ifstream@$bctr$qpxuciiJ@ifstream@$bctr$qiJ@ifstream@$bctr$qipzciJ@ifstream@$bctr$qipuciM@ifstream@$bdtr$qvH@ifstream@rdbuf$qvH@ifstream@open$qpxzciiH@ifstream@open$qpxuciiP     J@iostream_withassign@$bctr$qvM@iostream_withassign@$bdtr$qvH!@iostream_withassign@$basg$qr3iosH'@iostream_withassign@$basg$qp9streambuf,   .  U^F    PFPFP     P    Y  P P  P  YYP  YY  PC P  P  YYP  YY  P P  P  YYP  YY  P P  P  YYP  YY  P	P  P  YYP  YY  PKP  P  YYP  YY  PP  P  YYP  YY  PP  P  YYP  YY  PP  P  YYP  YY  PIP  P  YYP  YY  PP  P  YYP  YY  PP  P  YYP  YY  PP  P  YYP  YY  PQP  P  YYP  YY  PP  P  YYP  YY  PP  P  YYP  YY  PP  P  YYP  YY  PYP  P  YYP  YY  PP  P  YYP  YYF F F F	 F 6   PP3PFP  
P  P  YYFP  P  YYP  P  YYFP  P  YY:P  P  YYFP  P  YYeP  P  YYFP  P  YYP  P  YYFP  P  YYP  P  YYFP  P  YY~uF F F F	 F vPvPv
PvPvFP  YYP  YYP  YYP  YYP  YYP  YYP  YYP  YYP  YYvPvPvPvPvP  P  YYP  YYP  YYP  YYP  YYP  YYP  YYP  YYP  YYP  YYP  P  YY       PFP  YY3 ]< VϙVVTǍǉT~TxTrTlTfT`TZTTTNTJF?81*"TTTT
TTTTTVƧTƚƖVƍTƀ|wVsjTfb]VYPTLHCV?6T2.)V%TV	
TTVTTżŸŴVTTťšŝVTTŎŊņVT{TwsoVjTdT`\XVSTMTIEAV<T6T2.*V%TTVTT VTTVTTVTTĿĻķVTTĨĤĠVTTđčĉVT~TzvrVmTgTc_[VVTPTLHDV?T9T51-V'VVs   ***************************************************************** ***         CIRCLE TOUCH   - SETUP          ***      COLORS     * ***    Created by Ionica Bizau              ***  0 - BLACK      * ***                 2011                    ***  1 - BLUE       * ***********************************************  2 - GREEN      * *   1.Background                              *  3 - CYAN 	* *   2.Circle color 2-1                        *  4 - RED  	* *   3.Circle color 2-2                        *  5 - MAGNETA    * *   4.     Unselected menu option color       *  6 - BROWN      * *   5.     Selected menu option color         *  7 - LIGHTGRAY  * *   6.Reset settings                          *  8 - DARKGRAY   * *                                             *  9 - LIGHTBLUE  * *                                             *  10 - LIGHTGREEN* *                                             *  11 - LIGHTCYAN * *                                             *  12 - LIGHTRED  * *                                          'N    *  13 - LIGHTMAGN.* *                                             *  14 - YELLOW    * *                                             *  15 - WHITE     * ***************************************************************** OUT.TXT     Enter the background color (0-15):     Enter the untouched circle color (0-15):     Enter the touched circle color (0-15):           Enter the unselected menu options' color (0-15):          Enter the selected menu option color (0-15):  Daca vrei sa revii la setarile initiala apasa 1:          
         
        Settings were saved successfully. Bye!     UVv3PvV   ^]U Vh   UVvVVY ^]   UVvFRPV   ^]R Vg  SETUP_AT.CPP`m?݈       	  
   "  ,  C  Z  q               ) @ W n    ! # % &  ( -) :+ G, T. a/ n1 {2 4 5 6 8 9 : ; < = @ A &B C D G H #  C:\BORLANDC\BIN\IOSTREAM.H@  [  \ ] ^     o  p     g  h Ê  t/*  mem.h

    Memory manipulation functions

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__MEM_H)
#define __MEM_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef NULL
#include <_null.h>
#endif

#ifndef _STDDEF
#define _STDDEF
#ifndef _PTRDIFF_T
#define _PTRDIFF_T
#if defined(__LARGE__) || defined(__HUGE__) || defined(__COMPACT__)
typedef long    ptrdiff_t;
#else
typedef int ptrdiff_t;
#endif
#endif
#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif
void _FAR * _FARFUNC _Cdecl memccpy(void _FAR *__dest, const void _FAR *__src,
                           int __c, size_t __n);
void _FAR * _FARFUNC _Cdecl memchr(const void _FAR *__s, int __c, size_t __n);
int         _FARFUNC _Cdecl memcmp(const void _FAR *__s1, const void _FAR *__s2,
                          size_t __n);
void _FAR * _FARFUNC _Cdecl memcpy(void _FAR *__dest, const void _FAR *__src,
                          size_t __n);
int         _FARFUNC _Cdecl memicmp(const void _FAR *__s1, const void _FAR *__s2,
                          size_t __n);
void _FAR * _CType _FARFUNC memmove(void _FAR *__dest, const void _FAR *__src,
                          size_t __n);
void _FAR * _CType _FARFUNC memset(void _FAR *__s, int __c, size_t __n);
void        _FARFUNC _Cdecl movedata(unsigned __srcseg, unsigned __srcoff,
                            unsigned __dstseg,unsigned __dstoff, size_t __n);
void        _FARFUNC _Cdecl movmem(const void _FAR *__src, void _FAR *__dest,
                          unsigned __length);
void        _FARFUNC _Cdecl setmem(void _FAR *__dest,unsigned __length, char __value);

#if !__STDC__
void  far * _FARCALL cdecl _fmemccpy(void far *__dest, const void far *__src,
                       int __c, size_t __n);
void  far * _FARCALL cdecl _fmemchr(const void far *__s, int __c, size_t __n);
int         _FARCALL cdecl _fmemcmp(const void far *__s1, const void far *__s2,
                       size_t __n);
void  far * _FARCALL cdecl _fmemcpy(void far *__dest, const void far *__src,
                       size_t __n);
int         _FARCALL cdecl _fmemicmp(const void far *__s1, const void far *__s2,
                       size_t __n);
void  far * _FARCALL cdecl _fmemmove(void far *__dest, const void far *__src,
                       size_t __n);
void  far * _FARCALL cdecl _fmemset(void far *__s, int __c, size_t __n);
void        _FARCALL cdecl _fmovmem(const void far *__src, void far *__dest,
                       unsigned __length);
void        _FARCALL cdecl _fsetmem(void far *__dest, unsigned __length,
                       char __value);
#endif

#if !defined(__STRING_H)
/* Intrinsic functions */

void _FAR * _Cdecl _FARFUNC __memchr__  (const void _FAR *__s, int __c, size_t __n);
int         _Cdecl _FARFUNC __memcmp__(const void _FAR *__s1,
                          const void _FAR *__s2, size_t __n);
void _FAR * _Cdecl _FARFUNC __memcpy__(void _FAR *__dest, const void _FAR *__src,
                          size_t __n);
void _FAR * _CType _FARFUNC __memset__(void _FAR *__s, int __c, size_t __n);
#endif
#ifdef __cplusplus
}
#endif

#endif  /* __MEM_H */

pkBGI Device Driver (ATT) 2.00 - Mar 21 1988
Copyright (c) 1987,1988 Borland International
                            ATT                  U ]CB      s Yau      "-'YA  4   r _                Ø         .>z u ˸ ˴$.~ &CC&CC5<s
2"t}2"y@uÀu>z tÀ> u>0&?<u &GCDË&؋ 	
<t  >z u N                               ? ? (#X   ? ? (#X     (#XG  (#X." 320 x 200 CGA P0   320 x 200 CGA P1   320 x 200 CGA P2   320 x 200 CGA P3   640 x 200 CGA      640 x 400 AT&T     <u<u2Ê2@2<s<r,<u{z<sz 2~ &$> u{<r<t#663ɶO22ø  K3À>z t3"t"tÉ|ó:v:vã|ãQRȋӇ ZYË6|>"    }<rU,2
>z t   >}  Ъ ª2ҳs
uÀ>z t"t <t3ۃ3
                  >uK&"t*SQ/Y[>uKC"x-&  SQ|Y[ x<t
2؋                 ? (  =? (  A (  gP  m[Z  P  s]Z  y<r
؁GGGW2P Xش>t2$ø ø ø@ 0  33 @5-.[WW  3۹ PSQ؎ 2BJY3X󫺸X
@ ûe &"(6Vp4t  Á4tðÁ  ..+    QuZS$
2..[YQɀuZ    QuPS$
2.h[YQɀuP;w;w;w;vËv>;rډF^F ;rF쀑+F+ډ^/F^;rF^+؉^+؉^  ^F+ÉF+ÉF  ^V~vF$>{s$
F>z t@>~ t fnnEs t&0'
&"
&S{2"yCC[Muƀu֨@uŀuCs t&0'
&"
&Muƀu֨@uŀuCs t&0'
&"
&뽋NV{<s <rꡳр>z t"Ŋfz"uu{fv<sF t  ^<r^㎇.<uh     &&0
&  "&"
&;r;rڋ>z u+BS2÷ދ+â>z t@[PVQS ^[ .>z u.+
[ .#
].PSUW.>z t.uV/ ^ .>z t ;r_][X.uSM#t.GMu.>z t."*.>z u:Z}
.Gĳ".Ã.>z u? U2BW{<s <rꡳ؋ֹ?&z"t""uȆ[&{s
t  Àr㎇.uh                  @8px<iZ-KB$$B3333     "  "                          &%䀈& $"uÈ!"u"- &- (;|>+>&;s;|>+>(;sSQ _^.$.."PS&V  .! Ou[8 XuE.$uu7"
7.>z u"xCu.#.>{s
..#..#<0uO2<Ar<{r2<r#  |  &&Wt n 
>% tA&F &^&N&V* ֖Muڽ*|#|>z t"t3
"8l  ||    |~  x00000x |     ||  || x`0x 000000 | l8  l8l f< 0` <00000< `0 <<  8l           00       |~~    |~ ~v   |~ 0|0000   ~v|  8<  8 8<         ||     ~v  np```   || 00|000   ~   l8   l   l8l   v|  0` % 2QSQذaY^VQWS:X [SP.2>f "uE&'.[_GYXX                                                                ++BRQST_[u.>z t.+
.TPRV+ ^ZX.>{r...Ruԋìଊ#t	&%GJ"&%G   	&0&
& "&"
&+BRS2ދ+â>z t@[PVQST^[ .>z u.+
[ .#
Z.TPSRW _Z[X..RuSJ2#t.G嬊J.>z t."*.>z u:Z}.G2".Ã.>z uUUxg\(W22Ã>z t2拄&"
&Ëڋǃ玅hP ڋǃ玅.Z 拄&"
&øZ P RZ 拄&"
&p ΃A&$Ëǃ玅hP ǃ玅.Z ΀&$øZ P RZ R蜿P s  Ztr>z trBC&.J  ރ3
>z t"tRMMF +MMF 6:  >MMv F MM~ Zk&"":t2%[62:0>N EEu
&.JË~ EEv EE^ EE"SP$x Xtu>F u s5 % r+ ; 떡6@;u:H92~>@90á6H;t2;*s"F4;(t 02&-;6tN>z utOG&-"":t8""
;6t&N>z ut&-OG&-t& &-Fɀ>z utGG&-62àE&-:u&;6$|+6,OGa&-"":t8""
;6}&Fɀ>z ut&-GG&-t &-N60E&-:u&;6&s6,GGÀFɀ>z utGG &"":u^>Bu
&Gt>C t:Du
Ft
? u)":t!urMM^ MMv MM~ MMN ;60snJ&:u&0+,&:u;6,GG&"":t!0+,Q.E&:-u;s6,GGYÉ6KM>OQ
 &GHËÊBt3
؀>z t"tGPR% >z uZЀ>z t u&G[Ë6KM>OQH&G&>z uE2ƴtsE "t"uEÀuSQP2
C"u2XY[mP, >z t, ,$+,@&+(+*XEUEUEUejotPS2 G"[XKu  ÁCuǰÁ  KPCPKZCZà<r$<s SӃ<t4KSӃuZ..[CSӃuZKSӃuP.h[CSӃuP? ?@??  0    @       PKBGI Stroked Font V1.1 - Jun 5, 1989
Copyright (c) 1987,1988 Borland International
 SCRIk*                             +              2 F   >Px @bn@Xt~Bl8r0d x4v0	r			*
v




 N~"ZBDdBpDn~PP.`(jJ88lR$X>`&6FFBd l x         !!!$!2!@!L!T!`!p!!!!!!!!""&"8"H"V"d"r""""""
#P#z###$($4$D$V$~$$$$"%R%|%%%&"&2&B&P&^&p&&&&'.'D'R'''			

	
	


	



 
	
         
                         	       	                                                                                      	      }      	                                                          y               	         	                          	      	            	   	   			      	                     {   	                   ~                                       	   	   	   	   	   	         		   
         |         	   	                                              		  		}}}}     		  		  		  		}}}}}}}}   						}}}}}}}}}}}}						         y	         	   	      	   	   		   	      	   		               y	      	   	   	   	y   	   	   	y   		   	   	   yy   		   	   	          y	   	                       


       }       


      		   	   }   ~          	   		   		        ~   	               z                       	              /*****************************************************************************\
*                                                                             *
* print.h -     Printing helper functions, types, and definitions             *
*                                                                             *
*******************************************************************************
*
*  PRINTDRIVER       - For inclusion with a printer driver
*  NOPQ              - Prevent inclusion of priority queue APIs
*
\*****************************************************************************/

#ifndef __PRINT_H       /* prevent multiple includes */
#define __PRINT_H

#ifndef __WINDOWS_H
#ifdef PRINTDRIVER
#define NORASTEROPS
#define NOTEXTMETRICS
#define NOGDICAPMASKS
#define NOGDIOBJ
#define NOBITMAP
#define NOSOUND
#define NOTEXTMETRIC
#define NOCOMM
#define NOKANJI
#include <windows.h>    /* <windows.h> must be included */
#undef NORASTEROPS
#undef NOTEXTMETRICS
#undef NOGDICAPMASKS
#undef NOGDICAPMASKS
#undef NOGDIOBJ
#undef NOBITMAP
#undef NOSOUND
#undef NOTEXTMETRIC
#undef NOCOMM
#undef NOKANJI
#else  /* !PRINTDRIVER */
#include <windows.h>    /* <windows.h> must be included */
#endif  /* PRINTERDRIVER */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef PRINTDRIVER

#define NOPTRC  /* don't allow gdidefs.inc to redef these */
#define PTTYPE POINT

#define PQERROR (-1)

#ifndef NOPQ

DECLARE_HANDLE(HPQ);

HPQ     WINAPI CreatePQ(int);
int     WINAPI MinPQ(HPQ);
int     WINAPI ExtractPQ(HPQ);
int     WINAPI InsertPQ(HPQ, int, int);
int     WINAPI SizePQ(HPQ, int);
void    WINAPI DeletePQ(HPQ);
#endif  /* !NOPQ */

/* Spool routines for use by printer drivers */

DECLARE_HANDLE(HPJOB);

HPJOB   WINAPI OpenJob(LPSTR, LPSTR, HPJOB);
int     WINAPI StartSpoolPage(HPJOB);
int     WINAPI EndSpoolPage(HPJOB);
int     WINAPI WriteSpool(HPJOB, LPSTR, int);
int     WINAPI CloseJob(HPJOB);
int     WINAPI DeleteJob(HPJOB, int);
int     WINAPI WriteDialog(HPJOB, LPSTR, int);
int     WINAPI DeleteSpoolPage(HPJOB);

#endif /* PRINTDRIVER */

typedef struct tagBANDINFOSTRUCT
{
    BOOL    fGraphics;
    BOOL    fText;
    RECT    rcGraphics;
} BANDINFOSTRUCT, FAR* LPBI;

#define USA_COUNTRYCODE 1

/*
 *  Printer driver initialization using ExtDeviceMode()
 *  and DeviceCapabilities().
 *  This replaces Drivinit.h
 */

/* size of a device name string */
#define CCHDEVICENAME 32
#define CCHPAPERNAME  64

/* current version of specification */
#define DM_SPECVERSION 0x30A

/* field selection bits */
#define DM_ORIENTATION      0x0000001L
#define DM_PAPERSIZE        0x0000002L
#define DM_PAPERLENGTH      0x0000004L
#define DM_PAPERWIDTH       0x0000008L
#define DM_SCALE            0x0000010L
#define DM_COPIES           0x0000100L
#define DM_DEFAULTSOURCE    0x0000200L
#define DM_PRINTQUALITY     0x0000400L
#define DM_COLOR            0x0000800L
#define DM_DUPLEX           0x0001000L
#define DM_YRESOLUTION      0x0002000L
#define DM_TTOPTION         0x0004000L

/* orientation selections */
#define DMORIENT_PORTRAIT   1
#define DMORIENT_LANDSCAPE  2

/* paper selections */
/*  Warning: The PostScript driver mistakingly uses DMPAPER_ values between
 *  50 and 56.  Don't use this range when defining new paper sizes.
 */
#define DMPAPER_FIRST       DMPAPER_LETTER
#define DMPAPER_LETTER      1           /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL 2           /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID     3           /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER      4           /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL       5           /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT   6           /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE   7           /* Executive 7 1/4 x 10 1/2 in        */
#define DMPAPER_A3          8           /* A3 297 x 420 mm                    */
#define DMPAPER_A4          9           /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL     10          /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5          11          /* A5 148 x 210 mm                    */
#define DMPAPER_B4          12          /* B4 250 x 354                       */
#define DMPAPER_B5          13          /* B5 182 x 257 mm                    */
#define DMPAPER_FOLIO       14          /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO      15          /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14       16          /* 10x14 in                           */
#define DMPAPER_11X17       17          /* 11x17 in                           */
#define DMPAPER_NOTE        18          /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9       19          /* Envelope #9 3 7/8 x 8 7/8          */
#define DMPAPER_ENV_10      20          /* Envelope #10 4 1/8 x 9 1/2         */
#define DMPAPER_ENV_11      21          /* Envelope #11 4 1/2 x 10 3/8        */
#define DMPAPER_ENV_12      22          /* Envelope #12 4 \276 x 11           */
#define DMPAPER_ENV_14      23          /* Envelope #14 5 x 11 1/2            */
#define DMPAPER_CSHEET      24          /* C size sheet                       */
#define DMPAPER_DSHEET      25          /* D size sheet                       */
#define DMPAPER_ESHEET      26          /* E size sheet                       */
#define DMPAPER_ENV_DL      27          /* Envelope DL 110 x 220mm            */
#define DMPAPER_ENV_C5      28          /* Envelope C5 162 x 229 mm           */
#define DMPAPER_ENV_C3      29          /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4      30          /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6      31          /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65     32          /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4      33          /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5      34          /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6      35          /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY   36          /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH 37          /* Envelope Monarch 3.875 x 7.5 in    */
#define DMPAPER_ENV_PERSONAL 38         /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US  39          /* US Std Fanfold 14 7/8 x 11 in      */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Std Fanfold 8 1/2 x 12 in   */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */

#define DMPAPER_LAST        DMPAPER_FANFOLD_LGL_GERMAN

#define DMPAPER_USER        256

/* bin selections */
#define DMBIN_FIRST         DMBIN_UPPER
#define DMBIN_UPPER         1
#define DMBIN_ONLYONE       1
#define DMBIN_LOWER         2
#define DMBIN_MIDDLE        3
#define DMBIN_MANUAL        4
#define DMBIN_ENVELOPE      5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO          7
#define DMBIN_TRACTOR       8
#define DMBIN_SMALLFMT      9
#define DMBIN_LARGEFMT      10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_LAST          DMBIN_CASSETTE

#define DMBIN_USER          256     /* device specific bins start here */

/* print qualities */
#define DMRES_DRAFT         (-1)
#define DMRES_LOW           (-2)
#define DMRES_MEDIUM        (-3)
#define DMRES_HIGH          (-4)

/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME  1
#define DMCOLOR_COLOR       2

/* duplex enable */
#define DMDUP_SIMPLEX    1
#define DMDUP_VERTICAL   2
#define DMDUP_HORIZONTAL 3

/* TrueType options */
#define DMTT_BITMAP     1       /* print TT fonts as graphics */
#define DMTT_DOWNLOAD   2       /* download TT fonts as soft fonts */
#define DMTT_SUBDEV     3       /* substitute device fonts for TT fonts */

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define CALLBACK    FAR PASCAL
#define HMODULE     HANDLE
#define UINT        WORD
#define WINAPI      FAR PASCAL
#endif  /* WIN3.0 */

typedef struct tagDEVMODE
{
    char  dmDeviceName[CCHDEVICENAME];
    UINT  dmSpecVersion;
    UINT  dmDriverVersion;
    UINT  dmSize;
    UINT  dmDriverExtra;
    DWORD dmFields;
    int   dmOrientation;
    int   dmPaperSize;
    int   dmPaperLength;
    int   dmPaperWidth;
    int   dmScale;
    int   dmCopies;
    int   dmDefaultSource;
    int   dmPrintQuality;
    int   dmColor;
    int   dmDuplex;
    int   dmYResolution;
    int   dmTTOption;
} DEVMODE;

typedef DEVMODE* PDEVMODE, NEAR* NPDEVMODE, FAR* LPDEVMODE;

/* mode selections for the device mode function */
#define DM_UPDATE           1
#define DM_COPY             2
#define DM_PROMPT           4
#define DM_MODIFY           8

#define DM_IN_BUFFER        DM_MODIFY
#define DM_IN_PROMPT        DM_PROMPT
#define DM_OUT_BUFFER       DM_COPY
#define DM_OUT_DEFAULT      DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS           1
#define DC_PAPERS           2
#define DC_PAPERSIZE        3
#define DC_MINEXTENT        4
#define DC_MAXEXTENT        5
#define DC_BINS             6
#define DC_DUPLEX           7
#define DC_SIZE             8
#define DC_EXTRA            9
#define DC_VERSION          10
#define DC_DRIVER           11
#define DC_BINNAMES         12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE         15
#define DC_PAPERNAMES       16
#define DC_ORIENTATION      17
#define DC_COPIES           18

/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP         0x0000001L
#define DCTT_DOWNLOAD       0x0000002L
#define DCTT_SUBDEV         0x0000004L

/* export ordinal definitions */
#define PROC_EXTDEVICEMODE      MAKEINTRESOURCE(90)
#define PROC_DEVICECAPABILITIES MAKEINTRESOURCE(91)
#define PROC_OLDDEVICEMODE      MAKEINTRESOURCE(13)

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions
 */
typedef UINT   (CALLBACK* LPFNDEVMODE)(HWND, HMODULE, DEVMODE FAR*,
                          LPSTR, LPSTR, DEVMODE FAR*, LPSTR, UINT);

typedef DWORD  (CALLBACK* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, DEVMODE FAR*);

HDC     WINAPI ResetDC(HDC, const DEVMODE FAR*);

/* this structure is used by the GETSETSCREENPARAMS escape */
typedef struct tagSCREENPARAMS
{
   int angle;
   int frequency;
} SCREENPARAMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __PRINT_H */
/*****************************************************************************\
*                                                                             *
* wfext.h -     Windows File Manager Extensions definitions                   *
*                                                                             *
*               Version 3.10                                                  *                   *
*                                                                             *
*******************************************************************************/

#ifndef __WFEXT_H       /* prevent multiple includes */
#define __WFEXT_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#if !defined(WINVER) || (WINVER < 0x030a)
#error File Manager extensions require Windows 3.1
#endif

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define MENU_TEXT_LEN           40

#define FMMENU_FIRST            1
#define FMMENU_LAST             99

#define FMEVENT_LOAD            100
#define FMEVENT_UNLOAD          101
#define FMEVENT_INITMENU        102
#define FMEVENT_USER_REFRESH    103
#define FMEVENT_SELCHANGE       104

#define FMFOCUS_DIR             1
#define FMFOCUS_TREE            2
#define FMFOCUS_DRIVES          3
#define FMFOCUS_SEARCH          4

#define FM_GETFOCUS             (WM_USER + 0x0200)
#define FM_GETDRIVEINFO         (WM_USER + 0x0201)
#define FM_GETSELCOUNT          (WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN       (WM_USER + 0x0203)      /* LFN versions are odd */
#define FM_GETFILESEL           (WM_USER + 0x0204)
#define FM_GETFILESELLFN        (WM_USER + 0x0205)      /* LFN versions are odd */
#define FM_REFRESH_WINDOWS      (WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS    (WM_USER + 0x0207)

typedef struct tagFMS_GETFILESEL
{
        UINT wTime;
        UINT wDate;
        DWORD dwSize;
        BYTE bAttr;
        char szName[260];               /* always fully qualified */
} FMS_GETFILESEL, FAR *LPFMS_GETFILESEL;

typedef struct tagFMS_GETDRIVEINFO       /* for drive */
{
        DWORD dwTotalSpace;
        DWORD dwFreeSpace;
        char szPath[260];               /* current directory */
        char szVolume[14];              /* volume label */
        char szShare[128];              /* if this is a net drive */
} FMS_GETDRIVEINFO, FAR *LPFMS_GETDRIVEINFO;

typedef struct tagFMS_LOAD
{
        DWORD dwSize;                           /* for version checks */
        char  szMenuName[MENU_TEXT_LEN];        /* output */
        HMENU hMenu;                            /* output */
        UINT  wMenuDelta;                       /* input */
} FMS_LOAD, FAR *LPFMS_LOAD;

typedef DWORD (CALLBACK *FM_EXT_PROC)(HWND, UINT, LONG);
typedef DWORD (CALLBACK *FM_UNDELETE_PROC)(HWND, LPSTR);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __WFEXT_H */

0 6 4 1 14/*  varargs.h

    Definitions for accessing parameters in functions that accept
    a variable number of arguments.  These macros are compatible
    with UNIX System V.  Use stdarg.h for ANSI C compatibility.

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __VARARGS_H
#define __VARARGS_H

#ifdef __STDARG_H
#error Can't include both STDARG.H and VARARGS.H
#endif

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

typedef void _FAR *va_list;
#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap, type) (*(type _FAR *)(((*(char _FAR *_FAR *)&(ap))+=((sizeof(type)+1) & 0xFFFE))-(((sizeof(type)+1) & 0xFFFE))))
#define va_end(ap)   ap = ((void _FAR *)0)

#endif  /* __VARARGS_H */
/*  _defs.h

    Common definitions for pointer size and calling conventions.

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(___DEFS_H)
#define ___DEFS_H

#if __STDC__
#  define _Cdecl
#else
#  define _Cdecl  cdecl
#endif

#ifndef __PAS__
#  define _CType _Cdecl
#else
#  define _CType pascal
#endif

#ifdef __MSC
#  define _emit db
#  define __far _far
#  define __near _near
#  define __cdecl _cdecl
#  define __pascal _pascal
#  define __export _export
#  ifdef __SMALL__
#    define _M_I86SM
#  endif
#  ifdef __COMPACT__
#    define _M_I86CM
#  endif
#  ifdef __MEDIUM__
#    define _M_I86MM
#  endif
#  ifdef __LARGE__
#    define _M_I86LM
#  endif
#  ifndef _Windows
#    define _DOS
#  else
#    define _WINDOWS
#  endif
#endif

#if defined(__STDC__)
#  define _FAR
#  define _FARFUNC
#  define _CLASSTYPE
#else
#  if defined(_BUILDRTLDLL)
#    define _FARFUNC _export
#  elif defined(_RTLDLL)
#    define _FARFUNC far
#  else
#    define _FARFUNC
#  endif
#  if defined(__DLL__)
#    if defined(_RTLDLL) || defined(_CLASSDLL)
#      define _CLASSTYPE _export
#    else
#      define _CLASSTYPE far
#    endif
#    define _FAR far
#  elif defined(_RTLDLL) || defined(_CLASSDLL)
#    define _CLASSTYPE huge
#    define _FAR far
#  else
#    define _FAR
#    if   defined(__TINY__) || defined(__SMALL__) || defined(__MEDIUM__)
#      define _CLASSTYPE  near
#    elif defined(__COMPACT__) || defined(__LARGE__)
#      define _CLASSTYPE  far
#    else
#      define _CLASSTYPE  huge
#    endif
#  endif
#endif    /* __STDC__ */

#if defined(_BUILDRTLDLL)
#  define _FARCALL _export
#else
#  define _FARCALL far
#endif

#if defined( __cplusplus )
#  define _PTRDEF(name) typedef name _FAR * P##name;
#  define _REFDEF(name) typedef name _FAR & R##name;
#  define _REFPTRDEF(name) typedef name _FAR * _FAR & RP##name;
#  define _PTRCONSTDEF(name) typedef const name _FAR * PC##name;
#  define _REFCONSTDEF(name) typedef const name _FAR & RC##name;
#  define _CLASSDEF(name) class _CLASSTYPE name; \
        _PTRDEF(name) \
    _REFDEF(name) \
    _REFPTRDEF(name) \
    _PTRCONSTDEF(name) \
    _REFCONSTDEF(name)
#endif

#endif  /* ___DEFS_H */
/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
\*****************************************************************************/

#ifndef __WINDOWSX_H    /* prevent multiple includes */
#define __WINDOWSX_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) \
                GetModuleHandle((LPCSTR)MAKELP(0, hInstance))

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))

#define     GlobalLockPtr(lp)           \
                ((BOOL)SELECTOROF(GlobalLock(GlobalPtrHandle(lp))))
#define     GlobalUnlockPtr(lp)         \
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)   \
                (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalReAllocPtr(lp, cbNew, flags)  \
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)           \
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)         DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)          ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)        DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)        ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)         DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)       DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)         ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)       GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SendMessage(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)  \
                ((WNDPROC)SetWindowLong((hwnd), GWL_WNDPROC, (LPARAM)(WNDPROC)(lpfn)))

#define     IsMinimized(hwnd)   IsIconic(hwnd)
#define     IsMaximized(hwnd)   IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SendMessage)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SendMessage)

#if defined(WINVER) && (WINVER >= 0x030a)
#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT FAR*)(lprc), 2)
#endif  /* WINVER >= 0x030a */

#define     IsLButtonDown()     (GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()     (GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()     (GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
                ((DLGPROC)SetWindowLong(hwndDlg, DWL_DLGPROC, (LPARAM)(DLGPROC)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result)   \
    (((msg) == WM_CTLCOLOR || (msg) == WM_COMPAREITEM || (msg) == WM_VKEYTOITEM ||  \
    (msg) == WM_CHARTOITEM || (msg) == WM_QUERYDRAGICON || (msg) == WM_INITDIALOG)  \
    ? (BOOL)LOWORD(result) : (SetWindowLong((hwnd), DWL_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio); */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCSTR lpszSectionName); */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0, (LPARAM)(LPCSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd); */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd); */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd); */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue); */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((UINT)(cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCSTR lpszDeviceName); */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0,(LPARAM)(LPCSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd); */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0, 0L)

/* void Cls_OnPower(HWND hwnd, int code); */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd); */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding); */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode); */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* void Cls_OnSystemError(HWND hwnd, int errCode); */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) \
    (void)(fn)((hwnd), WM_SYSTEMERROR, (WPARAM)(errCode), 0L)

/* BOOL Cls_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (CREATESTRUCT FAR*)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (CREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd); */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0, 0L)

/* void Cls_OnNCDestroy(HWND hwnd); */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status); */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), MAKELPARAM((UINT)(status), 0))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw); */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable); */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCSTR lpszText); */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0, (LPARAM)(LPCSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd); */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (WINDOWPOS FAR*)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0, (LPARAM)(WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const WINDOWPOS FAR*)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0, (LPARAM)(const WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y); */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0, MAKELPARAM((int)(x), (int)(y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy); */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((int)(cx), (int)(cy)))

/* void Cls_OnClose(HWND hwnd); */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd); */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, MINMAXINFO FAR* lpMinMaxInfo); */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MINMAXINFO FAR*)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0, (LPARAM)(MINMAXINFO FAR*)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd); */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn); */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS FAR* lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS FAR*)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS FAR*)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y); */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0, MAKELPARAM((int)(x), (int)(y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd); */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0, 0L)

#ifdef __SHELLAPI_H
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop); */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(hdrop), 0L)
#endif  /* __SHELLAPI_H */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, (WPARAM)(UINT)(state), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, HTASK htaskActDeact); */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HTASK)LOWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, htaskActDeact, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), MAKELPARAM((htaskActDeact),0))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam))
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus); */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd); */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id); */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu); */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, int item, BOOL fSystemMenu); */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (int)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags); */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)HIWORD(lParam), (LOWORD(lParam) & MF_POPUP) ? 0 : (int)(wParam), \
                            (LOWORD(lParam) & MF_POPUP) ? (HMENU)(wParam) : 0, LOWORD(lParam)), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, ((flags) & MF_POPUP) ? (WPARAM)(HMENU)(hmenuPopup) : (WPARAM)(int)(item), MAKELPARAM((flags), (hmenu)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu); */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam), LOWORD(lParam), (HMENU)HIWORD(lParam));
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((flags), (UINT)(hmenu)))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, (WPARAM)(int)(id), MAKELPARAM((UINT)(hwndCtl), (codeNotify)))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam),  (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnCut(HWND hwnd); */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0, 0L)

/* void Cls_OnCopy(HWND hwnd); */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0, 0L)

/* void Cls_OnPaste(HWND hwnd); */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0, 0L)

/* void Cls_OnClear(HWND hwnd); */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0, 0L)

/* void Cls_OnUndo(HWND hwnd); */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt); */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT)(DWORD)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd); */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd); */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd); */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const PAINTSTRUCT FAR* lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const PAINTSTRUCT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const RECT FAR* lprc); */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const RECT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPSTR rgchName); */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext); */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), MAKELPARAM((UINT)(hwndNext), 0))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam));
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y); */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const MDICREATESTRUCT FAR* lpmcs); */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (MDICREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0, (LPARAM)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy); */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate); */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (HWND)HIWORD(lParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(fActive), MAKELPARAM((hwndActivate), (hwndDeactivate)))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore); */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev); */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), MAKELPARAM((fPrev), 0))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize); */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd); */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd); */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDIGETACTIVE, 0, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow); */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (HMENU)LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT)(DWORD)(fn)((hwnd), WM_MDISETMENU, (WPARAM)(fRefresh), MAKELPARAM((hmenuFrame), (hmenuWindow)))

/* void Cls_OnChildActivate(HWND hwnd); */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam); */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam);
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), MAKELPARAM((fNext), 0))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild); */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, (WPARAM)(UINT)(msg), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(idChild)))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource); */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), MAKELPARAM((UINT)(HWND)(hwndSource), 0))

/* UINT Cls_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg); */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (MSG FAR*)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (SELECTOROF(lpmsg) ? lpmsg->wParam : 0), (LPARAM)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type); */
#define HANDLE_WM_CTLCOLOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)LOWORD(lParam), (int)(HIWORD(lParam)))
#define FORWARD_WM_CTLCOLOR(hwnd, hdc, hwndChild, type, fn) \
    (HBRUSH)(UINT)(DWORD)(fn)((hwnd), WM_CTLCOLOR, (WPARAM)(HDC)(hdc), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(int)(type)))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw); */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SETFONT(hwnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), MAKELPARAM((UINT)(BOOL)(fRedraw), 0))

/* HFONT Cls_OnGetFont(HWND hwnd); */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT)(DWORD)(fn)((hwnd), WM_GETFONT, 0, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT FAR* lpDrawItem); */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, 0, (LPARAM)(const DRAWITEMSTRUCT FAR*)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem); */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, 0, (LPARAM)(MEASUREITEMSTRUCT FAR*)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT FAR* lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, 0, (LPARAM)(const DELETEITEMSTRUCT FAR*)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT FAR* lpCompareItem); */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT FAR*)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, 0, (LPARAM)(const COMPAREITEMSTRUCT FAR*)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* void Cls_OnQueueSync(HWND hwnd); */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0, 0L)

/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags); */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_GETICON, 0, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETCHECK, 0, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SendMessage((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETSTATE, 0, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SendMessage((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SendMessage((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SendMessage((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINECOUNT, 0, 0L))
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int FAR*)(lpch)) = (cchMax)), ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPSTR)(lpch))))

#define Edit_GetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_GETRECT, 0, (LPARAM)(RECT FAR*)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_SETRECT, 0, (LPARAM)(const RECT FAR*)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SendMessage((hwndCtl), EM_SETRECTNP, 0, (LPARAM)(const RECT FAR*)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SendMessage((hwndCtl), EM_SETSEL, 0, MAKELPARAM((ichStart), (ichEnd))))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SendMessage((hwndCtl), EM_REPLACESEL, 0, (LPARAM)(LPCSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SendMessage((hwndCtl), EM_GETMODIFY, 0, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SendMessage((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SendMessage((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SendMessage((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SendMessage((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SendMessage((hwndCtl), EM_LINESCROLL, 0, MAKELPARAM((dv), (dh))))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SendMessage((hwndCtl), EM_CANUNDO, 0, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SendMessage((hwndCtl), EM_UNDO, 0, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SendMessage((hwndCtl), EM_EMPTYUNDOBUFFER, 0, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SendMessage((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SendMessage((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int FAR*)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SendMessage((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT)(DWORD)SendMessage((hwndCtl), EM_GETHANDLE, 0, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SendMessage((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT)(HLOCAL)(h), 0L))

#if defined(WINVER) && (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SendMessage((hwndCtl), EM_GETFIRSTVISIBLELINE, 0, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SendMessage((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((char)(DWORD)SendMessage((hwndCtl), EM_GETPASSWORDCHAR, 0, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SendMessage((hwndCtl), EM_SETWORDBREAKPROC, 0, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SendMessage((hwndCtl), EM_GETWORDBREAKPROC, 0, 0L))
#endif  /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), LB_GETCOUNT, 0, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), LB_RESETCONTENT, 0, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), MAKELPARAM((index), 0)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), LB_GETCURSEL, 0, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELCOUNT, 0, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETTOPINDEX, 0, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int FAR*)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), LB_GETHORIZONTALEXTENT, 0, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int FAR*)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT FAR*)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETCARETINDEX, 0, 0L))


#if defined(WINVER) && (WINVER >= 0x030a)
#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SendMessage((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SendMessage((hwndCtl), CB_GETEDITSEL, 0, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SendMessage((hwndCtl), CB_SETEDITSEL, 0, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CB_GETCOUNT, 0, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SendMessage((hwndCtl), CB_RESETCONTENT, 0, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SendMessage((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)SendMessage((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SendMessage((hwndCtl), CB_GETCURSEL, 0, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SendMessage((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SendMessage((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if defined(WINVER) && (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SendMessage((hwndCtl), CB_GETDROPPEDSTATE, 0, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SendMessage((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)(RECT FAR*)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CB_GETITEMHEIGHT, 0, 0L))
#define ComboBox_SetItemHeight(hwndCtl, cyItem)     ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), 0L))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), CB_GETEXTENDEDUI, 0, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SendMessage((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __WINDOWSX_H */
/*  dirent.h

    Definitions for POSIX directory operations.

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __DIRENT_H
#define __DIRENT_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef NULL
#include <_null.h>
#endif

/* dirent structure returned by readdir().
 */
struct dirent
{
    char        d_name[13];
};

/* DIR type returned by opendir().  The first two members cannot
 * be separated, because they make up the DOS DTA structure used
 * by findfirst() and findnext().
 */
typedef struct
{
    char          _d_reserved[30];      /* reserved part of DTA */
    struct dirent _d_dirent;            /* filename part of DTA */
    char    _FAR *_d_dirname;           /* directory name */
    char          _d_first;             /* first file flag */
    unsigned char _d_magic;             /* magic cookie for verifying handle */
} DIR;

/* Prototypes.
 */
#ifdef __cplusplus
extern "C" {
#endif

DIR             _FAR * _Cdecl _FARFUNC opendir (char _FAR *__dirname);
struct dirent   _FAR * _Cdecl _FARFUNC readdir (DIR _FAR *__dir);
int             _Cdecl _FARFUNC closedir (DIR _FAR *__dir);
void            _Cdecl _FARFUNC rewinddir(DIR _FAR *__dir);

#ifdef __cplusplus
}
#endif

#endif /* __DIRENT_H */
/****************************************************************************/
/*                                                                          */
/*        MMSYSTEM.H - Include file for Multimedia APIs                     */
/*                                                                          */
/****************************************************************************/


/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *      MMNODRV          - Installable driver support
 *      MMNOSOUND        - Sound support
 *      MMNOWAVE         - Waveform support
 *      MMNOMIDI         - MIDI support
 *      MMNOAUX          - Auxiliary audio support
 *      MMNOTIMER        - Timer support
 *      MMNOJOY          - Joystick support
 *      MMNOMCI          - MCI support
 *      MMNOMMIO         - Multimedia file I/O support
 *      MMNOMMSYSTEM     - General MMSYSTEM functions
 */

#ifndef __MMSYSTEM_H    /* prevent multiple includes */
#define __MMSYSTEM_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#if !defined(WINVER) || (WINVER < 0x030a)
#error Multimedia APIs require Windows 3.1
#endif

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


/****************************************************************************

                    General constants and data types

****************************************************************************/

/* general constants */
#define MAXPNAMELEN      32     /* max product name length (including NULL) */
#define MAXERRORLENGTH   128    /* max error text length (including NULL) */

/* general data types */
typedef WORD    VERSION;        /* major (high byte), minor (low byte) */

/* MMTIME data structure */
typedef struct mmtime_tag {
    UINT    wType;              /* indicates the contents of the union */
    union {
        DWORD ms;               /* milliseconds */
        DWORD sample;           /* samples */
        DWORD cb;               /* byte count */
        struct {                /* SMPTE */
            BYTE hour;          /* hours */
            BYTE min;           /* minutes */
            BYTE sec;           /* seconds */
            BYTE frame;         /* frames  */
            BYTE fps;           /* frames per second */
            BYTE dummy;         /* pad */
            } smpte;
        struct {                /* MIDI */
            DWORD songptrpos;   /* song pointer position */
            } midi;
        } u;
    } MMTIME;
typedef MMTIME       *PMMTIME;
typedef MMTIME NEAR *NPMMTIME;
typedef MMTIME FAR  *LPMMTIME;

/* types for wType field in MMTIME struct */
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */


/****************************************************************************

                    Multimedia Extensions Window Messages

****************************************************************************/

#define MM_JOY1MOVE         0x3A0           /* joystick */
#define MM_JOY2MOVE         0x3A1
#define MM_JOY1ZMOVE        0x3A2
#define MM_JOY2ZMOVE        0x3A3
#define MM_JOY1BUTTONDOWN   0x3B5
#define MM_JOY2BUTTONDOWN   0x3B6
#define MM_JOY1BUTTONUP     0x3B7
#define MM_JOY2BUTTONUP     0x3B8

#define MM_MCINOTIFY        0x3B9           /* MCI */

#define MM_WOM_OPEN         0x3BB           /* waveform output */
#define MM_WOM_CLOSE        0x3BC
#define MM_WOM_DONE         0x3BD

#define MM_WIM_OPEN         0x3BE           /* waveform input */
#define MM_WIM_CLOSE        0x3BF
#define MM_WIM_DATA         0x3C0

#define MM_MIM_OPEN         0x3C1           /* MIDI input */
#define MM_MIM_CLOSE        0x3C2
#define MM_MIM_DATA         0x3C3
#define MM_MIM_LONGDATA     0x3C4
#define MM_MIM_ERROR        0x3C5
#define MM_MIM_LONGERROR    0x3C6

#define MM_MOM_OPEN         0x3C7           /* MIDI output */
#define MM_MOM_CLOSE        0x3C8
#define MM_MOM_DONE         0x3C9


/****************************************************************************

                String resource number bases (internal use)

****************************************************************************/

#define MMSYSERR_BASE          0
#define WAVERR_BASE            32
#define MIDIERR_BASE           64
#define TIMERR_BASE            96
#define JOYERR_BASE            160
#define MCIERR_BASE            256

#define MCI_STRING_OFFSET      512
#define MCI_VD_OFFSET          1024
#define MCI_CD_OFFSET          1088
#define MCI_WAVE_OFFSET        1152
#define MCI_SEQ_OFFSET         1216

/****************************************************************************

                        General error return values

****************************************************************************/

/* general error return values */
#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 11) /* last error in range */


/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
DECLARE_HANDLE(HDRVR);
#endif  /* WIN3.0 */

#ifndef MMNODRV
/****************************************************************************

                        Installable driver support

****************************************************************************/

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)

/* return values from DriverProc() function */
#define DRV_CANCEL              0x0000
#define DRV_OK                  0x0001
#define DRV_RESTART             0x0002

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO        *PDRVCONFIGINFO;
typedef DRVCONFIGINFO  NEAR *NPDRVCONFIGINFO;
typedef DRVCONFIGINFO  FAR  *LPDRVCONFIGINFO;

/* installable driver function prototypes */
LRESULT   WINAPI DrvClose(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);
HDRVR     WINAPI DrvOpen(LPCSTR szDriverName, LPCSTR szSectionName,
    LPARAM lParam2);
LRESULT   WINAPI DrvSendMessage(HDRVR hDriver, UINT uMessage,
    LPARAM lParam1, LPARAM lParam2);
HINSTANCE WINAPI DrvGetModuleHandle(HDRVR hDriver);

LRESULT WINAPI DrvDefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID,
    UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#define DefDriverProc DrvDefDriverProc

#endif  /* WIN3.0 */


#if defined(WINVER) && (WINVER >= 0x030a)

/* return values from DriverProc() function */
#define DRV_CANCEL             DRVCNF_CANCEL
#define DRV_OK                 DRVCNF_OK
#define DRV_RESTART            DRVCNF_RESTART

#endif  /* WINVER >= 0x030a */

#define DRV_MCI_FIRST          DRV_RESERVED
#define DRV_MCI_LAST           (DRV_RESERVED + 0xFFF)

#endif  /* ifndef MMNODRV */


/****************************************************************************

                          Driver callback support

****************************************************************************/

/* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and */
/* midiOutOpen() to specify the type of the dwCallback parameter. */

#define CALLBACK_TYPEMASK   0x00070000l    /* callback type mask */
#define CALLBACK_NULL       0x00000000l    /* no callback */
#define CALLBACK_WINDOW     0x00010000l    /* dwCallback is a HWND */
#define CALLBACK_TASK       0x00020000l    /* dwCallback is a HTASK */
#define CALLBACK_FUNCTION   0x00030000l    /* dwCallback is a FARPROC */

/* driver callback prototypes */
typedef void (CALLBACK DRVCALLBACK) (HDRVR h, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef DRVCALLBACK FAR *LPDRVCALLBACK;

/****************************************************************************

                         Manufacturer and product IDs

    Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS,
    MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.

****************************************************************************/

/* manufacturer IDs */
#define MM_MICROSOFT            1       /* Microsoft Corp. */

/* product IDs */
#define MM_MIDI_MAPPER          1       /* MIDI Mapper */
#define MM_WAVE_MAPPER          2       /* Wave Mapper */

#define MM_SNDBLST_MIDIOUT      3       /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4       /* Sound Blaster MIDI input port  */
#define MM_SNDBLST_SYNTH        5       /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6       /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7       /* Sound Blaster waveform input */

#define MM_ADLIB                9       /* Ad Lib-compatible synthesizer */

#define MM_MPU401_MIDIOUT       10      /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN        11      /* MPU401-compatible MIDI input port */

#define MM_PC_JOYSTICK          12      /* Joystick adapter */


#ifndef MMNOMMSYSTEM
/****************************************************************************

                    General MMSYSTEM support

****************************************************************************/

WORD WINAPI mmsystemGetVersion(void);
void WINAPI OutputDebugStr(LPCSTR);

#endif  /* ifndef MMNOMMSYSTEM */


#ifndef MMNOSOUND
/****************************************************************************

                            Sound support

****************************************************************************/

BOOL WINAPI sndPlaySound(LPCSTR lpszSoundName, UINT uFlags);

/* flag values for wFlags parameter */
#define SND_SYNC            0x0000  /* play synchronously (default) */
#define SND_ASYNC           0x0001  /* play asynchronously */
#define SND_NODEFAULT       0x0002  /* don't use default sound */
#define SND_MEMORY          0x0004  /* lpszSoundName points to a memory file */
#define SND_LOOP            0x0008  /* loop the sound until next sndPlaySound */
#define SND_NOSTOP          0x0010  /* don't stop any currently playing sound */

#endif  /* ifndef MMNOSOUND */


#ifndef MMNOWAVE
/****************************************************************************

                        Waveform audio support

****************************************************************************/

/* waveform audio error return values */
#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* waveform audio data types */
DECLARE_HANDLE(HWAVE);
DECLARE_HANDLE(HWAVEIN);
DECLARE_HANDLE(HWAVEOUT);
typedef HWAVEIN FAR *LPHWAVEIN;
typedef HWAVEOUT FAR *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK FAR *LPWAVECALLBACK;

/* wave callback messages */
#define WOM_OPEN        MM_WOM_OPEN
#define WOM_CLOSE       MM_WOM_CLOSE
#define WOM_DONE        MM_WOM_DONE
#define WIM_OPEN        MM_WIM_OPEN
#define WIM_CLOSE       MM_WIM_CLOSE
#define WIM_DATA        MM_WIM_DATA

/* device ID for wave device mapper */
#define WAVE_MAPPER     (-1)

/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */
#define  WAVE_FORMAT_QUERY     0x0001
#define  WAVE_ALLOWSYNC        0x0002

/* wave data block header */
typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    struct wavehdr_tag far *lpNext;     /* reserved for driver */
    DWORD       reserved;               /* reserved for driver */
} WAVEHDR;
typedef WAVEHDR       *PWAVEHDR;
typedef WAVEHDR NEAR *NPWAVEHDR;
typedef WAVEHDR FAR  *LPWAVEHDR;

/* flags for dwFlags field of WAVEHDR */
#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */

/* waveform output device capabilities structure */
typedef struct waveoutcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    UINT    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS;
typedef WAVEOUTCAPS       *PWAVEOUTCAPS;
typedef WAVEOUTCAPS NEAR *NPWAVEOUTCAPS;
typedef WAVEOUTCAPS FAR  *LPWAVEOUTCAPS;

/* flags for dwSupport field of WAVEOUTCAPS */
#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010

/* waveform input device capabilities structure */
typedef struct waveincaps_tag {
    UINT    wMid;                    /* manufacturer ID */
    UINT    wPid;                    /* product ID */
    VERSION vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    UINT    wChannels;               /* number of channels supported */
} WAVEINCAPS;
typedef WAVEINCAPS       *PWAVEINCAPS;
typedef WAVEINCAPS NEAR *NPWAVEINCAPS;
typedef WAVEINCAPS FAR  *LPWAVEINCAPS;

/* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS */
#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

/* general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT       *PWAVEFORMAT;
typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;

/* waveform audio function prototypes */
UINT WINAPI waveOutGetNumDevs(void);
UINT WINAPI waveOutGetDevCaps(UINT uDeviceID, WAVEOUTCAPS FAR* lpCaps,
    UINT uSize);
UINT WINAPI waveOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
UINT WINAPI waveOutSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI waveOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI waveOutOpen(HWAVEOUT FAR* lphWaveOut, UINT uDeviceID,
    const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI waveOutClose(HWAVEOUT hWaveOut);
UINT WINAPI waveOutPrepareHeader(HWAVEOUT hWaveOut,
     WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
UINT WINAPI waveOutUnprepareHeader(HWAVEOUT hWaveOut,
    WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
UINT WINAPI waveOutWrite(HWAVEOUT hWaveOut, WAVEHDR FAR* lpWaveOutHdr,
    UINT uSize);
UINT WINAPI waveOutPause(HWAVEOUT hWaveOut);
UINT WINAPI waveOutRestart(HWAVEOUT hWaveOut);
UINT WINAPI waveOutReset(HWAVEOUT hWaveOut);
UINT WINAPI waveOutBreakLoop(HWAVEOUT hWaveOut);
UINT WINAPI waveOutGetPosition(HWAVEOUT hWaveOut, MMTIME FAR* lpInfo,
    UINT uSize);
UINT WINAPI waveOutGetPitch(HWAVEOUT hWaveOut, DWORD FAR* lpdwPitch);
UINT WINAPI waveOutSetPitch(HWAVEOUT hWaveOut, DWORD dwPitch);
UINT WINAPI waveOutGetPlaybackRate(HWAVEOUT hWaveOut, DWORD FAR* lpdwRate);
UINT WINAPI waveOutSetPlaybackRate(HWAVEOUT hWaveOut, DWORD dwRate);
UINT WINAPI waveOutGetID(HWAVEOUT hWaveOut, UINT FAR* lpuDeviceID);

#if defined(WINVER) && (WINVER >= 0x030a)
DWORD WINAPI waveOutMessage(HWAVEOUT hWaveOut, UINT uMessage, DWORD dw1, DWORD dw2);
#endif  /* WINVER >= 0x030a */

UINT WINAPI waveInGetNumDevs(void);
UINT WINAPI waveInGetDevCaps(UINT uDeviceID, WAVEINCAPS FAR* lpCaps,
    UINT uSize);
UINT WINAPI waveInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI waveInOpen(HWAVEIN FAR* lphWaveIn, UINT uDeviceID,
    const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI waveInClose(HWAVEIN hWaveIn);
UINT WINAPI waveInPrepareHeader(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInUnprepareHeader(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInAddBuffer(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInStart(HWAVEIN hWaveIn);
UINT WINAPI waveInStop(HWAVEIN hWaveIn);
UINT WINAPI waveInReset(HWAVEIN hWaveIn);
UINT WINAPI waveInGetPosition(HWAVEIN hWaveIn, MMTIME FAR* lpInfo,
    UINT uSize);
UINT WINAPI waveInGetID(HWAVEIN hWaveIn, UINT FAR* lpuDeviceID);

#if defined(WINVER) && (WINVER >= 0x030a)
DWORD WINAPI waveInMessage(HWAVEIN hWaveIn, UINT uMessage, DWORD dw1, DWORD dw2);
#endif  /* WINVER >= 0x030a */

#endif  /* ifndef MMNOWAVE */


#ifndef MMNOMIDI
/****************************************************************************

                            MIDI audio support

****************************************************************************/

/* MIDI error return values */
#define MIDIERR_UNPREPARED    (MIDIERR_BASE + 0)   /* header not prepared */
#define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   /* still something playing */
#define MIDIERR_NOMAP         (MIDIERR_BASE + 2)   /* no current map */
#define MIDIERR_NOTREADY      (MIDIERR_BASE + 3)   /* hardware is still busy */
#define MIDIERR_NODEVICE      (MIDIERR_BASE + 4)   /* port no longer connected */
#define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   /* invalid setup */
#define MIDIERR_LASTERROR     (MIDIERR_BASE + 5)   /* last error in range */

/* MIDI audio data types */
DECLARE_HANDLE(HMIDI);
DECLARE_HANDLE(HMIDIIN);
DECLARE_HANDLE(HMIDIOUT);
typedef HMIDIIN FAR *LPHMIDIIN;
typedef HMIDIOUT FAR *LPHMIDIOUT;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK FAR *LPMIDICALLBACK;
#define MIDIPATCHSIZE   128
typedef WORD PATCHARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPPATCHARRAY;
typedef WORD KEYARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPKEYARRAY;

/* MIDI callback messages */
#define MIM_OPEN        MM_MIM_OPEN
#define MIM_CLOSE       MM_MIM_CLOSE
#define MIM_DATA        MM_MIM_DATA
#define MIM_LONGDATA    MM_MIM_LONGDATA
#define MIM_ERROR       MM_MIM_ERROR
#define MIM_LONGERROR   MM_MIM_LONGERROR
#define MOM_OPEN        MM_MOM_OPEN
#define MOM_CLOSE       MM_MOM_CLOSE
#define MOM_DONE        MM_MOM_DONE

/* device ID for MIDI mapper */
#define MIDIMAPPER     (-1)
#define MIDI_MAPPER    (-1)

/* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */
#define MIDI_CACHE_ALL      1
#define MIDI_CACHE_BESTFIT  2
#define MIDI_CACHE_QUERY    3
#define MIDI_UNCACHE        4

/* MIDI output device capabilities structure */
typedef struct midioutcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT    wTechnology;           /* type of device */
    UINT    wVoices;               /* # of voices (internal synth only) */
    UINT    wNotes;                /* max # of notes (internal synth only) */
    UINT    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS;
typedef MIDIOUTCAPS       *PMIDIOUTCAPS;
typedef MIDIOUTCAPS NEAR *NPMIDIOUTCAPS;
typedef MIDIOUTCAPS FAR  *LPMIDIOUTCAPS;

/* flags for wTechnology field of MIDIOUTCAPS structure */
#define MOD_MIDIPORT    1  /* output port */
#define MOD_SYNTH       2  /* generic internal synth */
#define MOD_SQSYNTH     3  /* square wave internal synth */
#define MOD_FMSYNTH     4  /* FM internal synth */
#define MOD_MAPPER      5  /* MIDI mapper */

/* flags for dwSupport field of MIDIOUTCAPS structure */
#define MIDICAPS_VOLUME          0x0001  /* supports volume control */
#define MIDICAPS_LRVOLUME        0x0002  /* separate left-right volume control */
#define MIDICAPS_CACHE           0x0004

/* MIDI output device capabilities structure */
typedef struct midiincaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
} MIDIINCAPS;
typedef MIDIINCAPS      *PMIDIINCAPS;
typedef MIDIINCAPS NEAR *NPMIDIINCAPS;
typedef MIDIINCAPS FAR  *LPMIDIINCAPS;

/* MIDI data block header */
typedef struct midihdr_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD       dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag far *lpNext;   /* reserved for driver */
    DWORD       reserved;             /* reserved for driver */
} MIDIHDR;
typedef MIDIHDR       *PMIDIHDR;
typedef MIDIHDR NEAR *NPMIDIHDR;
typedef MIDIHDR FAR  *LPMIDIHDR;

/* flags for dwFlags field of MIDIHDR structure */
#define MHDR_DONE       0x00000001       /* done bit */
#define MHDR_PREPARED   0x00000002       /* set if header prepared */
#define MHDR_INQUEUE    0x00000004       /* reserved for driver */

/* MIDI function prototypes */
UINT WINAPI midiOutGetNumDevs(void);
UINT WINAPI midiOutGetDevCaps(UINT uDeviceID,
    MIDIOUTCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI midiOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
UINT WINAPI midiOutSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI midiOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI midiOutOpen(HMIDIOUT FAR* lphMidiOut, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI midiOutClose(HMIDIOUT hMidiOut);
UINT WINAPI midiOutPrepareHeader(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutUnprepareHeader(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutShortMsg(HMIDIOUT hMidiOut, DWORD dwMsg);
UINT WINAPI midiOutLongMsg(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutReset(HMIDIOUT hMidiOut);
UINT WINAPI midiOutCachePatches(HMIDIOUT hMidiOut,
    UINT uBank, WORD FAR* lpwPatchArray, UINT uFlags);
UINT WINAPI midiOutCacheDrumPatches(HMIDIOUT hMidiOut,
    UINT uPatch, WORD FAR* lpwKeyArray, UINT uFlags);
UINT WINAPI midiOutGetID(HMIDIOUT hMidiOut, UINT FAR* lpuDeviceID);

#if defined(WINVER) && (WINVER >= 0x030a)
DWORD WINAPI midiOutMessage(HMIDIOUT hMidiOut, UINT uMessage, DWORD dw1, DWORD dw2);
#endif  /* WINVER >= 0x030a */

UINT WINAPI midiInGetNumDevs(void);
UINT WINAPI midiInGetDevCaps(UINT uDeviceID,
    LPMIDIINCAPS lpCaps, UINT uSize);
UINT WINAPI midiInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI midiInOpen(HMIDIIN FAR* lphMidiIn, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI midiInClose(HMIDIIN hMidiIn);
UINT WINAPI midiInPrepareHeader(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInUnprepareHeader(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInAddBuffer(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInStart(HMIDIIN hMidiIn);
UINT WINAPI midiInStop(HMIDIIN hMidiIn);
UINT WINAPI midiInReset(HMIDIIN hMidiIn);
UINT WINAPI midiInGetID(HMIDIIN hMidiIn, UINT FAR* lpuDeviceID);

#if defined(WINVER) && (WINVER >= 0x030a)
DWORD WINAPI midiInMessage(HMIDIIN hMidiIn, UINT uMessage, DWORD dw1, DWORD dw2);
#endif  /* WINVER >= 0x030a */

#endif  /* ifndef MMNOMIDI */


#ifndef MMNOAUX
/****************************************************************************

                        Auxiliary audio support

****************************************************************************/

/* device ID for aux device mapper */
#define AUX_MAPPER     (-1)

/* Auxiliary audio device capabilities structure */
typedef struct auxcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS;
typedef AUXCAPS       *PAUXCAPS;
typedef AUXCAPS NEAR *NPAUXCAPS;
typedef AUXCAPS FAR  *LPAUXCAPS;

/* flags for wTechnology field in AUXCAPS structure */
#define AUXCAPS_CDAUDIO    1       /* audio from internal CD-ROM drive */
#define AUXCAPS_AUXIN      2       /* audio from auxiliary input jacks */

/* flags for dwSupport field in AUXCAPS structure */
#define AUXCAPS_VOLUME          0x0001  /* supports volume control */
#define AUXCAPS_LRVOLUME        0x0002  /* separate left-right volume control */

/* auxiliary audio function prototypes */
UINT WINAPI auxGetNumDevs(void);
UINT WINAPI auxGetDevCaps(UINT uDeviceID, AUXCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI auxGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);

#if defined(WINVER) && (WINVER >= 0x030a)
DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMessage, DWORD dw1, DWORD dw2);
#endif  /* WINVER >= 0x030a */

#endif  /* ifndef MMNOAUX */


#ifndef MMNOTIMER
/****************************************************************************

                            Timer support

****************************************************************************/

/* timer error return values */
#define TIMERR_NOERROR        (0)                  /* no error */
#define TIMERR_NOCANDO        (TIMERR_BASE+1)      /* request not completed */
#define TIMERR_STRUCT         (TIMERR_BASE+33)     /* time struct size */

/* timer data types */
typedef void (CALLBACK TIMECALLBACK) (UINT uTimerID, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef TIMECALLBACK FAR *LPTIMECALLBACK;

/* flags for wFlags parameter of timeSetEvent() function */
#define TIME_ONESHOT    0   /* program timer for single event */
#define TIME_PERIODIC   1   /* program for continuous periodic event */

/* timer device capabilities data structure */
typedef struct timecaps_tag {
    UINT    wPeriodMin;     /* minimum period supported  */
    UINT    wPeriodMax;     /* maximum period supported  */
    } TIMECAPS;
typedef TIMECAPS       *PTIMECAPS;
typedef TIMECAPS NEAR *NPTIMECAPS;
typedef TIMECAPS FAR  *LPTIMECAPS;

/* timer function prototypes */
UINT WINAPI timeGetSystemTime(MMTIME FAR* lpTime, UINT uSize);
DWORD WINAPI timeGetTime(void);
UINT WINAPI timeSetEvent(UINT uDelay, UINT uResolution,
    LPTIMECALLBACK lpFunction, DWORD dwUser, UINT uFlags);
UINT WINAPI timeKillEvent(UINT uTimerID);
UINT WINAPI timeGetDevCaps(TIMECAPS FAR* lpTimeCaps, UINT uSize);
UINT WINAPI timeBeginPeriod(UINT uPeriod);
UINT WINAPI timeEndPeriod(UINT uPeriod);

#endif  /* ifndef MMNOTIMER */


#ifndef MMNOJOY
/****************************************************************************

                            Joystick support

****************************************************************************/

/* joystick error return values */
#define JOYERR_NOERROR        (0)                  /* no error */
#define JOYERR_PARMS          (JOYERR_BASE+5)      /* bad parameters */
#define JOYERR_NOCANDO        (JOYERR_BASE+6)      /* request not completed */
#define JOYERR_UNPLUGGED      (JOYERR_BASE+7)      /* joystick is unplugged */

/* constants used with JOYINFO structure and MM_JOY* messages */
#define JOY_BUTTON1         0x0001
#define JOY_BUTTON2         0x0002
#define JOY_BUTTON3         0x0004
#define JOY_BUTTON4         0x0008
#define JOY_BUTTON1CHG      0x0100
#define JOY_BUTTON2CHG      0x0200
#define JOY_BUTTON3CHG      0x0400
#define JOY_BUTTON4CHG      0x0800

/* joystick ID constants */
#define JOYSTICKID1         0
#define JOYSTICKID2         1

/* joystick device capabilities data structure */
typedef struct joycaps_tag {
    UINT wMid;                  /* manufacturer ID */
    UINT wPid;                  /* product ID */
    char szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT wXmin;                 /* minimum x position value */
    UINT wXmax;                 /* maximum x position value */
    UINT wYmin;                 /* minimum y position value */
    UINT wYmax;                 /* maximum y position value */
    UINT wZmin;                 /* minimum z position value */
    UINT wZmax;                 /* maximum z position value */
    UINT wNumButtons;           /* number of buttons */
    UINT wPeriodMin;            /* minimum message period when captured */
    UINT wPeriodMax;            /* maximum message period when captured */
    } JOYCAPS;
typedef JOYCAPS       *PJOYCAPS;
typedef JOYCAPS NEAR *NPJOYCAPS;
typedef JOYCAPS FAR  *LPJOYCAPS;

/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */
    UINT wYpos;                 /* y position */
    UINT wZpos;                 /* z position */
    UINT wButtons;              /* button states */
    } JOYINFO;
typedef JOYINFO       *PJOYINFO;
typedef JOYINFO NEAR *NPJOYINFO;
typedef JOYINFO FAR  *LPJOYINFO;

/* joystick function prototypes */
UINT WINAPI joyGetDevCaps(UINT uJoyID, JOYCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI joyGetNumDevs(void);
UINT WINAPI joyGetPos(UINT uJoyID, JOYINFO FAR* lpInfo);
UINT WINAPI joyGetThreshold(UINT uJoyID, UINT FAR* lpuThreshold);
UINT WINAPI joyReleaseCapture(UINT uJoyID);
UINT WINAPI joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL bChanged);
UINT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);

#endif  /* ifndef MMNOJOY */


#ifndef MMNOMMIO
/****************************************************************************

                        Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE            256
#define MMIOERR_FILENOTFOUND    (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY     (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN      (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE     (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD      (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE     (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK      (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND    (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND   (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED      (MMIOERR_BASE + 10) /* file is unbuffered */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */
typedef char _huge *    HPSTR;          /* a huge version of LPSTR */
DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMessage,
            LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
        /* general fields */
        DWORD           dwFlags;        /* general status flags */
        FOURCC          fccIOProc;      /* pointer to I/O procedure */
        LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
        UINT            wErrorRet;      /* place for error to be returned */
        HTASK           htask;          /* alternate local task */

        /* fields maintained by MMIO functions during buffered I/O */
        LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
        HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
        HPSTR           pchNext;        /* pointer to next byte to read/write */
        HPSTR           pchEndRead;     /* pointer to last valid byte to read */
        HPSTR           pchEndWrite;    /* pointer to last byte to write */
        LONG            lBufOffset;     /* disk offset of start of buffer */

        /* fields maintained by I/O procedure */
        LONG            lDiskOffset;    /* disk offset of next read or write */
        DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

        /* other fields maintained by MMIO */
        DWORD           dwReserved1;    /* reserved for MMIO use */
        DWORD           dwReserved2;    /* reserved for MMIO use */
        HMMIO           hmmio;          /* handle to open file */
} MMIOINFO;
typedef MMIOINFO       *PMMIOINFO;
typedef MMIOINFO NEAR *NPMMIOINFO;
typedef MMIOINFO FAR  *LPMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
        FOURCC          ckid;           /* chunk ID */
        DWORD           cksize;         /* chunk size */
        FOURCC          fccType;        /* form type or list type */
        DWORD           dwDataOffset;   /* offset of data portion of chunk */
        DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO;
typedef MMCKINFO       *PMMCKINFO;
typedef MMCKINFO NEAR *NPMMCKINFO;
typedef MMCKINFO FAR  *LPMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */


/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */


/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */

#if defined(WINVER) && (WINVER >= 0x030a)
#define MMIOM_RENAME            6       /* rename specified file */
#endif  /* WINVER >= 0x030a */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

/* MMIO function prototypes */
FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc,
    DWORD dwFlags);
HMMIO WINAPI mmioOpen(LPSTR szFileName, MMIOINFO FAR* lpmmioinfo,
    DWORD dwOpenFlags);

#if defined(WINVER) && (WINVER >= 0x030a)
UINT WINAPI mmioRename(LPCSTR szFileName, LPCSTR szNewFileName,
     MMIOINFO FAR* lpmmioinfo, DWORD dwRenameFlags);
#endif  /* WINVER >= 0x030a */

UINT WINAPI mmioClose(HMMIO hmmio, UINT uFlags);
LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
UINT WINAPI mmioGetInfo(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
UINT WINAPI mmioSetInfo(HMMIO hmmio, const MMIOINFO FAR* lpmmioinfo, UINT uFlags);
UINT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT uFlags);
UINT WINAPI mmioFlush(HMMIO hmmio, UINT uFlags);
UINT WINAPI mmioAdvance(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMessage,
    LPARAM lParam1, LPARAM lParam2);
UINT WINAPI mmioDescend(HMMIO hmmio, MMCKINFO FAR* lpck,
    const MMCKINFO FAR* lpckParent, UINT uFlags);
UINT WINAPI mmioAscend(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);
UINT WINAPI mmioCreateChunk(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);

#endif  /* ifndef MMNOMMIO */


#ifndef MMNOMCI
/****************************************************************************

                            MCI support

****************************************************************************/

typedef UINT (CALLBACK *YIELDPROC) (UINT uDeviceID, DWORD dwYieldData);

/* MCI function prototypes */
DWORD WINAPI mciSendCommand (UINT uDeviceID, UINT uMessage,
    DWORD dwParam1, DWORD dwParam2);
DWORD WINAPI mciSendString (LPCSTR lpstrCommand,
    LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
UINT WINAPI mciGetDeviceID (LPCSTR lpstrName);
UINT WINAPI mciGetDeviceIDFromElementID (DWORD dwElementID,
    LPCSTR lpstrType);
BOOL WINAPI mciGetErrorString (DWORD wError, LPSTR lpstrBuffer,
    UINT uLength);
BOOL WINAPI mciSetYieldProc (UINT uDeviceID, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

#if defined(WINVER) && (WINVER >= 0x030a)
HTASK WINAPI mciGetCreatorTask(UINT uDeviceID);
YIELDPROC WINAPI mciGetYieldProc (UINT uDeviceID, DWORD FAR* lpdwYieldData);
#endif  /* WINVER >= 0x030a */

/* If included with the 3.0 windows.h */
#if !defined(WINVER) || (WINVER < 0x030a)
BOOL WINAPI mciExecute (LPCSTR lpstrCommand);
#endif  /* WIN3.0 */

/* MCI error return values */
#define MCIERR_INVALID_DEVICE_ID        (MCIERR_BASE + 1)
#define MCIERR_UNRECOGNIZED_KEYWORD     (MCIERR_BASE + 3)
#define MCIERR_UNRECOGNIZED_COMMAND     (MCIERR_BASE + 5)
#define MCIERR_HARDWARE                 (MCIERR_BASE + 6)
#define MCIERR_INVALID_DEVICE_NAME      (MCIERR_BASE + 7)
#define MCIERR_OUT_OF_MEMORY            (MCIERR_BASE + 8)
#define MCIERR_DEVICE_OPEN              (MCIERR_BASE + 9)
#define MCIERR_CANNOT_LOAD_DRIVER       (MCIERR_BASE + 10)
#define MCIERR_MISSING_COMMAND_STRING   (MCIERR_BASE + 11)
#define MCIERR_PARAM_OVERFLOW           (MCIERR_BASE + 12)
#define MCIERR_MISSING_STRING_ARGUMENT  (MCIERR_BASE + 13)
#define MCIERR_BAD_INTEGER              (MCIERR_BASE + 14)
#define MCIERR_PARSER_INTERNAL          (MCIERR_BASE + 15)
#define MCIERR_DRIVER_INTERNAL          (MCIERR_BASE + 16)
#define MCIERR_MISSING_PARAMETER        (MCIERR_BASE + 17)
#define MCIERR_UNSUPPORTED_FUNCTION     (MCIERR_BASE + 18)
#define MCIERR_FILE_NOT_FOUND           (MCIERR_BASE + 19)
#define MCIERR_DEVICE_NOT_READY         (MCIERR_BASE + 20)
#define MCIERR_INTERNAL                 (MCIERR_BASE + 21)
#define MCIERR_DRIVER                   (MCIERR_BASE + 22)
#define MCIERR_CANNOT_USE_ALL           (MCIERR_BASE + 23)
#define MCIERR_MULTIPLE                 (MCIERR_BASE + 24)
#define MCIERR_EXTENSION_NOT_FOUND      (MCIERR_BASE + 25)
#define MCIERR_OUTOFRANGE               (MCIERR_BASE + 26)
#define MCIERR_FLAGS_NOT_COMPATIBLE     (MCIERR_BASE + 28)
#define MCIERR_FILE_NOT_SAVED           (MCIERR_BASE + 30)
#define MCIERR_DEVICE_TYPE_REQUIRED     (MCIERR_BASE + 31)
#define MCIERR_DEVICE_LOCKED            (MCIERR_BASE + 32)
#define MCIERR_DUPLICATE_ALIAS          (MCIERR_BASE + 33)
#define MCIERR_BAD_CONSTANT             (MCIERR_BASE + 34)
#define MCIERR_MUST_USE_SHAREABLE       (MCIERR_BASE + 35)
#define MCIERR_MISSING_DEVICE_NAME      (MCIERR_BASE + 36)
#define MCIERR_BAD_TIME_FORMAT          (MCIERR_BASE + 37)
#define MCIERR_NO_CLOSING_QUOTE         (MCIERR_BASE + 38)
#define MCIERR_DUPLICATE_FLAGS          (MCIERR_BASE + 39)
#define MCIERR_INVALID_FILE             (MCIERR_BASE + 40)
#define MCIERR_NULL_PARAMETER_BLOCK     (MCIERR_BASE + 41)
#define MCIERR_UNNAMED_RESOURCE         (MCIERR_BASE + 42)
#define MCIERR_NEW_REQUIRES_ALIAS       (MCIERR_BASE + 43)
#define MCIERR_NOTIFY_ON_AUTO_OPEN      (MCIERR_BASE + 44)
#define MCIERR_NO_ELEMENT_ALLOWED       (MCIERR_BASE + 45)
#define MCIERR_NONAPPLICABLE_FUNCTION   (MCIERR_BASE + 46)
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN    (MCIERR_BASE + 47)
#define MCIERR_FILENAME_REQUIRED        (MCIERR_BASE + 48)
#define MCIERR_EXTRA_CHARACTERS         (MCIERR_BASE + 49)
#define MCIERR_DEVICE_NOT_INSTALLED     (MCIERR_BASE + 50)
#define MCIERR_GET_CD                   (MCIERR_BASE + 51)
#define MCIERR_SET_CD                   (MCIERR_BASE + 52)
#define MCIERR_SET_DRIVE                (MCIERR_BASE + 53)
#define MCIERR_DEVICE_LENGTH            (MCIERR_BASE + 54)
#define MCIERR_DEVICE_ORD_LENGTH        (MCIERR_BASE + 55)
#define MCIERR_NO_INTEGER               (MCIERR_BASE + 56)

#define MCIERR_WAVE_OUTPUTSINUSE        (MCIERR_BASE + 64)
#define MCIERR_WAVE_SETOUTPUTINUSE      (MCIERR_BASE + 65)
#define MCIERR_WAVE_INPUTSINUSE         (MCIERR_BASE + 66)
#define MCIERR_WAVE_SETINPUTINUSE       (MCIERR_BASE + 67)
#define MCIERR_WAVE_OUTPUTUNSPECIFIED   (MCIERR_BASE + 68)
#define MCIERR_WAVE_INPUTUNSPECIFIED    (MCIERR_BASE + 69)
#define MCIERR_WAVE_OUTPUTSUNSUITABLE   (MCIERR_BASE + 70)
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE (MCIERR_BASE + 71)
#define MCIERR_WAVE_INPUTSUNSUITABLE    (MCIERR_BASE + 72)
#define MCIERR_WAVE_SETINPUTUNSUITABLE  (MCIERR_BASE + 73)

#define MCIERR_SEQ_DIV_INCOMPATIBLE     (MCIERR_BASE + 80)
#define MCIERR_SEQ_PORT_INUSE           (MCIERR_BASE + 81)
#define MCIERR_SEQ_PORT_NONEXISTENT     (MCIERR_BASE + 82)
#define MCIERR_SEQ_PORT_MAPNODEVICE     (MCIERR_BASE + 83)
#define MCIERR_SEQ_PORT_MISCERROR       (MCIERR_BASE + 84)
#define MCIERR_SEQ_TIMER                (MCIERR_BASE + 85)
#define MCIERR_SEQ_PORTUNSPECIFIED      (MCIERR_BASE + 86)
#define MCIERR_SEQ_NOMIDIPRESENT        (MCIERR_BASE + 87)

#define MCIERR_NO_WINDOW                (MCIERR_BASE + 90)
#define MCIERR_CREATEWINDOW             (MCIERR_BASE + 91)
#define MCIERR_FILE_READ                (MCIERR_BASE + 92)
#define MCIERR_FILE_WRITE               (MCIERR_BASE + 93)

/* all custom device driver errors must be >= than this value */
#define MCIERR_CUSTOM_DRIVER_BASE       (MCIERR_BASE + 256)

/* MCI command message identifiers */
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
#define MCI_SOUND                       0x0812
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856

/* all custom MCI command messages must be >= than this value */
#define MCI_USER_MESSAGES               (0x400 + DRV_MCI_FIRST)


/* device ID for "all devices" */
#define MCI_ALL_DEVICE_ID               0xFFFF

/* constants for predefined MCI device types */
#define MCI_DEVTYPE_VCR                 (MCI_STRING_OFFSET + 1)
#define MCI_DEVTYPE_VIDEODISC           (MCI_STRING_OFFSET + 2)
#define MCI_DEVTYPE_OVERLAY             (MCI_STRING_OFFSET + 3)
#define MCI_DEVTYPE_CD_AUDIO            (MCI_STRING_OFFSET + 4)
#define MCI_DEVTYPE_DAT                 (MCI_STRING_OFFSET + 5)
#define MCI_DEVTYPE_SCANNER             (MCI_STRING_OFFSET + 6)
#define MCI_DEVTYPE_ANIMATION           (MCI_STRING_OFFSET + 7)
#define MCI_DEVTYPE_DIGITAL_VIDEO       (MCI_STRING_OFFSET + 8)
#define MCI_DEVTYPE_OTHER               (MCI_STRING_OFFSET + 9)
#define MCI_DEVTYPE_WAVEFORM_AUDIO      (MCI_STRING_OFFSET + 10)
#define MCI_DEVTYPE_SEQUENCER           (MCI_STRING_OFFSET + 11)

#define MCI_DEVTYPE_FIRST               MCI_DEVTYPE_VCR
#define MCI_DEVTYPE_LAST                MCI_DEVTYPE_SEQUENCER

/* return values for 'status mode' command */
#define MCI_MODE_NOT_READY              (MCI_STRING_OFFSET + 12)
#define MCI_MODE_STOP                   (MCI_STRING_OFFSET + 13)
#define MCI_MODE_PLAY                   (MCI_STRING_OFFSET + 14)
#define MCI_MODE_RECORD                 (MCI_STRING_OFFSET + 15)
#define MCI_MODE_SEEK                   (MCI_STRING_OFFSET + 16)
#define MCI_MODE_PAUSE                  (MCI_STRING_OFFSET + 17)
#define MCI_MODE_OPEN                   (MCI_STRING_OFFSET + 18)

/* constants used in 'set time format' and 'status time format' commands */
#define MCI_FORMAT_MILLISECONDS         0
#define MCI_FORMAT_HMS                  1
#define MCI_FORMAT_MSF                  2
#define MCI_FORMAT_FRAMES               3
#define MCI_FORMAT_SMPTE_24             4
#define MCI_FORMAT_SMPTE_25             5
#define MCI_FORMAT_SMPTE_30             6
#define MCI_FORMAT_SMPTE_30DROP         7
#define MCI_FORMAT_BYTES                8
#define MCI_FORMAT_SAMPLES              9
#define MCI_FORMAT_TMSF                 10

/* MCI time format conversion macros */
#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
                                                  ((WORD)(s)<<8)) | \
                                                 (((DWORD)(BYTE)(f))<<16)))

#define MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
#define MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
#define MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
#define MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

#define MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | \
                                                  ((WORD)(m)<<8)) | \
                                                 (((DWORD)(BYTE)(s) | \
                                                   ((WORD)(f)<<8))<<16)))

#define MCI_HMS_HOUR(hms)               ((BYTE)(hms))
#define MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
#define MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))

#define MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | \
                                                  ((WORD)(m)<<8)) | \
                                                 (((DWORD)(BYTE)(s))<<16)))


/* flags for wParam of MM_MCINOTIFY message */
#define MCI_NOTIFY_SUCCESSFUL           0x0001
#define MCI_NOTIFY_SUPERSEDED           0x0002
#define MCI_NOTIFY_ABORTED              0x0004
#define MCI_NOTIFY_FAILURE              0x0008


/* common flags for dwFlags parameter of MCI command messages */
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OPEN_SHAREABLE              0x00000100L
#define MCI_OPEN_ELEMENT                0x00000200L
#define MCI_OPEN_ALIAS                  0x00000400L
#define MCI_OPEN_ELEMENT_ID             0x00000800L
#define MCI_OPEN_TYPE_ID                0x00001000L
#define MCI_OPEN_TYPE                   0x00002000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_SEEK_TO_START               0x00000100L
#define MCI_SEEK_TO_END                 0x00000200L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_STATUS_ITEM                 0x00000100L
#define MCI_STATUS_START                0x00000200L

/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_STATUS_LENGTH               0x00000001L
#define MCI_STATUS_POSITION             0x00000002L
#define MCI_STATUS_NUMBER_OF_TRACKS     0x00000003L
#define MCI_STATUS_MODE                 0x00000004L
#define MCI_STATUS_MEDIA_PRESENT        0x00000005L
#define MCI_STATUS_TIME_FORMAT          0x00000006L
#define MCI_STATUS_READY                0x00000007L
#define MCI_STATUS_CURRENT_TRACK        0x00000008L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_INFO_PRODUCT                0x00000100L
#define MCI_INFO_FILE                   0x00000200L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_GETDEVCAPS_ITEM             0x00000100L

/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_GETDEVCAPS_CAN_RECORD       0x00000001L
#define MCI_GETDEVCAPS_HAS_AUDIO        0x00000002L
#define MCI_GETDEVCAPS_HAS_VIDEO        0x00000003L
#define MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
#define MCI_GETDEVCAPS_USES_FILES       0x00000005L
#define MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L
#define MCI_GETDEVCAPS_CAN_EJECT        0x00000007L
#define MCI_GETDEVCAPS_CAN_PLAY         0x00000008L
#define MCI_GETDEVCAPS_CAN_SAVE         0x00000009L

/* flags for dwFlags parameter of MCI_SYSINFO command message */
#define MCI_SYSINFO_QUANTITY            0x00000100L
#define MCI_SYSINFO_OPEN                0x00000200L
#define MCI_SYSINFO_NAME                0x00000400L
#define MCI_SYSINFO_INSTALLNAME         0x00000800L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_SET_DOOR_OPEN               0x00000100L
#define MCI_SET_DOOR_CLOSED             0x00000200L
#define MCI_SET_TIME_FORMAT             0x00000400L
#define MCI_SET_AUDIO                   0x00000800L
#define MCI_SET_VIDEO                   0x00001000L
#define MCI_SET_ON                      0x00002000L
#define MCI_SET_OFF                     0x00004000L

/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */
#define MCI_SET_AUDIO_ALL               0x00000000L
#define MCI_SET_AUDIO_LEFT              0x00000001L
#define MCI_SET_AUDIO_RIGHT             0x00000002L

/* flags for dwFlags parameter of MCI_BREAK command message */
#define MCI_BREAK_KEY                   0x00000100L
#define MCI_BREAK_HWND                  0x00000200L
#define MCI_BREAK_OFF                   0x00000400L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_RECORD_INSERT               0x00000100L
#define MCI_RECORD_OVERWRITE            0x00000200L

/* flags for dwFlags parameter of MCI_SOUND command message */
#define MCI_SOUND_NAME                  0x00000100L

/* flags for dwFlags parameter of MCI_SAVE command message */
#define MCI_SAVE_FILE                   0x00000100L

/* flags for dwFlags parameter of MCI_LOAD command message */
#define MCI_LOAD_FILE                   0x00000100L

/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS;
typedef MCI_GENERIC_PARMS FAR *LPMCI_GENERIC_PARMS;

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
} MCI_OPEN_PARMS;
typedef MCI_OPEN_PARMS FAR *LPMCI_OPEN_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS;
typedef MCI_PLAY_PARMS FAR *LPMCI_PLAY_PARMS;

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS;
typedef MCI_SEEK_PARMS FAR *LPMCI_SEEK_PARMS;

/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS;
typedef MCI_STATUS_PARMS FAR * LPMCI_STATUS_PARMS;

/* parameter block for MCI_INFO command message */
typedef struct tagMCI_INFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS;
typedef MCI_INFO_PARMS FAR * LPMCI_INFO_PARMS;

/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS;
typedef MCI_GETDEVCAPS_PARMS FAR * LPMCI_GETDEVCAPS_PARMS;

/* parameter block for MCI_SYSINFO command message */
typedef struct tagMCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
    UINT    wReserved0;
} MCI_SYSINFO_PARMS;
typedef MCI_SYSINFO_PARMS FAR * LPMCI_SYSINFO_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS;
typedef MCI_SET_PARMS FAR *LPMCI_SET_PARMS;

/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;
    int     nVirtKey;
    UINT    wReserved0;
    HWND    hwndBreak;
    UINT    wReserved1;
} MCI_BREAK_PARMS;
typedef MCI_BREAK_PARMS FAR * LPMCI_BREAK_PARMS;

/* parameter block for MCI_SOUND command message */
typedef struct tagMCI_SOUND_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS;
typedef MCI_SOUND_PARMS FAR * LPMCI_SOUND_PARMS;

/* parameter block for MCI_SAVE command message */
typedef struct tagMCI_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_SAVE_PARMS;
typedef MCI_SAVE_PARMS FAR * LPMCI_SAVE_PARMS;

/* parameter block for MCI_LOAD command message */
typedef struct tagMCI_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS;
typedef MCI_LOAD_PARMS FAR * LPMCI_LOAD_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS;
typedef MCI_RECORD_PARMS FAR *LPMCI_RECORD_PARMS;


/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */
#define MCI_VD_MODE_PARK                (MCI_VD_OFFSET + 1)

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */
#define MCI_VD_MEDIA_CLV                (MCI_VD_OFFSET + 2)
#define MCI_VD_MEDIA_CAV                (MCI_VD_OFFSET + 3)
#define MCI_VD_MEDIA_OTHER              (MCI_VD_OFFSET + 4)

#define MCI_VD_FORMAT_TRACK             0x4001

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VD_PLAY_REVERSE             0x00010000L
#define MCI_VD_PLAY_FAST                0x00020000L
#define MCI_VD_PLAY_SPEED               0x00040000L
#define MCI_VD_PLAY_SCAN                0x00080000L
#define MCI_VD_PLAY_SLOW                0x00100000L

/* flag for dwFlags parameter of MCI_SEEK command message */
#define MCI_VD_SEEK_REVERSE             0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VD_STATUS_SPEED             0x00004002L
#define MCI_VD_STATUS_FORWARD           0x00004003L
#define MCI_VD_STATUS_MEDIA_TYPE        0x00004004L
#define MCI_VD_STATUS_SIDE              0x00004005L
#define MCI_VD_STATUS_DISC_SIZE         0x00004006L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_VD_GETDEVCAPS_CLV           0x00010000L
#define MCI_VD_GETDEVCAPS_CAV           0x00020000L

#define MCI_VD_SPIN_UP                  0x00010000L
#define MCI_VD_SPIN_DOWN                0x00020000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VD_GETDEVCAPS_CAN_REVERSE   0x00004002L
#define MCI_VD_GETDEVCAPS_FAST_RATE     0x00004003L
#define MCI_VD_GETDEVCAPS_SLOW_RATE     0x00004004L
#define MCI_VD_GETDEVCAPS_NORMAL_RATE   0x00004005L

/* flags for the dwFlags parameter of MCI_STEP command message */
#define MCI_VD_STEP_FRAMES              0x00010000L
#define MCI_VD_STEP_REVERSE             0x00020000L

/* flag for the MCI_ESCAPE command message */
#define MCI_VD_ESCAPE_STRING            0x00000100L

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
    } MCI_VD_PLAY_PARMS;
typedef MCI_VD_PLAY_PARMS FAR *LPMCI_VD_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS;
typedef MCI_VD_STEP_PARMS FAR *LPMCI_VD_STEP_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS;
typedef MCI_VD_ESCAPE_PARMS FAR *LPMCI_VD_ESCAPE_PARMS;


/* MCI extensions for waveform audio devices */

/* flags for the dwFlags parameter of MCI_OPEN command message */
#define MCI_WAVE_OPEN_BUFFER            0x00010000L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_FORMATTAG          0x00010000L
#define MCI_WAVE_SET_CHANNELS           0x00020000L
#define MCI_WAVE_SET_SAMPLESPERSEC      0x00040000L
#define MCI_WAVE_SET_AVGBYTESPERSEC     0x00080000L
#define MCI_WAVE_SET_BLOCKALIGN         0x00100000L
#define MCI_WAVE_SET_BITSPERSAMPLE      0x00200000L

/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */
#define MCI_WAVE_INPUT                  0x00400000L
#define MCI_WAVE_OUTPUT                 0x00800000L

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_WAVE_STATUS_FORMATTAG       0x00004001L
#define MCI_WAVE_STATUS_CHANNELS        0x00004002L
#define MCI_WAVE_STATUS_SAMPLESPERSEC   0x00004003L
#define MCI_WAVE_STATUS_AVGBYTESPERSEC  0x00004004L
#define MCI_WAVE_STATUS_BLOCKALIGN      0x00004005L
#define MCI_WAVE_STATUS_BITSPERSAMPLE   0x00004006L
#define MCI_WAVE_STATUS_LEVEL           0x00004007L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_ANYINPUT           0x04000000L
#define MCI_WAVE_SET_ANYOUTPUT          0x08000000L

/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_WAVE_GETDEVCAPS_INPUTS      0x00004001L
#define MCI_WAVE_GETDEVCAPS_OUTPUTS     0x00004002L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS;
typedef MCI_WAVE_OPEN_PARMS FAR *LPMCI_WAVE_OPEN_PARMS;

/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS;
typedef MCI_WAVE_DELETE_PARMS FAR *LPMCI_WAVE_DELETE_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    UINT    wInput;
    UINT    wReserved0;
    UINT    wOutput;
    UINT    wReserved1;
    UINT    wFormatTag;
    UINT    wReserved2;
    UINT    nChannels;
    UINT    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    UINT    nBlockAlign;
    UINT    wReserved4;
    UINT    wBitsPerSample;
    UINT    wReserved5;
} MCI_WAVE_SET_PARMS;
typedef MCI_WAVE_SET_PARMS FAR * LPMCI_WAVE_SET_PARMS;


/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */
#define     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */
#define     MCI_SEQ_FORMAT_SONGPTR      0x4001
#define     MCI_SEQ_FILE                0x4002
#define     MCI_SEQ_MIDI                0x4003
#define     MCI_SEQ_SMPTE               0x4004
#define     MCI_SEQ_NONE                65533

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_SEQ_STATUS_TEMPO            0x00004002L
#define MCI_SEQ_STATUS_PORT             0x00004003L
#define MCI_SEQ_STATUS_SLAVE            0x00004007L
#define MCI_SEQ_STATUS_MASTER           0x00004008L
#define MCI_SEQ_STATUS_OFFSET           0x00004009L
#define MCI_SEQ_STATUS_DIVTYPE          0x0000400AL

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_SEQ_SET_TEMPO               0x00010000L
#define MCI_SEQ_SET_PORT                0x00020000L
#define MCI_SEQ_SET_SLAVE               0x00040000L
#define MCI_SEQ_SET_MASTER              0x00080000L
#define MCI_SEQ_SET_OFFSET              0x01000000L

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS;
typedef MCI_SEQ_SET_PARMS FAR * LPMCI_SEQ_SET_PARMS;


/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_ANIM_OPEN_WS                0x00010000L
#define MCI_ANIM_OPEN_PARENT            0x00020000L
#define MCI_ANIM_OPEN_NOSTATIC          0x00040000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_ANIM_PLAY_SPEED             0x00010000L
#define MCI_ANIM_PLAY_REVERSE           0x00020000L
#define MCI_ANIM_PLAY_FAST              0x00040000L
#define MCI_ANIM_PLAY_SLOW              0x00080000L
#define MCI_ANIM_PLAY_SCAN              0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_ANIM_STEP_REVERSE           0x00010000L
#define MCI_ANIM_STEP_FRAMES            0x00020000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_ANIM_STATUS_SPEED           0x00004001L
#define MCI_ANIM_STATUS_FORWARD         0x00004002L
#define MCI_ANIM_STATUS_HWND            0x00004003L
#define MCI_ANIM_STATUS_HPAL            0x00004004L
#define MCI_ANIM_STATUS_STRETCH         0x00004005L

/* flags for the dwFlags parameter of MCI_INFO command message */
#define MCI_ANIM_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_ANIM_GETDEVCAPS_CAN_REVERSE 0x00004001L
#define MCI_ANIM_GETDEVCAPS_FAST_RATE   0x00004002L
#define MCI_ANIM_GETDEVCAPS_SLOW_RATE   0x00004003L
#define MCI_ANIM_GETDEVCAPS_NORMAL_RATE 0x00004004L
#define MCI_ANIM_GETDEVCAPS_PALETTES    0x00004006L
#define MCI_ANIM_GETDEVCAPS_CAN_STRETCH 0x00004007L
#define MCI_ANIM_GETDEVCAPS_MAX_WINDOWS 0x00004008L

/* flags for the MCI_REALIZE command message */
#define MCI_ANIM_REALIZE_NORM           0x00010000L
#define MCI_ANIM_REALIZE_BKGD           0x00020000L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_ANIM_WINDOW_HWND            0x00010000L
#define MCI_ANIM_WINDOW_STATE           0x00040000L
#define MCI_ANIM_WINDOW_TEXT            0x00080000L
#define MCI_ANIM_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_ANIM_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */
#define MCI_ANIM_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_ANIM_RECT                   0x00010000L
#define MCI_ANIM_PUT_SOURCE             0x00020000L
#define MCI_ANIM_PUT_DESTINATION        0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_ANIM_WHERE_SOURCE           0x00020000L
#define MCI_ANIM_WHERE_DESTINATION      0x00040000L

/* flags for dwFlags parameter of MCI_UPDATE command message */
#define MCI_ANIM_UPDATE_HDC             0x00020000L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
    UINT    wReserved1;
} MCI_ANIM_OPEN_PARMS;
typedef MCI_ANIM_OPEN_PARMS FAR *LPMCI_ANIM_OPEN_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS;
typedef MCI_ANIM_PLAY_PARMS FAR *LPMCI_ANIM_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS;
typedef MCI_ANIM_STEP_PARMS FAR *LPMCI_ANIM_STEP_PARMS;

/* parameter block for MCI_WINDOW command message */
typedef struct tagMCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    wReserved1;
    UINT    nCmdShow;
    UINT    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS;
typedef MCI_ANIM_WINDOW_PARMS FAR * LPMCI_ANIM_WINDOW_PARMS;

/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS FAR * LPMCI_ANIM_RECT_PARMS;

/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS;
typedef MCI_ANIM_UPDATE_PARMS FAR * LPMCI_ANIM_UPDATE_PARMS;


/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OVLY_OPEN_WS                0x00010000L
#define MCI_OVLY_OPEN_PARENT            0x00020000L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_OVLY_STATUS_HWND            0x00004001L
#define MCI_OVLY_STATUS_STRETCH         0x00004002L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_OVLY_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_OVLY_GETDEVCAPS_CAN_STRETCH 0x00004001L
#define MCI_OVLY_GETDEVCAPS_CAN_FREEZE  0x00004002L
#define MCI_OVLY_GETDEVCAPS_MAX_WINDOWS 0x00004003L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_OVLY_WINDOW_HWND            0x00010000L
#define MCI_OVLY_WINDOW_STATE           0x00040000L
#define MCI_OVLY_WINDOW_TEXT            0x00080000L
#define MCI_OVLY_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_OVLY_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */
#define MCI_OVLY_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_OVLY_RECT                   0x00010000L
#define MCI_OVLY_PUT_SOURCE             0x00020000L
#define MCI_OVLY_PUT_DESTINATION        0x00040000L
#define MCI_OVLY_PUT_FRAME              0x00080000L
#define MCI_OVLY_PUT_VIDEO              0x00100000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_OVLY_WHERE_SOURCE           0x00020000L
#define MCI_OVLY_WHERE_DESTINATION      0x00040000L
#define MCI_OVLY_WHERE_FRAME            0x00080000L
#define MCI_OVLY_WHERE_VIDEO            0x00100000L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
    UINT    wReserved1;
 } MCI_OVLY_OPEN_PARMS;
typedef MCI_OVLY_OPEN_PARMS FAR *LPMCI_OVLY_OPEN_PARMS;

/* parameter block for MCI_WINDOW command message */
typedef struct tagMCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    wReserved1;
    UINT    nCmdShow;
    UINT    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS;
typedef MCI_OVLY_WINDOW_PARMS FAR * LPMCI_OVLY_WINDOW_PARMS;

/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS;
typedef MCI_OVLY_RECT_PARMS FAR * LPMCI_OVLY_RECT_PARMS;

/* parameter block for MCI_SAVE command message */
typedef struct tagMCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS;
typedef MCI_OVLY_SAVE_PARMS FAR * LPMCI_OVLY_SAVE_PARMS;

/* parameter block for MCI_LOAD command message */
typedef struct tagMCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS;
typedef MCI_OVLY_LOAD_PARMS FAR * LPMCI_OVLY_LOAD_PARMS;

#endif  /* ifndef MMNOMCI */

/****************************************************************************

                        DISPLAY Driver extensions

****************************************************************************/

#ifndef C1_TRANSPARENT
    #define CAPS1           94          /* other caps */
    #define C1_TRANSPARENT  0x0001      /* new raster cap */
    #define NEWTRANSPARENT  3           /* use with SetBkMode() */

    #define QUERYROPSUPPORT 40          /* use to determine ROP support */
#endif  /* ifndef C1_TRANSPARENT */

/****************************************************************************

                        DIB Driver extensions

****************************************************************************/

#define SELECTDIB       41                      /* DIB.DRV select dib escape */
#define DIBINDEX(n)     MAKELONG((n),0x10FF)


/****************************************************************************

                        ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

#ifndef SC_SCREENSAVE

    #define SC_SCREENSAVE   0xF140

#endif  /* ifndef SC_SCREENSAVE */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __MMSYSTEM_H */
PKBGI Stroked Font V1.1 - Aug 3, 1989
Copyright (c) 1987,1988 Borland International
 TSCRKC                             +           B h ~  " >vbLJVt^	j		:

x"b.>4jZvfZ tjx6|&Xp|J^P ~  !p!!.""H##"$$*%%%&&''
(((v))d**0++
,l,,2----N...../1&444B4T4f4v44444444455(565@5N5`5r555555566*6>6P6`6p66666667h7778Z888L9`99 :h::N;;$<<.=F=====>^>>>D???? @B@r@
				#
		
           
                                  

    }     

                          	                         

       	                                         
                                                                                }    	                                             y        y       z                 
                        
    
            
    
         
yz{{z    yz{{z    
    	        
    
    
    
    
            y                yx    
                        |
z                
    
    
                        	                                 
    
    
y                    
           
    ||	        
         
    
         
     	                       
                      		    		}}}}}      		  	  		  		}}}}}}    						}}}}}}}}}}}}						        y    	    yy        	    y	    yy    	    	    		    	         	    		        y        y    	    yy    	    	    	    	y    y	    	    	y    		    	    	    yy    		    	    	        yy    y	    	          
     




 




 


                         }}                           
||     
	    }     
                                          
                     zz            
             		             




 
    // ObjectWindows - (C) Copyright 1991,1992 by Borland International

//
// BWCC.H
//


#if !defined(__BWCC_H)
#define __BWCC_H

#if !defined(WORKSHOP_INVOKED)

#if !defined(__WINDOWS_H)
#include <windows.h>

#endif

#endif

// Purpose:    Borland Windows Custom Controls  (BWCC)

#define BWCCVERSION	0x0102   // version 1.02

// from version 1.02 onward BWCCGetversion returns a DWORD
// The low-order word contains the version number
// and the high-order word contains the locale

#define BWCC_LOCALE_US     1
#define BWCC_LOCALE_JAPAN  2


#define BORDLGCLASS	"BorDlg"	// Our Custom Dialog class
#define BORDLGPROP	"FB"		// Borland dialog window uses
					// this property for instance data
					// users should not use a property
					// with this name!

#define IDHELP		998             // Id of help button

// button style definitions:

// the Borland buttons use Windows button styles for button
// type: i.e. BS_PUSHBUTTON/BS_DEFPUSHBUTTON


#define BUTTON_CLASS	"BorBtn"	// Our Bitmap Buttons
#define RADIO_CLASS	"BorRadio"	// Our Radio Buttons
#define CHECK_CLASS	"BorCheck"	// Our Check Boxes

// styles

#define BBS_BITMAP       0x8000L	// this is a bitmap static
#define BBS_DLGPAINT     0x4000L	// used at runtime by dialog class
#define BBS_PARENTNOTIFY 0x2000L	// Notify parent of TAB keys and focus
#define BBS_OWNERDRAW    0x1000L	// let parent paint via WM_DRAWITEM

// messages

#define BBM_SETBITS       ( BM_SETSTYLE + 10)

// notifications

#define BBN_SETFOCUS      ( BN_DOUBLECLICKED + 10)
#define BBN_SETFOCUSMOUSE ( BN_DOUBLECLICKED + 11)
#define BBN_GOTATAB       ( BN_DOUBLECLICKED + 12)
#define BBN_GOTABTAB      ( BN_DOUBLECLICKED + 13)

#define SHADE_CLASS	"BorShade"

#define BSS_GROUP	1L	// group box
#define BSS_HDIP	2L	// horizontal border
#define BSS_VDIP	3L	// vertical border
#define BSS_HBUMP	4L	// horizontal speed bump
#define BSS_VBUMP	5L	// vertical speed bump

#define BSS_DLGERASE	0x8000L // Dialog Window erases for us
#define BSS_DLGPAINT	0x4000L	// Dialog Window paints for us

#define STATIC_CLASS	"BorStatic"	// Our statics

#if !defined(EXPORT)
#define EXPORT _export
#endif

#if defined( __cplusplus )
extern "C" {
#endif  /* __cplusplus */

extern HGLOBAL FAR EXPORT PASCAL SpecialLoadDialog
(
	HINSTANCE hResMod,
	const   LPSTR   lpResName,
	const   DLGPROC fpDlgProc
);

extern HGLOBAL FAR EXPORT PASCAL MangleDialog
(
	HGLOBAL   hDlg,
	HINSTANCE hResources,
	DLGPROC   fpDialogProc
);

extern LRESULT FAR EXPORT PASCAL BWCCDefDlgProc
(
	HWND   hWnd,
	UINT   message,
	WPARAM wParam,
	LPARAM lParam
);
extern LRESULT FAR EXPORT PASCAL BWCCDefWindowProc
(
	HWND   hWnd,
	UINT   message,
	WPARAM wParam,
	LPARAM lParam
);

extern LRESULT FAR EXPORT PASCAL BWCCDefMDIChildProc
(
	HWND   hWnd,
	UINT   message,
	WPARAM wParam,
	LPARAM lParam
);

extern int FAR EXPORT PASCAL BWCCMessageBox
(
	HWND   hWndParent,
	LPCSTR lpText,
	LPCSTR lpCaption,
	UINT   wType
);

extern HBRUSH FAR EXPORT PASCAL BWCCGetPattern( void );
extern DWORD FAR EXPORT PASCAL BWCCGetVersion( void);

#if defined( __cplusplus )
}
#endif  /* __cplusplus */

#endif  /* __BWCC_H */

/*  generic.h -- for faking generic class declarations

    Copyright (c) 1990, 1992 by Borland International
    All rights reserved

    When type templates are implemented in C++, this will probably go away.
*/

#ifndef __cplusplus
#error Must use C++ for the generic types.
#endif

#ifndef __GENERIC_H
#define __GENERIC_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

// token-pasting macros; ANSI requires an extra level of indirection
#define _Paste2(z, y)       _Paste2_x(z, y)
#define _Paste2_x(z, y)     z##y
#define _Paste3(z, y, x)    _Paste3_x(z, y, x)
#define _Paste3_x(z, y, x)  z##y##x
#define _Paste4(z, y, x, w) _Paste4_x(z, y, x, w)
#define _Paste4_x(z, y, x, w)   z##y##x##w

// macros for declaring and implementing classes
#define name2 _Paste2
#define declare(z, y) _Paste2(z, declare)(y)
#define implement(z, y) _Paste2(z, implement)(y)
#define declare2(z, y, x) _Paste2(z, declare2)(y, x)
#define implement2(z, y, x) _Paste2(z, implement2)(y, x)

// macros for declaring error-handling functions
extern _Cdecl genericerror(int, char _FAR *);    // not implemented ***
typedef int _Cdecl (_FAR *GPT)(int, char _FAR *);
#define set_handler(gen, tp, z) _Paste4(set_, tp, gen, _handler)(z)
#define errorhandler(gen, tp) _Paste3(tp, gen, handler)
#define callerror(gen, tp, z, y) (*errorhandler(gen, tp))(z, y)

/*
 * function genericerror is not documented in the AT&T release, and
 * is not supplied.  If you can document any expected behavior, we
 * will try to adjust our implementation accordingly.
 */

#endif
/*  dos.h

    Defines structs, unions, macros, and functions for dealing
    with MSDOS and the Intel iAPX86 microprocessor family.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/
#ifndef __DOS_H
#define __DOS_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(_RTLDLL)
extern  int _Cdecl  errno;
extern  int _Cdecl  _doserrno;
#else

#ifdef __cplusplus
extern "C" {
#endif
int far * far _Cdecl __getErrno(void);
int far * far _Cdecl __getDOSErrno(void);
#ifdef __cplusplus
}
#endif

#define errno (*__getErrno())
#define _doserrno (*__getDOSErrno())
#endif

#ifndef __DLL__

/* Variables */
extern  int const _Cdecl _8087;
extern  int       _Cdecl _argc;
extern  char    **_Cdecl _argv;
extern  char    **_Cdecl  environ;

extern  unsigned      _Cdecl _psp;
extern  unsigned      _Cdecl _heaplen;
extern  unsigned char _Cdecl _osmajor;
extern  unsigned char _Cdecl _osminor;
extern  unsigned      _Cdecl _stklen;
extern  unsigned      _Cdecl _fpstklen;
extern  unsigned      _Cdecl _version;
extern  unsigned      _Cdecl _osversion;      /* MSC name for _version */

#endif  /* __DLL__*/


#define FA_NORMAL   0x00        /* Normal file, no attributes */
#define FA_RDONLY   0x01        /* Read only attribute */
#define FA_HIDDEN   0x02        /* Hidden file */
#define FA_SYSTEM   0x04        /* System file */
#define FA_LABEL    0x08        /* Volume label */
#define FA_DIREC    0x10        /* Directory */
#define FA_ARCH     0x20        /* Archive */

/* MSC names for file attributes */

#define _A_NORMAL   0x00        /* Normal file, no attributes */
#define _A_RDONLY   0x01        /* Read only attribute */
#define _A_HIDDEN   0x02        /* Hidden file */
#define _A_SYSTEM   0x04        /* System file */
#define _A_VOLID    0x08        /* Volume label */
#define _A_SUBDIR   0x10        /* Directory */
#define _A_ARCH     0x20        /* Archive */

#define NFDS    20          /* Maximum number of fds */

struct  fcb {
    char    fcb_drive;      /* 0 = default, 1 = A, 2 = B */
    char    fcb_name[8];    /* File name */
    char    fcb_ext[3];     /* File extension */
    short   fcb_curblk;     /* Current block number */
    short   fcb_recsize;    /* Logical record size in bytes */
    long    fcb_filsize;    /* File size in bytes */
    short   fcb_date;       /* Date file was last written */
    char    fcb_resv[10];   /* Reserved for DOS */
    char    fcb_currec;     /* Current record in block */
    long    fcb_random;     /* Random record number */
};

struct  xfcb    {
    char        xfcb_flag;  /* Contains 0xff to indicate xfcb */
    char        xfcb_resv[5];/* Reserved for DOS */
    char        xfcb_attr;  /* Search attribute */
    struct  fcb xfcb_fcb;   /* The standard fcb */
};

struct  COUNTRY {
    int co_date;
    char    co_curr[5];
    char    co_thsep[2];
    char    co_desep[2];
    char    co_dtsep[2];
    char    co_tmsep[2];
    char    co_currstyle;
    char    co_digits;
    char    co_time;
    long    co_case;
    char    co_dasep[2];
    char    co_fill[10];
};

#if defined(__MSC) && !defined(__cplusplus)
struct  DOSERROR {
        int     exterror;
        char    class;
        char    action;
        char    locus;
};
#else
struct  DOSERROR {
        int     de_exterror;
        char    de_class;
        char    de_action;
        char    de_locus;
};
#endif  /* __MSC and not C++ */

struct  dfree   {
    unsigned df_avail;
    unsigned df_total;
    unsigned df_bsec;
    unsigned df_sclus;
};

struct diskfree_t {
    unsigned total_clusters;
    unsigned avail_clusters;
    unsigned sectors_per_cluster;
    unsigned bytes_per_sector;
};

struct  fatinfo {
    char     fi_sclus;
    char     fi_fatid;
    unsigned fi_nclus;
    int      fi_bysec;
};

struct  devhdr  {
    long        dh_next;        /* Next device pointer */
    short       dh_attr;        /* Attributes */
    unsigned short  dh_strat;   /* Driver strategy routine */
    unsigned short  dh_inter;   /* Driver interrupt routine */
    char        dh_name[8];     /* Device name */
};

struct  time    {
    unsigned char   ti_min;     /* Minutes */
    unsigned char   ti_hour;    /* Hours */
    unsigned char   ti_hund;    /* Hundredths of seconds */
    unsigned char   ti_sec;     /* Seconds */
};

struct dostime_t {
    unsigned char hour;         /* Hours */
    unsigned char minute;       /* Minutes */
    unsigned char second;       /* Seconds */
    unsigned char hsecond;      /* Hundredths of seconds */
};

struct  date    {
    int     da_year;        /* Year - 1980 */
    char        da_day;     /* Day of the month */
    char        da_mon;     /* Month (1 = Jan) */
};

struct dosdate_t {
    unsigned char day;      /* 1-31 */
    unsigned char month;    /* 1-12 */
    unsigned int  year;     /* 1980 - 2099 */
    unsigned char dayofweek;/* 0 - 6 (0=Sunday) */
};

#ifndef _REG_DEFS
#define _REG_DEFS

struct WORDREGS {
    unsigned int    ax, bx, cx, dx, si, di, cflag, flags;
};

struct BYTEREGS {
    unsigned char   al, ah, bl, bh, cl, ch, dl, dh;
};

union   REGS    {
    struct  WORDREGS x;
    struct  BYTEREGS h;
};

struct  SREGS   {
    unsigned int    es;
    unsigned int    cs;
    unsigned int    ss;
    unsigned int    ds;
};

struct  REGPACK {
    unsigned    r_ax, r_bx, r_cx, r_dx;
    unsigned    r_bp, r_si, r_di, r_ds, r_es, r_flags;
};

#endif  /* _REG_DEFS */

typedef struct {
    char    ds_drive;          /* do not change    */
    char    ds_pattern [13];   /*  these fields,       */
    char    ds_reserved [7];   /*   Microsoft reserved */
    char    ds_attrib;
    short   ds_time;
    short   ds_date;
    long    ds_size;
    char    ds_nameZ [13];     /* result of the search, asciiz */
}   dosSearchInfo;  /* used with DOS functions 4E, 4F   */


#ifndef _FFBLK_DEF
#define _FFBLK_DEF
struct  ffblk   {
    char        ff_reserved[21];
    char        ff_attrib;
    unsigned    ff_ftime;
    unsigned    ff_fdate;
    long        ff_fsize;
    char        ff_name[13];
};
#endif  /* _FFBLK_DEF */

/* The MSC find_t structure corresponds exactly to the ffblk structure */
struct find_t {
    char     reserved[21];      /* Microsoft reserved - do not change */
    char     attrib;            /* attribute byte for matched file */
    unsigned wr_time;           /* time of last write to file */
    unsigned wr_date;           /* date of last write to file */
    long     size;              /* size of file */
    char     name[13];          /* asciiz name of matched file */
};

#ifdef __MSC
#define _find_t find_t
#endif

/* axret values for _hardresume() */

#define _HARDERR_IGNORE 0   /* ignore error */
#define _HARDERR_RETRY  1   /* retry the operation */
#define _HARDERR_ABORT  2   /* abort program */
#define _HARDERR_FAIL   3   /* fail the operation */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0

#ifdef __cplusplus
extern "C" {
#endif

#if !defined( _Windows )
int         _Cdecl absread( int __drive, int __nsects, long __lsect,
                            void _FAR *__buffer );
int         _Cdecl abswrite( int __drive, int __nsects, long __lsect,
                             void _FAR *__buffer );
int         _Cdecl allocmem( unsigned __size, unsigned _FAR *__segp );
#endif

int         _CType _FARFUNC bdos( int __dosfun, unsigned __dosdx, unsigned __dosal );
int         _CType bdosptr( int __dosfun, void _FAR *__argument,
                unsigned __dosal );
struct COUNTRY _FAR *_Cdecl country( int __xcode, struct COUNTRY _FAR *__cp);
void        _Cdecl ctrlbrk( int _Cdecl( *handler )( void ));

#if !defined( _Windows )
void        _CType delay( unsigned __milliseconds );
#endif

void        _Cdecl _FARFUNC disable( void );
int         _Cdecl _FARFUNC dosexterr( struct DOSERROR _FAR *__eblkp );
long        _Cdecl _FARFUNC dostounix( struct date _FAR *__d, struct time _FAR *__t );

unsigned    _Cdecl _dos_allocmem( unsigned __size, unsigned _FAR *__segp );
unsigned    _Cdecl _dos_close ( int __fd );
unsigned    _Cdecl _dos_commit( int __fd );
unsigned    _Cdecl _dos_creat( const char _FAR *__pathP, unsigned __attr,
                int _FAR *__fd );
unsigned    _Cdecl _dos_creatnew( const char _FAR *__pathP, unsigned __attr,
                   int _FAR *__fd );
unsigned    _Cdecl _dos_findfirst( const char _FAR *__path,
                  unsigned __attrib,
                  struct find_t _FAR *__finfo );
unsigned    _Cdecl _dos_findnext( struct find_t _FAR *__finfo );
unsigned    _Cdecl _dos_freemem( unsigned __segx );
void        _Cdecl _dos_getdate( struct dosdate_t _FAR *__datep );
unsigned    _Cdecl _dos_getdiskfree( unsigned __drive,
                      struct diskfree_t _FAR *__dtable);
void        _Cdecl _dos_getdrive( unsigned _FAR *__drive );
unsigned    _Cdecl _dos_getfileattr( const char _FAR *__filename,
                      unsigned _FAR *__attrib );
unsigned    _Cdecl _dos_getftime( int __fd, unsigned _FAR *__date,
                   unsigned _FAR *__time );
void        _Cdecl _dos_gettime( struct dostime_t _FAR *__timep );
void        _Cdecl _dos_keep(unsigned char __status, unsigned __size);
unsigned    _Cdecl _dos_open( const char _FAR *__pathP, unsigned __oflag,
                   int _FAR *__fd );
unsigned    _Cdecl _dos_read( int __fd, void far *__buf, unsigned __len,
                   unsigned _FAR *__nread );
unsigned    _Cdecl _dos_setblock( unsigned __size, unsigned __segx,
                   unsigned _FAR *__maxp );
unsigned    _Cdecl _dos_setdate( struct dosdate_t _FAR *__datep );
void        _Cdecl _dos_setdrive( unsigned __drive, unsigned _FAR *__ndrives );
unsigned    _Cdecl _dos_setfileattr( const char _FAR *__filename,
                      unsigned _FAR __attrib);
unsigned    _Cdecl _dos_setftime( int __fd, unsigned __date, unsigned __time );
unsigned    _Cdecl _dos_settime( struct dostime_t _FAR *__timep );
unsigned    _Cdecl _dos_write( int __fd, const void far *__buf, unsigned __len,
                unsigned _FAR *__nread );

void        __emit__( unsigned char __byte, ...);
void        _Cdecl _FARFUNC enable( void );

#if !defined( _Windows )
int         _Cdecl freemem( unsigned __segx );
#endif

int         _Cdecl getcbrk( void );
void        _CType getdate( struct date _FAR *__datep );
void        _Cdecl getdfree( unsigned char __drive,
                 struct dfree _FAR *__dtable );
int         _Cdecl _getdrive( void );
void        _Cdecl getfat( unsigned char __drive,
               struct fatinfo _FAR *__dtable );
void        _Cdecl getfatd( struct fatinfo _FAR *__dtable );
unsigned    _Cdecl getpsp( void );
int         _Cdecl getswitchar( void );
void        _CType gettime( struct time _FAR *__timep );
int         _Cdecl getverify( void );

#if !defined( _Windows )
#ifdef __cplusplus
void        _Cdecl _harderr( void _Cdecl (far *__fptr)( unsigned __deverr,
                             unsigned __doserr, unsigned far *__hdr) );
#else
void        _Cdecl _harderr( void _Cdecl (far *__fptr)( ) );
#endif
void        _Cdecl _hardresume( int __axret );
void        _Cdecl _hardretn( int __retn );

#ifdef __cplusplus
void        _CType harderr( int _Cdecl( *__handler )( int __errval, int __ax,
                            int __bp, int __si) );
#else
void        _CType harderr( int _Cdecl( *__handler )( ) );
#endif
void        _CType hardresume( int __axret );
void        _CType hardretn( int __retn );
#endif

#ifndef _PORT_DEFS
unsigned        _Cdecl inport ( unsigned __portid );
unsigned char   _Cdecl inportb( unsigned __portid );
unsigned        _Cdecl inpw   ( unsigned __portid );
int             _Cdecl inp    ( unsigned __portid );
#endif

int         _Cdecl int86( int __intno,
                          union REGS _FAR *__inregs,
                          union REGS _FAR *__outregs );
int         _Cdecl int86x( int __intno,
                           union REGS _FAR *__inregs,
                           union REGS _FAR *__outregs,
                           struct SREGS _FAR *__segregs );
int         _Cdecl intdos( union REGS _FAR *__inregs,
                           union REGS _FAR *__outregs );
int         _Cdecl intdosx( union REGS _FAR *__inregs,
                                     union REGS _FAR *__outregs,
                                     struct SREGS _FAR *__segregs );
void        _Cdecl intr( int __intno, struct REGPACK _FAR *__preg );

#if !defined( _Windows )
void        _Cdecl keep( unsigned char __status, unsigned __size );
void        _Cdecl nosound( void );
#endif

#ifndef _PORT_DEFS
void        _Cdecl outport ( unsigned __portid, unsigned __value );
void        _Cdecl outportb( unsigned __portid, unsigned char __value );
unsigned    _Cdecl outpw   ( unsigned __portid, unsigned __value );
int         _Cdecl outp    ( unsigned __portid, int __value );
#endif

char _FAR * _Cdecl parsfnm( const char _FAR *__cmdline,
                       struct fcb _FAR *__fcb, int __opt );
int         _Cdecl peek( unsigned __segment, unsigned __offset );
char        _Cdecl peekb( unsigned __segment, unsigned __offset );
void        _Cdecl poke( unsigned __segment, unsigned __offset, int __value);
void        _Cdecl pokeb( unsigned __segment,
                          unsigned __offset, char __value );

#if !defined( _Windows )
int         _Cdecl randbrd( struct fcb _FAR *__fcb, int __rcnt );
int         _Cdecl randbwr( struct fcb _FAR *__fcb, int __rcnt );
#endif

void        _Cdecl segread( struct SREGS _FAR *__segp );

#if !defined( _Windows )
int         _Cdecl setblock( unsigned __segx, unsigned __newsize );
#endif

int         _Cdecl setcbrk( int __cbrkvalue );
void        _Cdecl setdate( struct date _FAR *__datep );
void        _Cdecl setswitchar( char __ch );
void        _Cdecl settime( struct time _FAR *__timep );
void        _Cdecl setverify( int __value );

#if !defined( _Windows )
void        _Cdecl sleep( unsigned __seconds );
void        _Cdecl sound( unsigned __frequency );
#endif

void        _Cdecl _FARFUNC unixtodos( long __time, struct date _FAR *__d,
                              struct time _FAR *__t );
int         _CType unlink( const char _FAR *__path );

    /* These are in-line functions.  These prototypes just clean up
       some syntax checks and code generation.
     */

void        _Cdecl          __cli__( void );
void        _Cdecl          __sti__( void );
void        _Cdecl          __int__( int __interruptnum );

#define disable( ) __emit__( (char )( 0xfa ) )
#define _disable( ) __emit__( (char )( 0xfa ) ) /* MSC name */
#define enable( )  __emit__( (char )( 0xfb ) )
#define _enable( )  __emit__( (char )( 0xfb ) ) /* MSC name */

#define geninterrupt( i ) __int__( i )      /* Interrupt instruction */

#ifndef _PORT_DEFS
#define _PORT_DEFS

unsigned char   _Cdecl    __inportb__ ( unsigned __portid );
unsigned        _Cdecl    __inportw__ ( unsigned __portid );
unsigned char   _Cdecl    __outportb__( unsigned __portid, unsigned char __value );
unsigned        _Cdecl    __outportw__( unsigned __portid, unsigned __value );

#define inportb(__portid)           __inportb__(__portid)
#define outportb(__portid, __value) ((void) __outportb__(__portid, __value))
#define inport(__portid)            __inportw__(__portid)
#define outport(__portid, __value)  ((void) __outportw__(__portid, __value))

/* MSC-compatible macros for port I/O */
#define inp(__portid)               __inportb__ (__portid)
#define outp(__portid, __value)     __outportb__(__portid, (unsigned char)__value)
#define inpw(__portid)              __inportw__ (__portid)
#define outpw(__portid, __value)    __outportw__(__portid, __value)

#endif  /* _PORT_DEFS */

#if !__STDC__

extern  unsigned    _Cdecl  _ovrbuffer;
int cdecl far _OvrInitEms( unsigned __emsHandle, unsigned __emsFirst,
                           unsigned __emsPages );
int cdecl far _OvrInitExt( unsigned long __extStart,
                           unsigned long __extLength );

char far *cdecl getdta( void );
void      cdecl setdta( char far *__dta );

#define MK_FP( seg,ofs )( (void _seg * )( seg ) +( void near * )( ofs ))
#define FP_SEG( fp )( (unsigned )( void _seg * )( void far * )( fp ))
#define FP_OFF( fp )( (unsigned )( fp ))

#ifdef __cplusplus
void        _Cdecl _chain_intr ( void interrupt (far *__target)( ... ));
void interrupt( far * _Cdecl _dos_getvect( unsigned __interruptno ))( ... );
void interrupt( far * _CType getvect( int __interruptno ))( ... );
void        _Cdecl _dos_setvect( unsigned __interruptno,
                                 void interrupt( far *__isr )( ... ));
void        _CType setvect( int __interruptno,
                            void interrupt( far *__isr )( ... ));
int  inline _Cdecl peek( unsigned __segment, unsigned __offset )
                  { return( *( (int  far* )MK_FP( __segment, __offset )) ); }
char inline _Cdecl peekb( unsigned __segment, unsigned __offset )
                  { return( *( (char far* )MK_FP( __segment, __offset )) ); }
void inline _Cdecl poke( unsigned __segment, unsigned __offset, int __value )
               {( *( (int  far* )MK_FP( __segment, __offset )) = __value ); }
void inline _Cdecl pokeb( unsigned __segment, unsigned __offset, char __value )
               {( *( (char far* )MK_FP( __segment, __offset )) = __value ); }
#else
void        _Cdecl _chain_intr ( void interrupt (far *__target)( ));
void interrupt( far * _Cdecl _dos_getvect( unsigned __interruptno ))( );
void interrupt( far * _CType getvect( int __interruptno ))( );
void        _Cdecl _dos_setvect( unsigned __interruptno,
                void interrupt( far *__isr )( ));
void        _CType setvect( int __interruptno,
                void interrupt( far *__isr )( ) );
#define peek( a,b )( *( (int  far* )MK_FP( (a ),( b )) ))
#define peekb( a,b )( *( (char far* )MK_FP( (a ),( b )) ))
#define poke( a,b,c )( *( (int  far* )MK_FP( (a ),( b )) ) =( int )( c ))
#define pokeb( a,b,c )( *( (char far* )MK_FP( (a ),( b )) ) =( char )( c ))
#endif  /* __cplusplus */

#endif  /* !__STDC__ */


#ifdef __cplusplus
}
#endif

#endif  /* __DOS_H */


 JOC2.CPPO   TC86 Borland C++ 3.1   w  ]m?JOC2.CPP͈"  @C:\BORLANDC\BIN\GRAPHICS.H  @C:\BORLANDC\BIN\_DEFS.Hx   @C:\BORLANDC\BIN\STDLIB.H5  @C:\BORLANDC\BIN\_NULL.H_  @C:\BORLANDC\BIN\STDIO.Hv   @C:\BORLANDC\BIN\_NFILE.H*  @C:\BORLANDC\BIN\CONIO.H  @C:\BORLANDC\BIN\DOS.H"  @C:\BORLANDC\BIN\IOSTREAM.H  @C:\BORLANDC\BIN\MEM.H   @C:\BORLANDC\BIN\STRING.H !  @C:\BORLANDC\BIN\FSTREAM.H      	     ψ  j i     
e
  i ?  
و	    I  numex ;  
و  g opt_2 c_sel c_nsel c_2_2 c_2_1 bkg color nr_cerc tasta_2 y_cerc_2 x_cerc_2 punctaj y_cerc_1 x_cerc_1 ok opt tasta 	errorcode gmode gdriver   
  
    	 ou|R[} 	?EJPU[`fkpsx{sy[	d	m			

$
d
m
t



Ԉ    ˈ  @ostream@$blsh$qpxzc
    ;
    R  _s
  this    Ĉ  this _s
     q   q          ʈ  @ostream@$blsh$qi  _i
  this    È  this _i
     s   s          Ɉ)  %@ostream@$blsh$qpqr7ostream$r7ostream
    4     #  *
    7  _f
  this      this _f
     {   {            w  錈  	{(  _TEXTCODE_DATADATA_BSSBSSDGROUPј (
X H H   @ostream@$blsh$qpxzc e @ostream@$blsh$qi ɰ* %@ostream@$blsh$qpqr7ostream$r7ostream Ś U @ifstream@$bdtr$qv   !ios" .ƈ
       |  "io_state "  ?  $	open_mode "  D5  &seek_dir "  L
  (  !'%  )   -( ! @ios@$bctr$qp9streambuf  +   - ! @ios@$bdtr$qvL  -   - 	!   /   - ! @ios@flags$ql  1   - ! @ios@setf$qll  3   - ! @ios@setf$qli  5   - ! @ios@unsetf$ql  7   - 	!   9   - 	!   ;   - 	!   =   - 	!   ?   - 	!   A   - 	! !  C   - ! @ios@tie$qp7ostreamq  E   - 	! ҈  G   - 	!   I   - 	!   K   - 	!   M   - 	!   O   - 	! ވ  Q   - ! @ios@clear$qi
  S    T   -S 	!   V   - ! ӈ  Y	streambuf .
     O  -!  Z   -X Y @streambuf@$bctr$qv$  \   -X Y @streambuf@$bctr$qpzci!  ^   - Y @streambuf@$bdtr$qvW%  `   -X Y@streambuf@setbuf$qpzci  b   -X 	Y ?&  d   -X Y @streambuf@setbuf$qpzcii  f   - 	Y   h   - 	Y   j   - 	Y   l   - 	Y $  n   - Y @streambuf@sgetn$qpzci'  p   - Y@streambuf@do_sgetn$qpzciq%  r   - Y@streambuf@underflow$qv/  t   - 	Y %  v   - Y@streambuf@pbackfail$qip  x   - 	Y }  z   - 	Y {%  |   - Y @streambuf@sputn$qpxzci(  ~   - Y@streambuf@do_sputn$qpxzci͈%  　   - Y@streambuf@overflow$qi  。   - 	Y .  〄   - Y@streambuf@seekoff$ql8seek_diri%  〆   - Y@streambuf@seekpos$qli!  〈   - Y	@streambuf@sync$qv   《   - Y @streambuf@dbp$qvH  「  a  」   - 	Y ވ  』   - 	Y ܈  】   - 	Y   〓   - 	Y ؈  〕   - 	Y ֈ  〗   - 	Y Ԉ  〙   - 	Y ҈  〛   - 	Y Ј  〝   - 	Y Έ%  〟   - Y @streambuf@setp$qpzct1''  〡   - Y @streambuf@setg$qpzct1t1  〣   - 	Y Ԉ  〥   - 	Y ҈&  〧   - Y @streambuf@setb$qpzct1i  〩   - 	Y Έ  〫   - 	Y Ɉ  〭   - 	Y ǈ'  〯   - Y
@streambuf@doallocate$qv&&  〱   - Y @streambuf@do_snextc$qv,  〳   -X Y @streambuf@$bctr$qr9streambuf,  〵   - Y @streambuf@$basg$qr9streambufx
  X  Y  〷   -X 	!   〹   - ! @ios@bitalloc$qv  〻   - ! @ios@xalloc$qv  〽  4  〾   - ! @ios@iword$qi    4S     - ! @ios@pword$qi&     - ! @ios@sync_with_stdio$qv     - ! @ios@skip$qiV     -( ! @ios@$bctr$qv	%     - ! @ios@init$qp9streambuf;     - ! @ios@setstate$qi     #      Ո         - ! @ios@usersize$qi      -( ! @ios@$bctr$qr3ios|      - ! @ios@$basg$qr3ios   fstreambaseJ .N          %     -   @fstreambase@$bctr$qvy*     -   @fstreambase@$bctr$qpxzciiL%     -   @fstreambase@$bctr$qi)     -   @fstreambase@$bctr$qipzci$     -   @fstreambase@$bdtr$qvƈ(     -   @fstreambase@open$qpxzcii%     -   @fstreambase@attach$qi($     -   @fstreambase@close$qvz(     -   @fstreambase@setbuf$qpzci  filebuf$ .ވ       ["     -  @filebuf@$bctr$qv"     -  @filebuf@$bctr$qiʈ&     -  @filebuf@$bctr$qipzci
&     -  @filebuf@$bctr$qipuci!     -  @filebuf@$bdtr$qv     - 	 m     - 	 k&     -  @filebuf@open$qpxzcii     - 	 "     -  @filebuf@close$qvf#     -  @filebuf@attach$qi$     - @filebuf@overflow$qij%     - @filebuf@underflow$qv      - 	@filebuf@sync$qv-     - @filebuf@seekoff$ql8seek_diri%  	   -X @filebuf@setbuf$qpzci#     -  @filebuf@last_op$qv݈
    ߈         - 	  8%     -   @fstreambase@verify$qiڈ  istream( .         G,     -  @istream@$bctr$qp9streambuf!     -  @istream@$bdtr$qv6     -  %@istream@$bctr$qp9streambufip7ostream&     -  @istream@$bctr$qipzcir,     -  @istream@$bctr$qiip7ostream      -  @istream@ipfx$qi׈      - 	   "   - 	   $   - 	   &  4"  '   -&  @istream@seekg$ql͈+  )   -&  @istream@seekg$ql8seek_dir;!  +   -  @istream@tellg$qvX  -   - 	 %  /   -&  @istream@get$qpzcizcg  1   -& 	 c$  3   -&  @istream@read$qpzci  5   -& 	 _)  7   -&  @istream@getline$qpzcizc  9   -& 	 [,  ;   -&  @istream@get$qr9streambufzc"  =   -&  @istream@get$qruc"  ?   -&  @istream@get$qrzc  A   -  @istream@get$qv   C   - 	   E   - 	 %  G   -&  @istream@putback$qzc[$  I   -&  @istream@ignore$qiï  K   -&  E.  M   -&  @istream@$brsh$qpqr3ios$r3iosN$  O   -&  @istream@$brsh$qpzc  Q   -&  ?$  S   -&  @istream@$brsh$qruc$  U   -&  @istream@$brsh$qrzc#  W   -&  @istream@$brsh$qrsZ#  Y   -&  @istream@$brsh$qrib#  [   -&  @istream@$brsh$qrl]$  ]   -&  @istream@$brsh$qrus݈$  _   -&  @istream@$brsh$qrui$  a   -&  @istream@$brsh$qrul#  c   -&  @istream@$brsh$qrf[#  e   -&  @istream@$brsh$qrd[#  g   -&  @istream@$brsh$qrgV,  i   -&  @istream@$brsh$qp9streambuf"  k   -  @istream@$bctr$qv҈$  m   -  @istream@eatwhite$qv҈"  o   -  @istream@do_get$qv  ifstreamP .         q  d"  r   -q  @ifstream@$bctr$qv'  t   -q  @ifstream@$bctr$qpxzciiS'  v   -q  @ifstream@$bctr$qpxuciiV"  x   -q  @ifstream@$bctr$qi&  z   -q  @ifstream@$bctr$qipzciǈ&  |   -q  @ifstream@$bctr$qipuciʈ!  ~   -  @ifstream@$bdtr$qve  ぀   - 	 ͈  あ   - 	 4  い   - 	 2  ~  @ifstream@$bctr$qpxzcii m  t  @filebuf@openprot {    @endl$qr7ostream 5  う   #  @    _cout M  ostream& .     *  え   -  @ostream@$bctr$qp9streambuf   お   -  @ostream@$bdtr$qv   が   -  @ostream@$bctr$qi#  ぎ   -  @ostream@$bctr$qipzcW  ぐ   - 	 !  げ   - 	 "   ご   -  @ostream@flush$qv?   ざ   -  @ostream@seekp$qlQ)  じ   -  @ostream@seekp$ql8seek_dir   ず   -  @ostream@tellp$qvS  ぜ   - 	 $  ぞ   -  @ostream@write$qpxzcil  だ   - 	 !  ぢ   -  @ostream@$blsh$qzc  つ   -    て   -    と   -     な   -  @ostream@$blsh$qi  ぬ   -     の   -  @ostream@$blsh$ql!  ば   -  @ostream@$blsh$qul  ひ   -    ぴ   -  ވ   ぶ   -  @ostream@$blsh$qg}#  へ   -  @ostream@$blsh$qpxzc  ぺ   -  ؈!  ぼ   -  @ostream@$blsh$qpv*  ま   -  @ostream@$blsh$qp9streambufV4     -  %@ostream@$blsh$qpqr7ostream$r7ostreamc,     -  @ostream@$blsh$qpqr3ios$r3iosۈ"     -  @ostream@do_opfx$qvY"     -  @ostream@do_osfx$qvW      -  @ostream@$bctr$qvc&     -  @ostream@outstr$qpxzct1  ぇostream_withassign& .h          -     -  @ostream_withassign@$bctr$qv,     -  @ostream_withassign@$bdtr$qvЈ    45     -  $@ostream_withassign@$basg$qr7ostreamH7     -  &@ostream_withassign@$basg$qp9streambuft    _cin Ј  istream_withassign( .	   	   Ո    -     -  @istream_withassign@$bctr$qv',     -  @istream_withassign@$bdtr$qv|    45     -  $@istream_withassign@$basg$qr7istream7     -  &@istream_withassign@$basg$qp9streambuf   ; @ostream@outstr$qpxzct1    G-  %@ostream@$blsh$qpqr7ostream$r7ostream   @ostream@$blsh$qpxzc i @ostream@$blsh$ql    c  @ostream@$blsh$qi ٌ @istream@$brsh$qri   Y  @istream@$brsh$qpzc !  O 	 _sound ݈     #     0	 _delay      #     /	 _getch      #     .
 _clrscr {     #      - _rand c     #     , _settextstyle      #    + _setfillstyle Ԉ     #    * 	_setcolor      #    ) _setbkcolor Ĉ     #    ( 
_outtextxy      #    ' _line `     #    & 
_initgraph 8     #    % _graphresult I     #    $ 	_getpixel      #
    # _fillellipse e     #    " _closegraph Ԉ     #    ! _cleardevice      #     
 _circle      #      _main   Z     #          #       #       #       #    iostream, .6       Ɉ    u-     -  @iostream@$bctr$qp9streambuf"     -  @iostream@$bdtr$qvw#     -  @iostream@$bctr$qv  fstreamT .
   
    "     -  @fstream@$bctr$qvn'     -  @fstream@$bctr$qpxzciiA'     -  @fstream@$bctr$qpxuciiD"  	   -  @fstream@$bctr$qiu&     -  @fstream@$bctr$qipzci    y     #  r     #  ֈ     #  Ո     #  k     #  ӈ  ofstreamN .    )   #     -  @ofstream@$bctr$qv(     -  @ofstream@$bctr$qpxzcii(     -  @ofstream@$bctr$qpxucii#     -  @ofstream@$bctr$qi'     -  @ofstream@$bctr$qipzci    E     #  >   iostream_withassign, .X    4    !   ).  "   -!   @iostream_withassign@$bctr$qvՈ-  $   -   @iostream_withassign@$bdtr$qvu2  &   -   !@iostream_withassign@$basg$qr3ios[    4      #  $  (   #    )   #    *   #    +   #    ,   #    -   #    .   #    /   #  H Pfstream 	Pofstream 	Pifstreamq Pfstreambase Pfilebuf Riostream_withassign Piostream_withassign! Rostream_withassign Postream_withassign Ristream_withassign Pistream_withassign 	Piostream Rostream Postream Ristream& Pistream 
PstreambufX Pios( 	streamoff 	streampos 	ptrdiff_t fpos_t wchar_t size_t
 fstream ofstream ifstream fstreambase  filebuf ios_user_union iostream_withassign  ostream_withassign istream_withassign iostream ostream istream 	streambufY ios! 툽 pio_state"p	open_mode$pseek_dir&`@ios@basefield`@ios@adjustfield`@ios@floatfieldJ@ios@$bctr$qp9streambuf)M@ios@$bdtr$qv+H@ios@flags$qv-H@ios@flags$ql/H@ios@setf$qll1H@ios@setf$ql3H@ios@unsetf$ql5H@ios@width$qv7H@ios@width$qi9H@ios@fill$qv;H@ios@fill$qzc=H@ios@precision$qi?H@ios@precision$qvAH@ios@tie$qp7ostreamCH@ios@tie$qvEH@ios@rdstate$qvGH@ios@eof$qvIH@ios@fail$qvKH@ios@bad$qvMH@ios@good$qvOH@ios@clear$qiQK@ios@$opv$qvTH@ios@$bnot$qvVH@ios@rdbuf$qvH@ios@bitalloc$qvH@ios@xalloc$qvH@ios@iword$qiH@ios@pword$qiH@ios@sync_with_stdio$qvH@ios@skip$qi@    bpX x_tie state ispecial ospecial x_flags x_precision x_width x_fill isfx_special osfx_special delbuf assign_privateJ@ios@$bctr$qvH@ios@init$qp9streambufH@ios@setstate$qi`@ios@stdioflush`@ios@nextbit`@ios@usercount 	userwords nwordsH@ios@usersize$qiJ@ios@$bctr$qr3iosH@ios@$basg$qr3ios"   R   @ios@goodbit   @ios@eofbit  @ios@failbit  @ios@badbit @ios@hardfail ,r   @ios@in  @ios@out  @ios@ate  @ios@app  
@ios@trunc  @ios@nocreate   @ios@noreplace@ @ios@binary '   @ios@beg   @ios@cur @ios@end  J@streambuf@$bctr$qvZJ@streambuf@$bctr$qpzci\M@streambuf@$bdtr$qv^L@streambuf@setbuf$qpzci`H@streambuf@setbuf$qpucibH@streambuf@setbuf$qpzciidH@streambuf@sgetc$qvfH@streambuf@snextc$qvhH@streambuf@sbumpc$qvjH@streambuf@stossc$qvlH@streambuf@sgetn$qpzcinL@streambuf@do_sgetn$qpzcipL@streambuf@underflow$qvrH@streambuf@sputbackc$qzctL@streambuf@pbackfail$qivH@streambuf@in_avail$qvxH@streambuf@sputc$qizH@streambuf@sputn$qpxzci|L@streambuf@do_sputn$qpxzci~L@streambuf@overflow$qiH@streambuf@out_waiting$qvL@streambuf@seekoff$ql8seek_diriL@streambuf@seekpos$qliL@streambuf@sync$qvH@streambuf@dbp$qvH@streambuf@base$qvH@streambuf@ebuf$qvH@streambuf@blen$qvH@streambuf@pbase$qvH@streambuf@pptr$qvH@streambuf@epptr$qvH@streambuf@eback$qvH@streambuf@gptr$qvH@streambuf@egptr$qvH@streambuf@setp$qpzct1H@streambuf@setg$qpzct1t1H@streambuf@pbump$qiH@streambuf@gbump$qiH@streambuf@setb$qpzct1iH@streambuf@unbuffered$qiH@streambuf@unbuffered$qvH@streambuf@allocate$qvL@streambuf@doallocate$qv@    alloc_ unbuf_ base_ ebuf_ pbase_ pptr_ epptr_ eback_ gptr_ egptr_H@streambuf@do_snextc$qvJ@streambuf@$bctr$qr9streambufH@streambuf@$basg$qr9streambuf   ?: J@fstreambase@$bctr$qvJ@fstreambase@$bctr$qpxzciiJ@fstreambase@$bctr$qiJ@fstreambase@$bctr$qipzciM@fstreambase@$bdtr$qvH@fstreambase@open$qpxzciiH@fstreambase@attach$qiH@fstreambase@close$qvH@fstreambase@setbuf$qpzciH@fstreambase@rdbuf$qvH@fstreambase@verify$qi@    bufJ   G `@filebuf@openprotJ@filebuf@$bctr$qvJ@filebuf@$bctr$qiJ@filebuf@$bctr$qipzciJ@filebuf@$bctr$qipuciM@filebuf@$bdtr$qvH@filebuf@is_open$qvH@filebuf@fd$qvH@filebuf@open$qpxzciiH@filebuf@open$qpxuciiH@filebuf@close$qvH@filebuf@attach$qiL@filebuf@overflow$qiL@filebuf@underflow$qvL@filebuf@sync$qvL@filebuf@seekoff$ql8seek_diriL@filebuf@setbuf$qpzci	@    xfd mode opened 	last_seek in_startH@filebuf@last_op$qv lahead$   v J@istream@$bctr$qp9streambufM@istream@$bdtr$qvJ%@istream@$bctr$qp9streambufip7ostreamJ@istream@$bctr$qipzciJ@istream@$bctr$qiip7ostreamH@istream@ipfx$qiH@istream@ipfx0$qv H@istream@ipfx1$qv"H@istream@isfx$qv$H@istream@seekg$ql'H@istream@seekg$ql8seek_dir)H@istream@tellg$qv+H@istream@sync$qv-H@istream@get$qpzcizc/H@istream@get$qpucizc1H@istream@read$qpzci3H@istream@read$qpuci5H@istream@getline$qpzcizc7H@istream@getline$qpucizc9H@istream@get$qr9streambufzc;H@istream@get$qruc=H@istream@get$qrzc?H@istream@get$qvAH@istream@peek$qvCH@istream@gcount$qvEH@istream@putback$qzcGH@istream@ignore$qiiIH%@istream@$brsh$qpqr7istream$r7istreamKH@istream@$brsh$qpqr3ios$r3iosMH@istream@$brsh$qpzcOH@istream@$brsh$qpucQH@istream@$brsh$qrucSH@istream@$brsh$qrzcUH@istream@$brsh$qrsWH@istream@$brsh$qriYH@istream@$brsh$qrl[H@istream@$brsh$qrus]H@istream@$brsh$qrui_H@istream@$brsh$qrulaH@istream@$brsh$qrfcH@istream@$brsh$qrdeH@istream@$brsh$qrggH@istream@$brsh$qp9streambufiJ@istream@$bctr$qvkH@istream@eatwhite$qvm@    gcount_H@istream@do_get$qvo(   Z  J@ifstream@$bctr$qvrJ@ifstream@$bctr$qpxzciitJ@ifstream@$bctr$qpxuciivJ@ifstream@$bctr$qixJ@ifstream@$bctr$qipzcizJ@ifstream@$bctr$qipuci|M@ifstream@$bdtr$qv~H@ifstream@rdbuf$qvH@ifstream@open$qpxzciiH@ifstream@open$qpxuciiP   *- J@ostream@$bctr$qp9streambufM@ostream@$bdtr$qvJ@ostream@$bctr$qiJ@ostream@$bctr$qipzcH@ostream@opfx$qvH@ostream@osfx$qvH@ostream@flush$qvH@ostream@seekp$qlH@ostream@seekp$ql8seek_dirH@ostream@tellp$qvH@ostream@put$qzcH@ostream@write$qpxzciH@ostream@write$qpxuciH@ostream@$blsh$qzcH@ostream@$blsh$qucH@ostream@$blsh$qsH@ostream@$blsh$qusH@ostream@$blsh$qiH@ostream@$blsh$quiH@ostream@$blsh$qlH@ostream@$blsh$qulH@ostream@$blsh$qfH@ostream@$blsh$qdH@ostream@$blsh$qgH@ostream@$blsh$qpxzcH@ostream@$blsh$qpxucH@ostream@$blsh$qpvH@ostream@$blsh$qp9streambufH%@ostream@$blsh$qpqr7ostream$r7ostreamH@ostream@$blsh$qpqr3ios$r3iosH@ostream@do_opfx$qvH@ostream@do_osfx$qvJ@ostream@$bctr$qvH@ostream@outstr$qpxzct1&     J@ostream_withassign@$bctr$qvM@ostream_withassign@$bdtr$qvH$@ostream_withassign@$basg$qr7ostreamH&@ostream_withassign@$basg$qp9streambuf&   D  J@istream_withassign@$bctr$qvM@istream_withassign@$bdtr$qvH$@istream_withassign@$basg$qr7istreamH&@istream_withassign@$basg$qp9streambuf(   4T  J@iostream@$bctr$qp9streambufM@iostream@$bdtr$qvJ@iostream@$bctr$qv,   }  J@fstream@$bctr$qvJ@fstream@$bctr$qpxzciiJ@fstream@$bctr$qpxuciiJ@fstream@$bctr$qi	J@fstream@$bctr$qipzciJ@fstream@$bctr$qipuciM@fstream@$bdtr$qvH@fstream@rdbuf$qvH@fstream@open$qpxzciiH@fstream@open$qpxuciiT   ,  J@ofstream@$bctr$qvJ@ofstream@$bctr$qpxzciiJ@ofstream@$bctr$qpxuciiJ@ofstream@$bctr$qiJ@ofstream@$bctr$qipzciJ@ofstream@$bctr$qipuciM@ofstream@$bdtr$qvH@ofstream@rdbuf$qvH@ofstream@open$qpxzciiH@ofstream@open$qpxuciiN     J@iostream_withassign@$bctr$qv"M@iostream_withassign@$bdtr$qv$H!@iostream_withassign@$basg$qr3ios&H'@iostream_withassign@$basg$qp9streambuf,     U VWF    PFPFP        FF  F  F F F F F F	 F 6   P P3PFP  
FPFPFPFPFPFPFP  YYP  YYP  YYP  YYP  YYP  YYv    Y P    Y P3P P    	 P Pd P    vޚ    Y P3P P     P P P    v    Y  P P P    ' PP P    7 PTP P      F:	~HuFHF~PuF@F~ uF ~uF ~t vޚ    Y P3P P    > P Pd P    vޚ    Y P3P P    O P P P    v    YU P P P    \ PP P    l PTP P    ~t vޚ    Y P3P P    s P Pd P    v    Y P3P P     P P P    vޚ    Y P P P    v    Y PP P     PTP P    ~t vޚ    Y P3P P     P Pd P    v    Y P3P P     P P P     P P P    vޚ    Y PP P    v    Y PTP P    ~t vޚ    Y P3P P     P Pd PUVVVǷϰVϥVǙϒVχV{rVf]VLVAV5,VVVVVVVζVƪΡVΐV΅VypV_VKV?6V*!VVVVVVͽVͬVgV_VSJV>5V)"VVVVVVV̶VVVVVVVnVc\&VVԠ    v    Y P3P P     P P P     P P P     PP P    vޚ    YPTP P      F~t~t      v    Y P3P P    F  I    Fڻd 
 P    YPvڸ P    v  YF P  YF
 Fځ~,| P3P3P    vޚ    YP  P  YYxP  P  YY      F       BV   BVvޚ    YF  'F PXPF P P    F Fځ~|F  'PF P PF P    F F؁~X|Ҹ P3P3P    0P P P     P P3P    xP P P     P3P P    PP P    
 PǺ  Pƺ  P    v P    YY
 P
 PF  PF  P      FH v    Y
 PǺ  Pƺ  P    ~HuH~Pu@~KuH~Mu@Ǻ  Pƺ  P    YYFF;Fu,~Hu@~PuH~Ku@~MuH} ~ } ~ vޚ    Y
 PǺ  Pƺ  P    @;FtH;Fu;~t@;FtH;Ft ;vt v P    YY
 P
 P VϲVϒV1VVVVαVΊV{VYVMDV1V%V	VVV͝VzVjV]VMVJVEVA	7T3/)VV VVVVV̵V̤VV̙VVyVmfV[VOFV:1V%VV V.F  PF  P       BV   BVv P    YY
 P
 PF  PF  P    F@F  F~t>    ~t ~t      P3P P    v    YP P P     P3P3P    vޚ    YP P P    &P P P    IP P P    mP,P P    P^P P          ~t ~t      P3P P    v    YP P P    P  P  YY  PF{ PPxPP  P  YYP  YYP  YYP  YYP  YY      ~t ~t      P3P P    F  I    Fڻd 
 P    YPvڸ P    v  Y2 P  YF
 Fځ~,|vޚ    Y P3P3P    P P< P    F  ~ t       PFP  YY3 _^]#VιVVΠVƔ΋V{VdV\VQVF?V(VV	VVVTTTTTŴVTūŧ͟Vœ͌V́VqVZVWVOVC:V.%VVVVVVĿ̸V̭V̝V̆VwVhVAV-V VV۠   OUT.TXT 'ATINGE' CERCUL! START DESPRE AFLA PUNCTAJUL! IESIRE 'ATINGE' CERCUL! START DESPRE AFLA PUNCTAJUL! IESIRE 'ATINGE' CERCUL! START DESPRE AFLA PUNCTAJUL! IESIRE 'ATINGE' CERCUL! START DESPRE AFLA PUNCTAJUL! IESIRE 'ATINGE' CERCUL! START DESPRE AFLA PUNCTAJUL! IESIRE START!!! Introdu numele tau:  1   2   3  4   5   6   7  8   9   10  11 12  13  14 15  16  17 18  19   14  13  12  11 10   9   8  7  6   5   4   3   2   1  Daca nu mai ai nicio posibilitate de a ajunge la cercul galben, apasa 'esc'. DESPRE... Program realizat de Ionica Bizau. Scopul   jocului este  'atingerea' celor doua cercuri folosind tastele directionale, facand un punctaj cat mai mare. AFLA PUNCTAJUL... 




                :        La revedere! Apasa orice tasta pentru iesire.     UVv3PvV   ^]U V
l   UVvFRPV   ^]S Vk   UVvVVY ^]  JOC2.CPP]m?̈       	    %  -  2  7  <  A  Z  s            !  " 	# $ '% <& Q( f+ o, u- |. / 0 1 2 3 5 6 7 8 9 : ; 
< = (> =@ RB [C dD wE F G H I J K L N P Q  R 3S HT QU dV yW X Y Z \ ^ _ ` a b c  d 5e Jf _g hi }o r s t u v x y z { | ~  " + 8 F I N S V Y f s |         5 H ]                7 ? E J P U [ ` f k p s x {          ) 6 D l s y           	 )	 >	 S	 V	 [	 m	 r	 	 	 	 	 	 		



	$

)
A
U
\
t
}


) 




#  C:\BORLANDC\BIN\IOSTREAM.H@  [  \ ] ^     g  h Ĉ    o  p   t/*  dir.h

    Defines structures, macros, and functions for dealing with
    directories and pathnames.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__DIR_H)
#define __DIR_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef _FFBLK_DEF
#define _FFBLK_DEF
struct  ffblk   {
    char        ff_reserved[21];
    char        ff_attrib;
    unsigned    ff_ftime;
    unsigned    ff_fdate;
    long        ff_fsize;
    char        ff_name[13];
};
#endif

#define WILDCARDS 0x01
#define EXTENSION 0x02
#define FILENAME  0x04
#define DIRECTORY 0x08
#define DRIVE     0x10

#define MAXPATH   80
#define MAXDRIVE  3
#define MAXDIR    66
#define MAXFILE   9
#define MAXEXT    5

#ifdef __cplusplus
extern "C" {
#endif

int         _CType chdir( const char _FAR *__path );
int         _CType _FARFUNC findfirst( const char _FAR *__path,
                              struct ffblk _FAR *__ffblk,
                              int __attrib );
int         _CType _FARFUNC findnext( struct ffblk _FAR *__ffblk );
void        _CType _FARFUNC fnmerge( char _FAR *__path,
                            const char _FAR *__drive,
                            const char _FAR *__dir,
                            const char _FAR *__name,
                            const char _FAR *__ext );
int _CType _FARFUNC _fnsplit(const char _FAR *__path,
                            char _FAR *__drive,
                            char _FAR *__dir,
                            char _FAR *__name,
                            char _FAR *__ext );
int _CType _FARFUNC fnsplit( const char _FAR *__path,
                            char _FAR *__drive,
                            char _FAR *__dir,
                            char _FAR *__name,
                            char _FAR *__ext );
int         _Cdecl getcurdir( int __drive, char _FAR *__directory );
char _FAR * _Cdecl _FARFUNC getcwd( char _FAR *__buf, int __buflen );
int         _Cdecl getdisk( void );
int         _Cdecl mkdir( const char _FAR *__path );
char _FAR * _Cdecl _FARFUNC mktemp( char _FAR *__template );
int         _Cdecl rmdir( const char _FAR *__path );
char _FAR * _CType _FARFUNC searchpath( const char _FAR *__file );
int         _Cdecl setdisk( int __drive );
#ifdef __cplusplus
}
#endif

#endif  /* __DIR_H */

/*  assert.h

    assert macro

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

void _Cdecl _FARFUNC __assertfail( char _FAR *__msg,
                                   char _FAR *__cond,
                                   char _FAR *__file,
                                   int __line);

#ifdef  __cplusplus
}
#endif

#undef assert

#ifdef NDEBUG
#  define assert(p)   ((void)0)
#else
#  ifdef _Windows
#    define _ENDL
#  else
#    define _ENDL "\n"
#  endif
#  define assert(p) ((p) ? (void)0 : (void) __assertfail( \
                    "Assertion failed: %s, file %s, line %d" _ENDL, \
                    #p, __FILE__, __LINE__ ) )
#endif
PKBGI Stroked Font V1.1 - Jun 5, 1989
Copyright (c) 1987,1988 Borland International
 LCOM.                             +               4 H   6Bj2FJN >XFZb	`				
&
F
f







,hD .Vj&f
(VnBJF ~2,v.`hDzT\j\&dx8HXXF r"z"""""""""##$#.#8#F#T#b#j#z########$"$6$F$V$f$t$$$$$$$$0%~%%% &`&&&&&<'n''':(((V))))**"*0*X****:+T+j+x+++"

 				
	         
                      		   	       	                    
                                                                                                                  
                                y      y      y      
                                                           y   y                                                               
   
   
   
    |                                           
                              	                       	   y 	   
                       
                 
    
  	               		  		}}}}     		  		  		  		{}}}}}   						}}}}}}}}}}}}						         		   y      	   y	   yy   	   	   		   	   	         		            		   y   	   	   		   	   y	   	   	y   	    			   	y      		   	   	      y   	      	     
    















                                               {       	                            	                  y   
   
   	                   







   /*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef __DDEML_H       /* prevent multiple includes */
#define __DDEML_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* WIN3.0 */

#ifndef DECLARE_HANDLE32
#ifdef STRICT
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ _far* name
#else   /* STRICT */
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */
#endif  /* !DECLARE_HANDLE32 */

#define EXPENTRY    WINAPI

/******** public types ********/

DECLARE_HANDLE32(HCONVLIST);
DECLARE_HANDLE32(HCONV);
DECLARE_HANDLE32(HSZ);
DECLARE_HANDLE32(HDDEDATA);

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR
{
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT
{
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;

/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO
{
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD   hUser;         /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED        0x0001
#define     ST_ADVISE           0x0002
#define     ST_ISLOCAL          0x0004
#define     ST_BLOCKED          0x0008
#define     ST_CLIENT           0x0010
#define     ST_TERMINATED       0x0020
#define     ST_INLIST           0x0040
#define     ST_BLOCKNEXT        0x0080
#define     ST_ISSELF           0x0100

/* DDE constants for wStatus field */

#define DDE_FACK                0x8000
#define DDE_FBUSY               0x4000
#define DDE_FDEFERUPD           0x4000
#define DDE_FACKREQ             0x8000
#define DDE_FRELEASE            0x2000
#define DDE_FREQUESTED          0x1000
#define DDE_FACKRESERVED        0x3ff0
#define DDE_FADVRESERVED        0x3fff
#define DDE_FDATRESERVED        0x4fff
#define DDE_FPOKRESERVED        0xdfff
#define DDE_FAPPSTATUS          0x00ff
#define DDE_FNOTPROCESSED   0x0000

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           -1L

/***** Transaction ID constants *****/

#define     QID_SYNC                -1L

/****** public strings used in DDE ******/

#define SZDDESYS_TOPIC          "System"
#define SZDDESYS_ITEM_TOPICS    "Topics"
#define SZDDESYS_ITEM_SYSITEMS  "SysItems"
#define SZDDESYS_ITEM_RTNMSG    "ReturnMessage"
#define SZDDESYS_ITEM_STATUS    "Status"
#define SZDDESYS_ITEM_FORMATS   "Formats"
#define SZDDESYS_ITEM_HELP      "Help"
#define SZDDE_ITEM_ITEMLIST     "TopicItemList"


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef FNCALLBACK *PFNCALLBACK;

#define     CBR_BLOCK                0xffffffffL

/* DLL registration functions */

UINT    WINAPI DdeInitialize(DWORD FAR* pidInst, PFNCALLBACK pfnCallback,
                DWORD afCmd, DWORD ulRes);

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL


BOOL    WINAPI DdeUninitialize(DWORD idInst);

/* conversation enumeration functions */

HCONVLIST WINAPI DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
            HCONVLIST hConvList, CONVCONTEXT FAR* pCC);
HCONV   WINAPI DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL    WINAPI DdeDisconnectList(HCONVLIST hConvList);

/* conversation control functions */

HCONV   WINAPI DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
            CONVCONTEXT FAR* pCC);
BOOL    WINAPI DdeDisconnect(HCONV hConv);
HCONV   WINAPI DdeReconnect(HCONV hConv);

UINT    WINAPI DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, CONVINFO FAR* pConvInfo);
BOOL    WINAPI DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);

BOOL    WINAPI DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/* app server interface functions */

BOOL    WINAPI DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL    WINAPI DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2

HDDEDATA WINAPI DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/* app client interface functions */

HDDEDATA WINAPI DdeClientTransaction(void FAR* pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, DWORD FAR* pdwResult);

/* data transfer functions */

HDDEDATA WINAPI DdeCreateDataHandle(DWORD idInst, void FAR* pSrc, DWORD cb,
            DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA WINAPI DdeAddData(HDDEDATA hData, void FAR* pSrc, DWORD cb, DWORD cbOff);
DWORD   WINAPI DdeGetData(HDDEDATA hData, void FAR* pDst, DWORD cbMax, DWORD cbOff);
BYTE FAR* WINAPI DdeAccessData(HDDEDATA hData, DWORD FAR* pcbDataSize);
BOOL    WINAPI DdeUnaccessData(HDDEDATA hData);
BOOL    WINAPI DdeFreeDataHandle(HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001



UINT WINAPI DdeGetLastError(DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ     WINAPI DdeCreateStringHandle(DWORD idInst, LPCSTR psz, int iCodePage);
DWORD   WINAPI DdeQueryString(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
BOOL    WINAPI DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL    WINAPI DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int     WINAPI DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);


#ifndef NODDEMLSPY
/* */
/* DDEML public debugging header file info */
/* */

typedef struct tagMONMSGSTRUCT
{
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
} MONMSGSTRUCT;

typedef struct tagMONCBSTRUCT
{
    UINT   cb;
    WORD   wReserved;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
} MONCBSTRUCT;

typedef struct tagMONHSZSTRUCT
{
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WORD   wReserved;
    char   str[1];
} MONHSZSTRUCT;

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4


typedef struct tagMONERRSTRUCT
{
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT;

typedef struct tagMONLINKSTRUCT
{
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT
{
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;
    HCONV   hConvServer;
} MONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __DDEML_H */
/*  bios.h

    Access to bios services.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__BIOS_H)
#define __BIOS_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

/* diskinfo_t structure for _bios_disk() */

struct diskinfo_t {
    unsigned drive, head, track, sector, nsectors;
    void far *buffer;
};

/* cmd values for _bios_disk() */

#define _DISK_RESET     0   /* controller hard reset */
#define _DISK_STATUS    1   /* status of last operation */
#define _DISK_READ      2   /* read sectors */
#define _DISK_WRITE     3   /* write sectors */
#define _DISK_VERIFY    4   /* verify sectors */
#define _DISK_FORMAT    5   /* format track */

/* cmd values for _bios_keybrd() */

#define _KEYBRD_READ            0       /* read key */
#define _NKEYBRD_READ           0x10    /* read key - enhanced */
#define _KEYBRD_READY           1       /* check key ready */
#define _NKEYBRD_READY          0x11    /* check key ready - enhanced */
#define _KEYBRD_SHIFTSTATUS     2       /* get shift status */
#define _NKEYBRD_SHIFTSTATUS    0x12    /* get shift status - enhanced */

/* cmd values for _bios_printer() */

#define _PRINTER_WRITE  0       /* send a byte to printer */
#define _PRINTER_INIT   1       /* initialize printer */
#define _PRINTER_STATUS 2       /* read printer status */

/* cmd values for _bios_serialcom() */

#define _COM_INIT       0       /* set communication parms to a byte */
#define _COM_SEND       1       /* send a byte to port */
#define _COM_RECEIVE    2       /* read character from port */
#define _COM_STATUS     3       /* get status of port */

/* byte values for _COM_INIT cmd of _bios_serialcom() */

#define _COM_CHR7       0x02    /* 7 data bits */
#define _COM_CHR8       0x03    /* 8 data bits */
#define _COM_STOP1      0x00    /* 1 stop bit */
#define _COM_STOP2      0x04    /* 2 stop bits */
#define _COM_NOPARITY   0x00    /* no parity */
#define _COM_EVENPARITY 0x18    /* even parity */
#define _COM_ODDPARITY  0x08    /* odd parity */
#define _COM_110        0x00    /* 110 baud */
#define _COM_150        0x20    /* 150 baud */
#define _COM_300        0x40    /* 300 baud */
#define _COM_600        0x60    /* 600 baud */
#define _COM_1200       0x80    /* 1200 baud */
#define _COM_2400       0xa0    /* 2400 baud */
#define _COM_4800       0xc0    /* 4800 baud */
#define _COM_9600       0xe0    /* 9600 baud */

/* cmd values for _bios_timeofday() */

#define _TIME_GETCLOCK  0   /* get clock count */
#define _TIME_SETCLOCK  1   /* set clock count */

/* register structure definitions for int86(), int86x() */

#ifndef _REG_DEFS
#define _REG_DEFS

struct WORDREGS {
    unsigned int    ax, bx, cx, dx, si, di, cflag, flags;
};

struct BYTEREGS {
    unsigned char   al, ah, bl, bh, cl, ch, dl, dh;
};

union   REGS    {
    struct  WORDREGS x;
    struct  BYTEREGS h;
};

struct  SREGS   {
    unsigned int    es;
    unsigned int    cs;
    unsigned int    ss;
    unsigned int    ds;
};

struct  REGPACK {
    unsigned    r_ax, r_bx, r_cx, r_dx;
    unsigned    r_bp, r_si, r_di, r_ds, r_es, r_flags;
};

#endif  /* _REG_DEFS */

#ifdef __cplusplus
extern "C" {
#endif

/* New MSC-compatible BIOS functions.
 */
unsigned _Cdecl _bios_equiplist(void);
unsigned _Cdecl _bios_disk(unsigned __cmd, struct diskinfo_t _FAR *__dinfo);
unsigned _Cdecl _bios_keybrd(unsigned __cmd);
unsigned _Cdecl _bios_memsize(void);
unsigned _Cdecl _bios_printer(unsigned __cmd, unsigned __port, unsigned __abyte);
unsigned _Cdecl _bios_serialcom(unsigned __cmd, unsigned __port, unsigned __abyte);
unsigned _Cdecl _bios_timeofday(unsigned __cmd, long _FAR *__timeval);

/* Old-style BIOS functions.
 */
int     _Cdecl bioscom(int __cmd, char __abyte, int __port);
int     _Cdecl biosdisk(int __cmd, int __drive, int __head, int __track,
                        int __sector, int __nsects, void _FAR *__buffer);
int     _Cdecl biosequip(void);
int     _Cdecl bioskey(int __cmd);
int     _Cdecl biosmemory(void);
int     _Cdecl biosprint(int __cmd, int __abyte, int __port);
long    _Cdecl biostime(int __cmd, long __newtime);

/* Miscellaneous prototypes for MSC compatibility
 */
int         _Cdecl int86(int __intno,
                         union REGS _FAR *__inregs,
                         union REGS _FAR *__outregs );
int         _Cdecl int86x(int __intno,
                          union REGS _FAR *__inregs,
                          union REGS _FAR *__outregs,
                          struct SREGS _FAR *__segregs );

#ifdef __cplusplus
}
#endif

#endif  /* __BIOS_H */
MZPL J @   -	       >    Pjr                               ]      55H5V555555v55	5	5	55555A5u55:555F5k55555555B55{55535R55555	55G5r555555455585q555j55-55x555                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .0!. , ڣ   .  3؋aC&8ùى   +>8 s >8r(>r"G;r>8 t> u ;w
ډ   +؎JW!_ҋ3.+>vG> r@w> r7X !r*g!r H !r@ HI!r
X  !s   
t@ p &3.
 6 6 6 gP.VW
 _^VW.3/ & F-\t	 / 
_^ËLF! H  5!t v 5!x z 5!| ~ 5!   %ʎں! %t !%x !%| !% !ø ׋;t&?t&O2;sӃ;t&? &t&_&Wô ׋;t&?t&8gr&gӃ;t&? &t&_&Wô@ !ù V . P   U^F   PFPFP	5 P5Y%P PPwYYPYY%P PP`YYPuYY%P/PPIYYP^YY%PqPP2YYPGYY%PPPYYP0YY%PPPYYPYY%P2PPYYPYY%PoPPYYPYY%PPPYYPYY%PPPYYPYY%P5PPYYPYY%PwPPzYYPYY%PPPcYYPxYY%PPPLYYPaYY%P=PP5YYPJYY%PPPYYP3YY%PPPYYPYY%PPPYYPYY%PEPPYYPYYF F F F	 F 6& PP3PFPl/
PPYYFPXPE+YYPPzYYFPXP++YYPP`YYFPXP+YYPPFYYFPXP*YYJPP,YYFPXP*YYPPYYFPXP*YY~uF F F F	 F vPvPvPvPvFP YYP YYP YYP YYP YYP YYP YYP YYP YYvPvPvPvPvPPb YYP YYPV YYP| YYPJ YYPp YYP> YYPd YYP2 YYPX YYPP YYn5 PFP.YY3 ]UVv3PvV85 ^]UVvVVY ^]UVvFRPV71 ^]U>b u bFb3]UvY]UVvubb>b uPfY~ uuhjviY^] U3PPv]U P3Pv]3P P3Pø PP3PyVt^UVWv~
_^] YQ3YQ YQ YQ UVWF
V^Nutite uy
؃ y
ۃ   W33;rw;r+@[ tƋ t؃ _^]  t3[Ssـˀ3[Ssـˀ3UVv|X~W 6ރ06 ^] UVvV^] U D^!% ]U"VW~
^$wXrSFN}~ t-G؃ v+F	+FuNN,
s:F F
_^] U3Pvv
 P PaPj] U^でBF
^NV!rP]UVFFVF]UVvt VVYFu>V uF^]Vt^U^ t P?^NV!rPN]ú ;s+Ǉ  ڱƇpl㉇zB;rՠpP[Yu&n Pn t 3P3PlPKP'Yu&~ P~ t 3P3P|PÊ  '@'U VWF  FP F  FW2I_6GNu/SQRj+jPWvV
uF FP ~jZY[j~~v
t<%t6GNv<%t~3ɉNNNFF2Ћ؀ `sAv. wNЀ wNŀ w~+tV뵃fN 맀 wMF u)N8~6Fsy؃NFou׉FbsʵFU,0wF|F3uFtFNeN fY


F V3҈V~6
FV~6GGvF t6GG~~uu~ u6 NRPWǘPFPSV}  Vv~^67CC^F  t6CC^:Z6 F fN+ϋV; vV~6F~26  vV~F  u6=F6=Fu:P;NvN vV~N} WQ^SR #FPF t	 F
F P:
~F tV~&=-uI+~V&=-tF
tO&~ ~
N}N~^ #F= ufou~ F xtXuN@KKn}F  NF u yK;F@ t0hFbV~'++&<-t< t<+u&CIK08+&6GN+~	˰ Uv~F  u6=F6=FP *FF&F tGG&  v~%
u~P}~ tF_^] GT&vQQQU젬 VJPZVJ] UVW FNZ~
v;s
H~ u;;trsrsrsë_^]
 UFԁ ;s 3	  ]UFV  u r
;s 	  ]UvY]UFRPYY]UVWv~F 
 F
 F FF - ؃w..6v ;F}lNg F]FX u.> t'&FFF@PF@P`RPFP PwVv  F	   F ;F} FF ;F}PPPPPPpNOtVv i F _^] *%**U츿P3PvFP]UVv^F&F:t3< u ^]   UQ@ Y t	tYq<t<uP <t& X<@u׳tA2   <t*  <t<uPx
Xt	> t@]ôpP Y d&&UFJ&:t 83&>v>@s>t 3>@t@ & >t PRPuu 3>u     ]ú @ !' @!> t
  ! V> t
P>Y^U> tF ]UvY]UvY]UvRY]UVW~vWVvv
[u3-F+@FvWV:RPvFFF;v
~ _^]UVW~vWVvv
u3-F+@FWVRPvvFFF;v
~ _^]UVDF^N
!r~ uP]À> t !UVWv~
vVvWzt#vvF+FVR+ƋVRWu3S։~F ;v}
׉vF)v+ƋVRRPvWRPF+F@P~FF;u͸ _^]VW\r;tB  _^9t#wt6 ;6tT G3S;[;twu?u2 ?t\ߋ;t>wu|  Ë6t|\]wÉ__VWDtR r6%= s > tt9s_;uf !  397sk _^P3PP{[[% t	3RPm[[XP3SPb[[=t؉X@[3P3SP;[[=tءGX@X3)7@\uËSPQP[tvVF$[^Ë;w5;uSP[[]+)|Bˋ7كVWU^F
t7t-IЃs ;rwOPeS3[]_^UFP P3Pw]&UFȠ P3[ش  *ЈVF] UVWv~;t	 :rƲ _^] UVW~FFF;u 3Ftvv
fFF;u 3Ft_vvCFQ~ tFPFPe 
^&7F~ tFPFP?Ɗܹ  	
^
&7F
OuV _^]
 UV u> tvv
vvR6vv
vvR]
 UVW^
v~ Ƞ ;w-;w);%;w!9Vw;v~~~~ ~ 3_^] UVvV. B;V~^] U  t*> u ~tFF
FF~t F
 PF PF PF PF
 @PF P`PF PF PF PF P
`PF PF PA`PF PF PF PF P
 F
 @PF PF HPF PF
 PF P
`PF
 PF PF
 PF P
`PF PF P`PF
 PF PF
t>fFn
NvV]    +@  +@UNCFV!rP]UV;r	 PǇ  R Y]U>^!rǇ  3P]UVW~un f9}t^= |)E u
 9E
uF   9E
u8EE
0.E@)5PEE
PEPh;tE uM3_^]UVWF  >lD tVbYFOuF_^]UVWv< }
TB3+ЋD@ u,L
< }	Iـ?
uGJuA?
uGJu_^] UVWv~
VYtGu< ~V|)FVd_  DD
WvvDPu
=u3_^]UVv P33PRDPVFu=u < }tD tW P33PRDPVFu=tP3PvvDPu=u*FVFVVFVV)FVVF^]UVW~vNsF_^]UN<V!rP] U^++Ҵ@!] UVWv~ u% 3PvYYF tx#>ǩu P~u#>t
6 ǀ t3 F t7P P tv3PO} WYvv6}l Vv YY|Z3PWYYF t   t%   P PWt
 tWF t t t PPv|/ t 3ցRF t3 ZЋ㉗_^]UN u
 u V"N
=!rFF% ^㉇FPk]UVWF;r
 PO F@= r^ t3 vvvF@= r^ @uFbNv<t-<tS PFPva[F;u S PPQv^く [+_^]5UVWv~
9tu~v > u|u > ulu < t P33PRVD ttZYdD   DD
~t>v:f"#~ uWYFuuLlFD
D|~uL3_^]UW؎~3H_]U VW~v;>r
 P F@= s3  t P33PRWe @uvVW  でvFFMN^FF<
uFFFx+Ё |'+VPW[ ;tu=F+F1x~ ux+v!VxPW  ;ttŋF+F_^]U^ t P@^NV!rP^く XPx]VW lD tVYOu_^U3PPYY P3PYY P3PYYXFt3Pv
YY Ft3PvsYY Ft3Pv\YY Ft3PvEYY 6XP 
YY6PYY6PYY6PYYP6XYYP6YYP6YY3  PR6 PYt3  PR6]Ã> t P6YY > t P6YY > t P6YY 3PXP	YY3PPLYY3PP@YY3PP4YYø PPYY PPYY PPYY PXPJ
YYUVv
PVYYVY^]UVWv|uD  | u3Q3| tD+D
3tPVWYY=u 3tLYFDD  Ft3_^]UVWvu$ PYtiV4YDD  D  D  D  PYt9 PPWV P PVf P PWV_^]UVWvu$ PYtjVYFDD D  D  D  P[Yt9 PPWVN P PV P PWV_^]UVWv~t1(| tVYYPVWYY3PVYY tVY_^]UVW~} tE% = u } u} u*~u FF PFPu= u WWYuE+E= ~  FuE+ERFPWFPFPVW~t)VE;Er´ PWWYY]E E _^]UVWv~| uu3  t+ t    u @ t  t  tĸ ǀ t  @ t v
Pv=ȃtLD | t 3P33PRQTD|u	|uW|tD+D= ~  3FFPFPVFPFPWVY_^]UVWv~V| t
| t3\t~~  F	3F33PPWVFPFPV&FPFPWV_^]UVWvFVFV| tD+D
3tPt
tx;tL ~
u=D;Dv+D3t()FVD uTB?
un^ 9Tu~
 u3~
u  FPvvti߃TD| uF| t@D+D= ~  F|FPFPVFPFPWV|u|uTD_^]UVWv| u | tD+D
3tXPt
tQ;uӋD+D= ~  F|D+DRFPVtFPFPWV$fD;Dv+D3tS PD;Dv+D3ؙRPt>ރTDtttVttV|u	|u&3_^]UVWv| tD% = uD;Dv+D3t
\  | t | u VWYuD+D= ~  FDFD+D+FPFFPttFFPFFPvVFFPFFPV(tR\ FF P" PtuF3PPD" F# P" P" PVuFF_^]UVWv~uJ PYtGu( ( PYD>@ PY P4YYvv
vVi _^]Ë6G  UVWv~t9DBD P PcYY t3P( PcYY tVhY_^]Ë6GUVvV t% = u| t v
Rv Pt3 P4YY^]UVvv4YY^]UVWv~u( PYt%u  PYDFHD  _^]Ë6G UVWv~u( PuYt*u  P2Y PVtYYDJL_^]Ë6G UVWv~D   t3[ t2t%_G_;Gv__+G3;}	wYuG tV Y u 3_^]UVWv~t*DNP t3P PYY tVY_^]Ë6GUVWv~t3DRT3PVYY t3P P<YY tVAY_^]Ë6GUVWv-_G_;Grw_WY_GD_G_;Grw_WY__ e% uu P4YY_^]UVWv~FPVGYYG uF_^]UVWv~F  F  e u!uG P4YYoG N^3Ҹ
 TPR[Yڃ0 ^N_ t_GG_;Grw[Y__ euVF_^]UVWv~F  F  0|7~!uG P4(YYoG VFPR[Yڃ0 ^N_ t_GG_;GrwY__ 0|7~VF_^]UVWv~F  F  e u"uG P4tYY G et7etW0VF!PR[Yډ^N_ t_GG_;GrwY__ euVF_^]UVWv3PVYYuF  F  _G_;Grw_WY__ Ѓ-u 3+tt9_ t_GG_;Grw(Y__ ЋG%@   tRVYYVF G%    t G%   u0tRV̋_ t_GG_;Grw
Y__ ЃxtXu<_ t_GG_;Grwf
Y__ H0|7RV;F  F  tVF؃ VF^W_^]UVWv~uN PyYtTu, , D(, P.YvF
 Pv PV-
 P( P&YYDVD*XZ_^]UVWv~uN PYtTu, , D(, PYvF
 Pv PV
 P( P YYDVD*XZ_^]Ë6G
 6G  UVWv~tFD\D*^`3P( P YY3PVYY t3P, PDYY tVIY_^]Ë6G6GUVvv4?YY^]UVWv~u& PYt u  PYDbd_^]Ë6GW UVWv~u& PYt*u  PdY PVyYYDfh_^]Ë6GL UVWv~t/DjlV~ Y t3P P4YY tV9Y_^]Ë6GUVWv~t3Dnp3PVYY t3P P
YY tVY_^]Ë6GUVvw_WY=u P4YY^]UVv N3
 PRvvt03
 PRvvPЉVFFuЋ^]UVv NF$0 VFЉVFFuߋ^]UVv~
 trF NF% ^؊ VFЉVFFuً^]UVWv3G%@   t G%    t 
 ؃
u~ |~ s 3F~ tVF؃ VFVF
u7RPFPЋFFu ~ t G%   tupuIG%   t 3FPvvFPЋG%   t4~ t"vvFPyЋG%   tWRV_^]UVWv3G%@   tGG%   t 3FPvvFPFЋG%   tm~ t[G%    t$vvFPЋG%   t/*vvFPuЋFFtG%   tWRV_^]UVW~
 tWYY u0GFG  HFG%
   uUNW_G_;Gr´ Pw_WYY_wG =u P5tYYN}G uMFЋ_G_;Gr´ Pw_WYY_wG =u P5YYG u`G%   tUNW_G_;Gr´ Pw_WYY_wG =u P5YYN}G% `  tW2 Y _^]UVvG u twY 3^]UVvG uG%    tVgYG% @  tPRYPJY^]UVW~
 tWY u~ t	vY3F~ t	vY3FGFG  +F+FFG%
   uUNW_G_;Gr´ Pw_WYY_wG =u P5pYYN}G u%~ tvvw7;Ft P5;YYG u`G%   tUNW_G_;Gr´ Pw_WYY_wG =u P5YYN}G u%~ tvvw;Ft P5YYG u`G%   tUNW_G_;Gr´ Pw_WYY_wG =u P5BYYN}G% `  tWY _^]UVv PYuT DD  ^]UVvu PYt6D  D  D  D
  D  D  D  D  D  D  ^]UVvVWY=u\ ^]UVW~E;Ev+E3F~ ~)Puv߃FFFE^FFFF;F}+E;ErWWY=u
]E F=uF_^]UVW~E+EF~ ~Pvu2߃FFFEFF;F}3^FЋE;Er´ PWWYY]E =uF_^]UVWv~t| ttMY tVBY_^]UF]UF]UVvV3PFPRV ^]UVWv~| t| t9|ttY|t~ t
9~rFǉDu 3D~
 t	t 3D_^]UVv^VN
ttDTtt;rD^]UVvVNDD
tt;rD^]UF]UVvv
3PvvVW
^]UVWvV~D+D;|WRtW݃~FDWRVW
_^]UVvD;Dv+D3u| tD+D
3u3^]UVvD;Dv	\ 	DD^]UVvF% T DD% DDD
% DD
^]UVvu" PYt	D  ^]UVWv~t| ttY tVY_^]UVvD   3D
DD D  D 3DDD  D  FD^]UVvDTFVFV##t!T!DFV##t!T!DFV##t!T!DFV	T	DD%   tL dVF^]UVvV% 	D%	D%	D
^]UVWv|tWYFD~ tL L
 
dd
_^]         UVW~j
j
 Nǻ
 303u_^] UVWv~"uV
F_^] UVWv
~ND&*E_^]
 UVv&
t<ar	<z$_&F^] UW~2Oǌ_] UVW~vt"uOv"uOǌ_^] UV	!] Uk
>!]UWV
 =!s+k
33ҸB!r#t	#u=vF~3_]
 Uk
3ɋV
 B!rk
NV?!r3	 ] UVWVWv~N_^_^]UV؋vF  F  ރv .^F ^F
 ^F' ^FF^F ^Fe^F ^F ^F ^F~^F0^Fj^F`^F9V^FHL^F[^F:^Fo0^F&^F^F^FV`^FFFt%m
PvvvvRPPgڸm
m
PvvR^]ˊvlZPF<2(ULLء	F	  ]U>!	 tPP  Y]Uv4  Ytu
;u33^&&W H]UVv^&&GttV&w&7(  ^&G  &  ^]UVWv
^&7% &)VƱЃtNڎ33_^]
 UV؋FV FV>!	u ^&?pktz^&r&vd3WF vPƺ i	P Pu5vvvv^&w=Pƻ RXx	Xv		  F;6^	|	^]U
VW^&?PKt		 ~~F^&r&
v^&G&WFVF  eDT
;Fu;VtF~r~u-cF= r뉡c ecFVDT
tVD    vvvv^&w2TDD  F@_^]ULLV؋vaF>!	 u s	6aF^]U^&  ^CwZ.Y^& Y^& O^& E^& ^& 1^&  '^& ^&^&^&]9F/%%Uvv
vv^&? }	&	]U))    	  	   	    	  	  G  G  G  G(  G&  G*  G  
		%	  !	  ]UdVv^&  FPvvvv
\FPvvV	>	 u32FP33PRvv
+FPvvVg	>	 u͸ ^] UVvPƺ `	PKPƺ ؋x	v	t 	    	   vvP	PPt3 6	P't	3P6	6 	6t6 	6YY;t	6	P뙋ƺ ؋x	v	V ^] UVW؃>!	 uq Pww3PPe
.VFVWvC	 _^C	P1YY= t3P
Y	 PYP
Pr	P P	YY P3PPI P3PPI P3PYY3PY3PPYY_^]UVWF  && £  ^&? u_KF ؋r	t	t4F r	F~ |FF ^&^
F&FF;^	}	^&? tvv
vvP^&? }	&N^
&FFu BPvv> t-P	VF^&:t&\t&\F^& ^&? ~	&% 6Pu^	&qVW	E 2_^6aPGt 	^&6	PX%  		aa	> tP
PYY P		PRP
P YY> t 	s		
	' !		  _^]UVWvvHVF
^& N^&? uF;Fsvv63<vvƺ `	P Puƺ V^
t	r	
 dF;6^	|>^	
|	N^	 `	Pvv^	 i	Pvvu^	 V^
t	r	^	^		 _^]UVvvHVF
^& N^&? uF;FsvvI3#vvƺ oP Pu@;F;6c|׃>c|	%^GPc RXZqocc^]UV؋v>!	tp;6	~	bt    6VY P		PRP
	
	'^]Uؠ u	]Uؐfu)]UVWؠ u		  6a	P 	t%6	P Ǉx	  Ǉv	  3e3|
 t)| t#tVD    D  D  D  Gr_^]Uؐ3PPYY]UVW؋v~|"|G;F
rG;Fr
9v
|9~}	86'	>)	F
+	F-	F/	FPvv
WV	
3PP YY_^]Uvv'	P
   ]Uء9	7	FV3PP\YY-	+)	P+	+'	P3PPy~uv;	PvvYY3PP YY]UVW؋v~WVYY6	>	_^]Uء	FP	FPYY]Uء	]Uء	]U؋G]U؋G]U؃>!	t33 i	]U
PvYRP'ڸ
]UVW؋v~WV
YYWVYY_^]UVW؋v~	P	P
YY	P	PYY_^]Uvv1	P   ]UVW؋v~
wv	61	F3	>5	WvV_^]UVW؋v~Wv
WV,
vv
Wv

vVvv

WVvV	_^]U^9	7	&G&]UVW؋v~v	67	>9	WVYY_^]UVWVW;	~ _^_^]UVWؐ;F
s	37	 F
9	VW؎v;	 _^v
vvo_^]U
	RP^3ɡ	r  RP  ] UV؋vVPVvv
vv	^]UV؋v
VPVhP3Pvv	^]U^	&^

	&]U؋F	F
	]UV؋vV@PVvv
vv	^]U؃~w(F	~ uD	 
^D	D	D	PZ
Y]Uؠ	 ]Uؠ	 ]UVW؋FVFV>!	 u|^&?v ^& FF  !^^&~^^&G^D	FF;Fr^&t	 VWC	~ _^#	FFP	YY_^]UV؋v>!	 t+C	 H;r!~ |FD	u	 vV	YY^]UvvC	P   ]UVvv
vv^u	^]UVW؋~^
&F&wvGV)	+;vvv'	F;Gw;'	|3r/F)	|&^
&wvvv
vW
^
F&G_^]UvvT	P
   ]Uvv6	6	J	>Z	 u%>V	 u6	vv	YY	RYY]UVW؋v~|	|~	6Z	>\	WVYY_^]UVW؋vuu|;6c~		j;6T	uhƺ V;6%	u7%	H ؃m t:%	H eF^wvW^G    G  G  G  EEt P
 PPPJPPFPPt>	t 	 F PFPtB	 FVFF  3PvvvetF PFPTvvYY;tF PFPk'FVEF E6%	EU			3F
 6T	FV	F
X	v
vVH_^]Uvv
vvuX	  ]Uؐ]Sˀ>_u7>u_ ô_@  &`>Xt>Xt$ &U.VW _^]_U.VW3.Y>XuW^& u2  		_^]U.VWF^N
V~ u̀8 _^]U.VW'F<
sW6]6[lXX[ _^]U.VW>_t# >t@  `&2___^]U.VWF2P2 &_!_^]U.VWF2P2 &_
Xy_^]U.VWF2P2 &__^]U.VWf
&		 	^  _^]U.VWfF* _^]U.VWF
+Fy@ P2 &_[N+NyA r#t3_^]U.VWVW Y
~
&X"u_ V/~&W~
&"x$
*s2.3!Y.!V~2&_^]U.VW6V	 V_^]U]~X2<u&2W~
&U.VW^[] _^]U.VW _^]U.VWF^ _^]U.VWF^
 _^]U.VWF^N
V _^]U.VWN^  _^]U.VWN^  _^]U.VWF^N
V _^]U.VWF^N
V;r;sQR [XNV2 _^]U.VWF^ F
^NV _^]U.VWF^ F
^   hN
V _^]U.VWF^ F
^NV _^]U.VW ~ _^]U.VWF	&	 _^]U.VW2: _^]U.VW2: _^]U.VW: _^]U.VWN  @_^]U.VW  H_^]U.VW^2 _^]U.VWF̀^N
V _^]U.VWF2^ _^]U.VW^C _^]U.VWF	^N
Z2" _^]U.VWF^N
6[&|&T&|ՎWU, [XӋ_^]U.VWf&		 F	  _^]U.VWF^ ^
2+I& _^]U.VW	&_V
Ȋ؊Ff"t>	&}t
2ً	$ _^]U.VWF^N
V̀$ _^]U.VW^2+I( _^]M U.VW S ( _^]U.VWF^. 2_^]U.VWF^V
0 _^]U.VW^NVv
~;r;r+&7+&4 _^]U.VW^
NVF6 _^]                  VXW $ Xt2.!V.%!W.3!Yô<t1 sXQ sj #tX
X sX+ r "tXþ 3&&&;uXø }Xt03 r*"t&X4 r û9 &?Z4u&49uX	XÀr	sø <utt
rw2ú2$ $:tÀ
s2ù $0<uðð33Ҵ0tًڊG
t<ut 3                 z                            V ^..p    _  [ Rqz    *RI gg                                    '               d d         ^^P      ;r;r#x#x   X"y X3؋}      L  Ë PS7[X p y% @s, p <u	x &Z !s   ?s=t6 6 p  
	>  t>o  t&؋È&"t  |  p r o 3p t v S>p Hȫ.6t &} .6t & } .6t 
&4@  .6t &4@ [DPSQR&G@@&G&G3ҹ &_x z ZY[Xp     p ã ã   p <u ã 2  2    " p â                                               & d$ (  "     P#t;ǭuXXˡ 
. .r  p    PS
 [X ^rQRȋӇ  ZY9s p ã                                                 CAGWOW
OG GG   p r> ss p 4 +yߋ+y;> s++ ++ PSQRW_ZY[X               <r2AFk    2CPSQ3Y_ C #uX" t&&_  F >  tH}- X( ;s= r  p  ø  Á>  r> t  >;r r6 6+ 5 u"t #uWQY_#uޏ 
 WQY_û &GG&GGI À> tn>t> u6 6s0 p ;u;u>t2    >;>s6&Sx &[QR   r	 p S[PXS[PXZYt?Rы>  t_#uO W+PX+S[_#t   p áiS^[PS[X+LSPX[+S6[-;|;}@IKB4      D> s > u>  r/PS2 " p 3[Xv   " p \ 6 6PS6 3W> 6WVWVO>  t > u>  r3҈PS3ҹZ 3= r [X;tSPZ GXS3;Ük tX[3;ÜY t  > tPSv[XegÉP XË>  tZ Z+> #u 6 6QR6 WVSSPP X X X ^^666PM;u;u> ^s!
> s À> u +&&_   - r> u_ _ ЋË ËȋQRh3R;t3ҋX;rZY+ ح+ Ⱦëë;rh;r>  tZ ZSPPPNXTء XX[@;~PS3[X&&_            >  r= r&N^F؉^6 s *s XX FFF  .  F~rF^;^uF  FF;F|F  ^CCFʀt;|;|;}SQ ; Y[Հu
uËwO;|·׋+tF++ËЋvF;Fs"F#tH@;|	HuFF ^CCCCu<t;F}F;F|Fދv3N&PVU  ^u ! ]^X@;Fr    >c t Ã>c t ȋӇ;r> u p      Z  

Z
    
        c   xO> u22F2F. F2>  t> t   p   2        U*FrF F
^FڋF^	F ;FFFFuFFuFF^;wd 
s F܉Vދ^FV3FFFF܋Vދ^^FVs s +FVމFV։~v r F^F^F^;^|
u;Fr o F;F|uF;Fr 2 F^F^;^
u;Fw8 W F tы]X FFFFFFF+FFFFFFFFFFFFFFFFNF)FFFF+FFFFFËVv~F u7VWƋߋȋ _^VWߋƋߋȋ _^F^NVUq] 	  ދƋ* ~ u;F|;F~;F};F~WVv~J ^_
x
x+؋p
x++t3ɇʑËȋrËƋ>o  u$P2 p &X>o  u2 p &_ S      ;w'a:l !H#l%')+-/2468:<> @ACEGjI<KMNPFRSUKWXZ\]_`bycd9fghjYklmnoqrsttuvwGxyyhz
{{2||3}}~l~~L U FZU   F} 3ҹh= ~-  =Z ~ !3Ѐ>  t
Ѓ   ]                           ssãTVXZ( >  tTVXZø؋ȋ  ûT X 
uáX+TpԣPZ+VpȣRT X 
u"t  "u  >P uV; } V ;V}Vv>R uT; } T ;T}TQT; } P T: ;T}
P T'V; } Pb V ;V}PO V"u/ 12ҋ; }; ~G; }; ~áTXTVZV+V.P>RT+T.R>PV > ;};|H> ;~;<> ;};|0> ;~;$> 6   > 6 
  ;};~; w; w; |; |;|;|                    2S[;À>o  u $ p "y(>o  uPSQR$ p 
 ZY[Xã       >| t"tJ> t >  tT >  tFu 3Ҁ>o  u$ p    
r
 ㋟22á S؀> uO XS؀> uh X  p À> u #yÊ2>|  u
>  tA& p á>t> t2&>uH+á>u	2&>t>u+                 +                               >| t&:t'SQ Y[rã3ۉ#u$#u@#u@1> u ';s#uCF á#u  6 >+tÎ3&<+uà*2P&6X&6	 SQ >3&C.*.:s2s&6Y[    *:r2>߃&?>> tw_Y W2IQv .:u"t_  ȋӇ&GG2ŀttW3_W2_ Xq 3 ۀ>  tؓ l " P 0 X3$2$@tJˀËttËttÀ>tTR6 SG Q2 H> t Y[&"tSQ`Y[CXP> t  Q 5 Yá> t > t>uH>  t) á> u> t>u>  t  P $&:u"XtX  s p           Borland C++ - Copyright 1991 Borland Intl. Null pointer assignment
Divide error
Abnormal program termination
                                                   ***************************************************************** ***         CIRCLE TOUCH   - SETUP          ***      COLORS     * ***    Created by Ionica Bizau              ***  0 - BLACK      * ***                 2011                    ***  1 - BLUE       * ***********************************************  2 - GREEN      * *   1.Background                              *  3 - CYAN 	* *   2.Circle color 2-1                        *  4 - RED  	* *   3.Circle color 2-2                        *  5 - MAGNETA    * *   4.     Unselected menu option color       *  6 - BROWN      * *   5.     Selected menu option color         *  7 - LIGHTGRAY  * *   6.Reset settings                          *  8 - DARKGRAY   * *                                             *  9 - LIGHTBLUE  * *                                             *  10 - LIGHTGREEN* *                                             *  11 - LIGHTCYAN * *                                             *  12 - LIGHTRED  * *                                             *  13 - LIGHTMAGN.* *                                             *  14 - YELLOW    * *                                             *  15 - WHITE     * ***************************************************************** OUT.TXT     Enter the background color (0-15):     Enter the untouched circle color (0-15):     Enter the touched circle color (0-15):           Enter the unselected menu options' color (0-15):          Enter the selected menu option color (0-15):  Daca vrei sa revii la setarile initiala apasa 1:          
         
        Settings were saved successfully. Bye! "5                                                                                                         
           TRIP           LITT           SANS           GOTH           SCRI           SIMP           TSCR           LCOM           EURO           BOLD                                                                                                                                                       )5)5                                                                                                                                                                                                CGA      CGA              EGAVGA   EGAVGA           IBM8514  IBM8514          HERC     HERC             ATT      ATT              PC3270   PC3270                                                                                                                   xxxx     No Error                                                                                            Bad Mode                                No error (BGI) graphics not installed Graphics hardware not detected Device driver file not found ( Invalid device driver file ( Not enough memory to load driver Out of memory in scan fill Out of memory in flood fill Font file not found ( Not enough memory to load font Invalid graphics mode for selected driver Graphics error Graphics I/O error Invalid font file ( Invalid font number Invalid Printer Initialize Printer Module Not Linked Invalid File Version Number Graphics error ( ) 
BGI Error: Not in graphics mode

$ 
BGI Error: Graphics not initialized (use 'initgraph')

$ .BGI .CHR                        !!!!!                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                                                                                                    	          l  
         |             C           B                                                                                                                                                                                                                                                          ```                               @     ),(((((),(((),#,*((((**#(#%(  (null)   	

                  COMPAQ print scanf : floating point formats not linked
             &(m>+?>&p)@*=&(m>+?>&p)@*=&(m>+?>&p)@*=.-$-.-z-/8.[/./Q/[//@565,5@555g666]6g66660123456789abcdef0123456789ABCDEF- + 0X 0x 0 0X 0x 0 + q??m>MA?>?@@A=q??m>MA?>?@@A=Ap              A I
      C#    $   \$    $                                                                                                                                                                                                                                                                                                                                                                            R+  8d    ;    P                       '                                       _      r                     	      
          Et   M   7                 7      F      X      f      r      r                                                                !      "      #      $      %   S   &   V   '   V   (   t   )   w   *   w   +      ,      -      .      /   n	   0   	   1   	   2   	   3   
   4   
   5   I
   6   
   7      8      9      :   P   ;   r   <      =      >      ?      @   @   A      B      C "    D      E      F      G      H      I   (   J   4   K   B   L      M      N      O   #   P      Q      R      S   7   T   J   U   z   V      W   -   X      Y      Z      [      \      ]      ^      _      `   &   a      b   K   c      d      e   .    f       g       h   !   i   !   j   "   k   #   l   "#   m   \$   n n%   o   .%   p   %   q   .&   r   &   s   &   t   '   u   (   v   p)   w   *   x   +   y   ,   z   .-   {   -   |   -   }   -   ~   B.      .      /      [/      /    20      2    \>4      4    f@5      5      5      6      g6      6      7    ;7      9      9      V;      };    W;      =      =      K>      m>      >      q?      ?      ?      ?      ?      ;@      w@      @      @      @      A      MA      qA      A      A      A      9B      B      C      x5    5    5    )5    5    5    5    5    q5    5    	5    5    5    5    5    <5    n5  ! 5    35    5    5    ?5    f5    5    5    5    5    5    5    5    ;5    v5    5    5    .5    K5    5    5    5    A5    m5    5    5   5    5    5    *5    5    5    25    g5    5    5    c5    5    s5    5    5    5    5    
5    N5    z5    5    5    5    85    [5    5    5    5    m5    5    5    5    5     5    C5    c5    5    5    5    5    T5    5   5   5   5   5   !5   B5   ^5   }5 	  5 
  5   5   5   K5   {5   5    5   ( 5   U 5   v 5    5    5    5   "5        t    x    |                       !    "    #    $    %    &    '    (    )    *    +    ,    -    .    /   0   1   2   3  	 4  	 5  	 6  	 7  	 8  	 9  	 :  	 ;  	 <  #	 =  b >  d ?  f @  h A  j B  l C   D   E   F   G   H   I   J  8 K   L   M   N   O   P   Q   R   S & T   U   V   W   X   Y   Z   [   \  V ]zX ^o _   `   a   b   c   d   g   h   i   j   k   l   m   n   o   p    
q    q    p    
r    
q    q    r    
s    
q    q    s    
         Y                          u    p                              |    [     +               
              |         y#     z              }o    z        {     ~{    x\     t$     f	z%     e`m?@ 	 
      3 J a x        0 G ^ u ! # % & ( ) + 	, . #/ 01 =2 J4 W5 d6 q8 w9 |: ; < = @ A B JC WD ZG lH p[t\{]^opgh        e	    n    t p    { r     t    
 v     x               3   4    8    :                                              	    
       
                       
          (                              +  
    .|N       .{&           #      4    #     #     #     #      .yJ   .t"   "u     ? "v     D "w     L    $ -     + $      -      $     -      $      -      $      -      $      -      $     -      $      -      $      -      $      -      $      -      $      -      $      -      $      -      $     -      $      -      $      -      $      -      $      -      $      -      $      -      $         -     V $      -      $         \ .x   -     [ \     -     [ \      -      \     -     [ \    -     [ \      -     [ \      -      \      -      \      -      \      -      \      -      \      -      \    -      \    -      \      -      \    -      \      -      \      -      \     -      \ 
   -      \    -      \      -      \    -      \    -      \    -      \          -      \      -      \      -      \      -      \      -      \      -      \      -      \      -      \      -      \      -      \     -      \     -      \      -      \      -      \     -      \      -      \      -      \      -      \    -      \     -     [ \      -      \      P-     [ $      -      $      -      $      4    -      $      4   V -      $      -      $      -      $      -     + $     -      $     -      $         #          -      $      -     + $      -      $      P   # -      #      -      #   y  -      #      -      #      -      #   z  -      #   {  -      #      -      #      -      #          .z$   -         p  -         q  -            -            -         r  -            -            -         t  -            -         o  -            -        s  -        x  -        w  -        v  -     [   u  -                 -      #      -      #      -            -           -            -            -            -            -           -            -            -            -            -            -            -           P-            -            -            -           p-            -           P-           P-            -            -            P-           p-            -            P-            P-           p-            P-           -           -           -               -     Y      -     Y     -     Y     -     Y      -     Y      -     Y      -           -            -            -            #      .}&      o-     po    -      o    4   o-     uo     P-     uo    P.(   .~(  	    {-     |{     -      {    -     |{     -     |{     -     |{     -      {    -      {     -      {     -      {     4   {-     {     -     {     -      {     -      {     -     {     -     {     -     {     -     {     -     {     -     {     -     {     -     {     -     {     -      {     -      {     -      {     -     {     -     {     -     {     -     {     P-     {     P-     {     -     {     P-     {     P-     {     P-     {    P-     {    P-     {     P-     {     P-     {     P-     {     P-     {     P-     {     P-     {     P-     |{  }  -      {    -      {        z-     z  ~  -      z    4   z-     z     P-     z  |  P#      #      #      #      #      #      #      #      #      #        .T  
 .,      -          -           -          -          -          -          -          -          #      #      #      #      #        .P   -          -          -          -          -          #     4   .,      -          -           -          Ppu% pv' pw) `TT`UU`VVJ, M . H0 H2 H4 H 6 H8 H: H< H> H@ HB HD H F HH HJ HL HN HP HR H T KW HY H H H H H H H @    [                         J  H  H  `dd`WW`XX    H J H "                           @        J ] J_ M a L c He Hg Hi Hk Hm Ho Hq L s L u H w L y H{ H} H  L  L  H
 L  L  L  H H H H H H H H H H! H  H  H% H' H  H* H+ H- L  @    /  0  1  2  3  4  5  6  7  8 H  J: H;    J< Jy  J= J> Mz  H{  HA HC HE HGHI@    J J   `SSJp  Jq  JK JL Mr  HN HP Ht  HR Ho  HULs Lx Lw Lv 
Lu @    [  \  ]  ^  _ Ha b$   JcM JdJeHgHiH !Hl#Hm%Ho'Hq)Hs+Ht-H /Hu1Hv3Hw5H 7Hx9H ;H =Hy?HzAH{CH EH|GH}IH~KH MHOH QH SJ UH W&   JZJ \J ^J`JbJdM fHhHjHlN   J qM sHvH x&   J}M JJJH HHHHHHHHHHHHHHHHHHHHHHHHHHHHH H HHHHHHHJ} H @     H(   J~ M HH| (   JMJ,   JJJJJ JMHHHT   J	JJJJJMHHHP   JMHH,      |     {     y      t      O x      z      }         ~      	      )    4      	 	     	        wpt{    __turboCrt __cvtfak __AHSHIFT __cleanup __checknull __terminate __restorezero _abort DGROUP@ __MMODEL _main @ostream@$blsh$qpxzc @ostream@$blsh$qpqr7ostream$r7ostream @ostream@$blsh$qi _atexit @$bdele$qpv _exit __exit __cexit __c_exit F_LXMUL@ LXMUL@ F_SCOPY@ SCOPY@ N_LDIV@ F_LDIV@ LDIV@ N_LUDIV@ F_LUDIV@ LUDIV@ N_LMOD@ F_LMOD@ LMOD@ N_LUMOD@ LUMOD@ F_LUMOD@ N_LXLSH@ LXLSH@ F_LXLSH@ N_LXURSH@ LXURSH@ F_LXURSH@ __IOERROR __DOSERROR _isatty __LONGTOA __UTOA _lseek @set_new_handler$qpqv$v @$bnew$qui N_LXMUL@ __read __setupio __VPRINTER __VPTR __VRAM __AHINCR ___brk ___sbrk _brk _sbrk __CPUTN _cprintf __VideoInt __c0crtinit __crtinit _getch __Ngetche _getche __Nungetch _ungetch __graphexit __graphfreemem __graphgetmem _gettext _puttext _ioctl _kbhit _movetext _free _malloc _realloc _putch __REALCVT __SCREENIO __VALIDATEXY __SCROLL __wherexy _wherex _wherey __chmod _close __close _fflush _flushall _fseek _ftell _memcpy _open __open ___read _read _setvbuf _strlen ___write __write _write __xfflush @Iostream_delete$qv @endl$qr7ostream @filebuf@close$qv @filebuf@$bctr$qv @filebuf@$bctr$qi @filebuf@$bdtr$qv @filebuf@overflow$qi @filebuf@open$qpxzcii @filebuf@setbuf$qpzci @filebuf@seekoff$ql8seek_diri @filebuf@sync$qv @filebuf@underflow$qv @fstreambase@$bctr$qpxzcii @fstreambase@$bdtr$qv @fstreambase@open$qpxzcii @istream_withassign@$basg$qp9streambuf @istream@$bctr$qv @istream_withassign@$bctr$qv @istream@ipfx$qi @istream@$bdtr$qv @istream_withassign@$bdtr$qv @istream@eatwhite$qv @istream@$brsh$qri @istream@$brsh$qrl @ofstream@$bctr$qpxzcii @ofstream@$bctr$qpxucii @ofstream@$bdtr$qv @ostream_withassign@$basg$qp9streambuf @ostream@$bctr$qv @ostream_withassign@$bctr$qv @ostream@$bdtr$qv @ostream_withassign@$bdtr$qv @ostream@flush$qv @ostream@$blsh$ql @ostream@$blsh$qul @ostream@$blsh$qzc @ostream@do_opfx$qv @ostream@do_osfx$qv @ostream@outstr$qpxzct1 @streambuf@doallocate$qv @streambuf@$bctr$qv @streambuf@do_snextc$qv @streambuf@do_sgetn$qpzci @streambuf@do_sputn$qpxzci @streambuf@$bdtr$qv @streambuf@overflow$qi @streambuf@pbackfail$qi @streambuf@setbuf$qpzci @streambuf@setb$qpzct1i @streambuf@setg$qpzct1t1 @streambuf@setp$qpzct1 @streambuf@seekoff$ql8seek_diri @streambuf@seekpos$qli @streambuf@sputn$qpxzci @streambuf@sync$qv @streambuf@underflow$qv @ios@clear$qi @ios@$bctr$qv @ios@$bdtr$qv @ios@init$qp9streambuf @ios@setf$ql @ios@setstate$qi @ios@tie$qp7ostream ___move _grapherrormsg _graphresult __GraphNotInstalled _registerfarbgidriver _registerfarbgifont _setgraphbufsize _getmoderange _detectgraph _graphdefaults _initgraph _installuserdriver _installuserfont _setgraphmode _getgraphmode _restorecrtmode _closegraph _cleardevice _setviewport _getviewsettings _clearviewport _moveto _moverel _getx _gety _getmaxx _getmaxy _getdrivername _getmodename _lineto _linerel _getlinesettings _setlinestyle _rectangle _getfillsettings _setfillstyle _getfillpattern _setfillpattern _arc _circle _getaspectratio _setaspectratio _pieslice _setbkcolor _getcolor _getbkcolor _setallpalette _setpalette _getpalette _imagesize _putimage _gettextsettings _outtext _settextjustify _settextstyle _setusercharsize _textheight @DGROUP _postdevice __installdevice __reinstalldevice __gr_setviewport __gr_setgraphmode __gr_restorecrtmode _setvisualpage _setactivepage _setwritemode __gr_setfillpattern __gr_settextjustify __gr_imagesize __autodetect __gr_detectgraph __initdevice __gr_cleardevice __gr_moveto __gr_lineto _line _drawpoly _fillpoly _bar _bar3d _ellipse _fillellipse _sector _getarccoords _setcolor _getmaxcolor _getpalettesize _getdefaultpalette __gr_getmodename _getmaxmode __gr_setbkcolor _setrgbpalette __gr_setpalette __gr_setallpalette __gr_setlinestyle _floodfill __gr_setfillstyle _outtextxy __gr_settextstyle __gr_setusercharsize _textwidth __gr_textheight _getpixel _putpixel _getimage __gr_putimage __GRP_ovr DATASEG@ __Int0Vector __Int4Vector __Int5Vector __Int6Vector __C0argc __C0argv __C0environ __envLng __envseg __envSize __psp __osversion __osmajor __version __osminor _errno __StartTime ___heapbase ___brklvl __heapbase __brklvl __heaptop __BGI_ovr __BGI_auto __DDO_ADD __BGI_ADD __gr_ErrCode __FON_ADD __StatOfs __StatSeg __drawcolor __fillcolor __backcolor __linestyle __fillstyle __OverScanColor __atexitcnt __ctype __exitbuf __exitfopen __exitopen __streams __nfile __openfd __fmode __notUmask __heaplen __doserrno __dosErrorToSV __stklen __wscroll __video _directvideo __cFlag __cChar __first __last __rover @filebuf@openprot @ios@basefield @ios@adjustfield @ios@floatfield @ios@nextbit @ios@usercount __RealCvtVector __ScanTodVector __atexittbl __new_handler _cin _cout _cerr _clog ___stdin_streambuf ___stdout_streambuf ___stderr_streambuf @ios@stdioflush SETUP_AT.CPP SETUP_AT g opt_2 c_sel c_nsel c_2_2 c_2_1 bkg gmode gdriver _s this _f _i ios io_state open_mode seek_dir streambuf fstreambase filebuf ostream ofstream ostream_withassign istream istream_withassign iostream fstream ifstream iostream_withassign wchar_t Pfstream Pofstream Pifstream Pfstreambase Pfilebuf Riostream_withassign Piostream_withassign Rostream_withassign Postream_withassign Ristream_withassign Pistream_withassign Piostream Rostream Postream Ristream Pistream Pstreambuf Pios streamoff streampos size_t ptrdiff_t ios_user_union @ios@$bctr$qp9streambuf @ios@flags @ios@flags$qv @ios@flags$ql @ios@setf @ios@setf$qll @ios@unsetf @ios@unsetf$ql @ios@width @ios@width$qv @ios@width$qi @ios@fill @ios@fill$qv @ios@fill$qzc @ios@precision @ios@precision$qi @ios@precision$qv @ios@tie @ios@tie$qv @ios@rdstate @ios@rdstate$qv @ios@eof @ios@eof$qv @ios@fail @ios@fail$qv @ios@bad @ios@bad$qv @ios@good @ios@good$qv @ios@clear @ios@$opv$qv @ios@$bnot$qv @ios@rdbuf @ios@rdbuf$qv @ios@bitalloc @ios@bitalloc$qv @ios@xalloc @ios@xalloc$qv @ios@iword @ios@iword$qi @ios@pword @ios@pword$qi @ios@sync_with_stdio @ios@sync_with_stdio$qv @ios@skip @ios@skip$qi bp x_tie state ispecial ospecial x_flags x_precision x_width x_fill isfx_special osfx_special delbuf assign_private @ios@init @ios@setstate userwords nwords @ios@usersize @ios@usersize$qi @ios@$bctr$qr3ios @ios@$basg$qr3ios @ios@goodbit @ios@eofbit @ios@failbit @ios@badbit @ios@hardfail @ios@in @ios@out @ios@ate @ios@app @ios@trunc @ios@nocreate @ios@noreplace @ios@binary @ios@beg @ios@cur @ios@end @streambuf@$bctr$qpzci @streambuf@setbuf @streambuf@setbuf$qpuci @streambuf@setbuf$qpzcii @streambuf@sgetc @streambuf@sgetc$qv @streambuf@snextc @streambuf@snextc$qv @streambuf@sbumpc @streambuf@sbumpc$qv @streambuf@stossc @streambuf@stossc$qv @streambuf@sgetn @streambuf@sgetn$qpzci @streambuf@do_sgetn @streambuf@underflow @streambuf@sputbackc @streambuf@sputbackc$qzc @streambuf@pbackfail @streambuf@in_avail @streambuf@in_avail$qv @streambuf@sputc @streambuf@sputc$qi @streambuf@sputn @streambuf@do_sputn @streambuf@overflow @streambuf@out_waiting @streambuf@out_waiting$qv @streambuf@seekoff @streambuf@seekpos @streambuf@sync @streambuf@dbp @streambuf@dbp$qv @streambuf@base @streambuf@base$qv @streambuf@ebuf @streambuf@ebuf$qv @streambuf@blen @streambuf@blen$qv @streambuf@pbase @streambuf@pbase$qv @streambuf@pptr @streambuf@pptr$qv @streambuf@epptr @streambuf@epptr$qv @streambuf@eback @streambuf@eback$qv @streambuf@gptr @streambuf@gptr$qv @streambuf@egptr @streambuf@egptr$qv @streambuf@setp @streambuf@setg @streambuf@pbump @streambuf@pbump$qi @streambuf@gbump @streambuf@gbump$qi @streambuf@setb @streambuf@unbuffered @streambuf@unbuffered$qi @streambuf@unbuffered$qv @streambuf@allocate @streambuf@allocate$qv @streambuf@doallocate alloc_ unbuf_ base_ ebuf_ pbase_ pptr_ epptr_ eback_ gptr_ egptr_ @streambuf@do_snextc @streambuf@$bctr$qr9streambuf @streambuf@$basg$qr9streambuf @fstreambase@$bctr$qv @fstreambase@$bctr$qi @fstreambase@$bctr$qipzci @fstreambase@open @fstreambase@attach @fstreambase@attach$qi @fstreambase@close @fstreambase@close$qv @fstreambase@setbuf @fstreambase@setbuf$qpzci @fstreambase@rdbuf @fstreambase@rdbuf$qv @fstreambase@verify @fstreambase@verify$qi buf @filebuf@$bctr$qipzci @filebuf@$bctr$qipuci @filebuf@is_open @filebuf@is_open$qv @filebuf@fd @filebuf@fd$qv @filebuf@open @filebuf@open$qpxucii @filebuf@close @filebuf@attach @filebuf@attach$qi @filebuf@overflow @filebuf@underflow @filebuf@sync @filebuf@seekoff @filebuf@setbuf xfd mode opened last_seek in_start @filebuf@last_op @filebuf@last_op$qv lahead @ostream@$bctr$qp9streambuf @ostream@$bctr$qi @ostream@$bctr$qipzc @ostream@opfx @ostream@opfx$qv @ostream@osfx @ostream@osfx$qv @ostream@flush @ostream@seekp @ostream@seekp$ql @ostream@seekp$ql8seek_dir @ostream@tellp @ostream@tellp$qv @ostream@put @ostream@put$qzc @ostream@write @ostream@write$qpxzci @ostream@write$qpxuci @ostream@$blsh$quc @ostream@$blsh$qs @ostream@$blsh$qus @ostream@$blsh$qui @ostream@$blsh$qf @ostream@$blsh$qd @ostream@$blsh$qg @ostream@$blsh$qpxuc @ostream@$blsh$qpv @ostream@$blsh$qp9streambuf @ostream@$blsh$qpqr3ios$r3ios @ostream@do_opfx @ostream@do_osfx @ostream@outstr @ofstream@$bctr$qv @ofstream@$bctr$qi @ofstream@$bctr$qipzci @ofstream@$bctr$qipuci @ofstream@rdbuf @ofstream@rdbuf$qv @ofstream@open @ofstream@open$qpxzcii @ofstream@open$qpxucii @ostream_withassign@$basg$qr7ostream @istream@$bctr$qp9streambuf @istream@$bctr$qp9streambufip7ostream @istream@$bctr$qipzci @istream@$bctr$qiip7ostream @istream@ipfx @istream@ipfx0 @istream@ipfx0$qv @istream@ipfx1 @istream@ipfx1$qv @istream@isfx @istream@isfx$qv @istream@seekg @istream@seekg$ql @istream@seekg$ql8seek_dir @istream@tellg @istream@tellg$qv @istream@sync @istream@sync$qv @istream@get @istream@get$qpzcizc @istream@get$qpucizc @istream@read @istream@read$qpzci @istream@read$qpuci @istream@getline @istream@getline$qpzcizc @istream@getline$qpucizc @istream@get$qr9streambufzc @istream@get$qruc @istream@get$qrzc @istream@get$qv @istream@peek @istream@peek$qv @istream@gcount @istream@gcount$qv @istream@putback @istream@putback$qzc @istream@ignore @istream@ignore$qii @istream@$brsh$qpqr7istream$r7istream @istream@$brsh$qpqr3ios$r3ios @istream@$brsh$qpzc @istream@$brsh$qpuc @istream@$brsh$qruc @istream@$brsh$qrzc @istream@$brsh$qrs @istream@$brsh$qrus @istream@$brsh$qrui @istream@$brsh$qrul @istream@$brsh$qrf @istream@$brsh$qrd @istream@$brsh$qrg @istream@$brsh$qp9streambuf @istream@eatwhite gcount_ @istream@do_get @istream@do_get$qv @istream_withassign@$basg$qr7istream @iostream@$bctr$qp9streambuf @iostream@$bdtr$qv @iostream@$bctr$qv @fstream@$bctr$qv @fstream@$bctr$qpxzcii @fstream@$bctr$qpxucii @fstream@$bctr$qi @fstream@$bctr$qipzci @fstream@$bctr$qipuci @fstream@$bdtr$qv @fstream@rdbuf @fstream@rdbuf$qv @fstream@open @fstream@open$qpxzcii @fstream@open$qpxucii @ifstream@$bctr$qv @ifstream@$bctr$qpxzcii @ifstream@$bctr$qpxucii @ifstream@$bctr$qi @ifstream@$bctr$qipzci @ifstream@$bctr$qipuci @ifstream@$bdtr$qv @ifstream@rdbuf @ifstream@rdbuf$qv @ifstream@open @ifstream@open$qpxzcii @ifstream@open$qpxucii @iostream_withassign@$bctr$qv @iostream_withassign@$bdtr$qv @iostream_withassign@$basg$qr3ios @iostream_withassign@$basg$qp9streambuf C:\BORLANDC\BIN\IOSTREAM.H /*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef __WINDOWS_H     /* prevent multiple includes */
#define __WINDOWS_H

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID                void

#define FAR                 _far
#define NEAR                _near
#define PASCAL              _pascal
#define CDECL               _cdecl

#define WINAPI              _far _pascal
#define CALLBACK            _far _pascal

/****** Simple types & common helper macros *********************************/

typedef int                 BOOL;
#define FALSE               0
#define TRUE                1

typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int        UINT;

#ifdef STRICT
typedef signed long         LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)((UINT)(w) >> 8))

#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)((DWORD)(l) >> 16))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#if !defined(NOMINMAX) && !defined(__cplusplus)
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)   ((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)  ((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL                0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;


typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*          PBYTE;
typedef BYTE FAR*           LPBYTE;

typedef int NEAR*           PINT;
typedef int FAR*            LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*          PLONG;
typedef long FAR*           LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE*             PHANDLE;
typedef HANDLE NEAR*        SPHANDLE;
typedef HANDLE FAR*         LPHANDLE;

typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;

typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#if defined(STRICT)
int     PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
int FAR PASCAL LibMain(HINSTANCE, WORD, WORD, LPSTR);
#else
int     PASCAL WinMain(HANDLE, HANDLE, LPSTR, int);
int FAR PASCAL LibMain(HANDLE, WORD, WORD, LPSTR);
#endif
int CALLBACK   WEP(int);

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#define WF_LARGEFRAME   0x0100
#define WF_SMALLFRAME   0x0200
#define WF_80x87        0x0400
#define WF_PAGING       0x0800
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING             0x8000
#define ERR_PARAM               0x4000

#define ERR_SIZE_MASK           0x3000
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE          0x7004
#define ERR_BAD_DFLAGS          0x7005
#define ERR_BAD_DINDEX          0x7006
#define ERR_BAD_PTR             0x7007
#define ERR_BAD_FUNC_PTR        0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR      0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069


/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)


HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

#ifdef _LAX
#define MakeProcInstance(__F, __H) MakeProcInstance((FARPROC)__F, __H)
#define FreeProcInstance(__F)      FreeProcInstance((FARPROC)__F)
#endif /* _LAX */

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL    0

/****** Task Management *****************************************************/

#endif  /* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);


/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED      0x4000
#define GMEM_LOCKCOUNT      0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)


#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED      0x4000
#define LMEM_LOCKCOUNT      0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH           0x0400      /* Used without OF_REOPEN */
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ        0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long    WINAPI _hread(HFILE, void _huge*, long);
long    WINAPI _hwrite(HFILE, const void _huge*, long);
#endif  /* WINVER >= 0x030a */


#endif  /* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE       (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS                      0x0000
#define WN_NOT_SUPPORTED                0x0001
#define WN_NET_ERROR                    0x0002
#define WN_MORE_DATA                    0x0003
#define WN_BAD_POINTER                  0x0004
#define WN_BAD_VALUE                    0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED                0x0007
#define WN_FUNCTION_BUSY                0x0008
#define WN_WINDOWS_ERROR                0x0009
#define WN_BAD_USER                     0x000A
#define WN_OUT_OF_MEMORY                0x000B
#define WN_CANCEL                       0x000C
#define WN_CONTINUE                     0x000D

/* Connection errors */
#define WN_NOT_CONNECTED                0x0030
#define WN_OPEN_FILES                   0x0031
#define WN_BAD_NETNAME                  0x0032
#define WN_BAD_LOCALNAME                0x0033
#define WN_ALREADY_CONNECTED            0x0034
#define WN_DEVICE_ERROR                 0x0035
#define WN_CONNECTION_CLOSED            0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)       GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#if defined(_WIN30_API)
#define MAKEINTRESOURCE(i)  ((LPSTR)MAKELP(0, (i)))
#else
#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))
#endif

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)

#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON       MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640
#define OCR_ICON            32641
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647

#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#if defined(_WIN30_API)
#define MAKEINTATOM(i)      ((LPSTR)MAKELP(0, (i)))
#else
#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))
#endif

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE     0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);


#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif  /* WINVER >= 0x030a */
#endif  /* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif  /* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif  /* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)        (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY       DCB_ACCUMULATE
#define DCB_SET         (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT             1
#define MM_LOMETRIC         2
#define MM_HIMETRIC         3
#define MM_LOENGLISH        4
#define MM_HIENGLISH        5
#define MM_TWIPS            6
#define MM_ISOTROPIC        7
#define MM_ANISOTROPIC      8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);


/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)      ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR            0
#define COLOR_BACKGROUND           1
#define COLOR_ACTIVECAPTION        2
#define COLOR_INACTIVECAPTION      3
#define COLOR_MENU                 4
#define COLOR_WINDOW               5
#define COLOR_WINDOWFRAME          6
#define COLOR_MENUTEXT             7
#define COLOR_WINDOWTEXT           8
#define COLOR_CAPTIONTEXT          9
#define COLOR_ACTIVEBORDER        10
#define COLOR_INACTIVEBORDER      11
#define COLOR_APPWORKSPACE        12
#define COLOR_HIGHLIGHT           13
#define COLOR_HIGHLIGHTTEXT       14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT             18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN             1
#define OBJ_BRUSH           2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL             5
#define PS_INSIDEFRAME      6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN           6
#define BLACK_PEN           7
#define NULL_PEN            8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID            0
#define BS_NULL             1
#define BS_HOLLOW           BS_NULL
#define BS_HATCHED          2
#define BS_PATTERN          3
#define BS_INDEXED          4
#define BS_DIBPATTERN       5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH            PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH         0
#define LTGRAY_BRUSH        1
#define GRAY_BRUSH          2
#define DKGRAY_BRUSH        3
#define BLACK_BRUSH         4
#define NULL_BRUSH          5
#define HOLLOW_BRUSH        NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR               0
#define NULLREGION          1
#define SIMPLEREGION        2
#define COMPLEXREGION       3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND             1
#define RGN_OR              2
#define RGN_XOR             3
#define RGN_DIFF            4
#define RGN_COPY            5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED     0x01    /* palette index used for animation */
#define PC_EXPLICIT     0x02    /* palette index is explicit to device */
#define PC_NOCOLLAPSE   0x04    /* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);


/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);


/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED      0x0001
#define ETO_OPAQUE      0x0002
#define ETO_CLIPPED     0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP              0x0000
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP                0x0000
#define TA_UPDATECP                  0x0001
#define TA_LEFT                      0x0000
#define TA_RIGHT                     0x0002
#define TA_CENTER                    0x0006
#define TA_TOP                       0x0000
#define TA_BOTTOM                    0x0008
#define TA_BASELINE                  0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE         32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE         0
#define FW_THIN             100
#define FW_EXTRALIGHT       200
#define FW_LIGHT            300
#define FW_NORMAL           400
#define FW_MEDIUM           500
#define FW_SEMIBOLD         600
#define FW_BOLD             700
#define FW_EXTRABOLD        800
#define FW_HEAVY            900

#define FW_ULTRALIGHT       FW_EXTRALIGHT
#define FW_REGULAR          FW_NORMAL
#define FW_DEMIBOLD         FW_SEMIBOLD
#define FW_ULTRABOLD        FW_EXTRABOLD
#define FW_BLACK            FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET        0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET      2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET         255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS           4
#define OUT_DEVICE_PRECIS       5
#define OUT_RASTER_PRECIS       6
#define OUT_TT_ONLY_PRECIS      7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK               0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING             0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE       0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif  /* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR         0x02
#define TMPF_DEVICE         0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE       0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR     0x00000040L
#define NTM_BOLD        0x00000020L
#define NTM_ITALIC      0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL    WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE    0x0001
#define TT_ENABLED      0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD          bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE        bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;


HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif  /* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE    1
#define WHITEONBLACK    2
#define COLORONCOLOR    3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif  /* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR              0x0201
#define META_SETBKMODE               0x0102
#define META_SETMAPMODE              0x0103
#define META_SETROP2                 0x0104
#define META_SETRELABS               0x0105
#define META_SETPOLYFILLMODE         0x0106
#define META_SETSTRETCHBLTMODE       0x0107
#define META_SETTEXTCHAREXTRA        0x0108
#define META_SETTEXTCOLOR            0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG            0x020B
#define META_SETWINDOWEXT            0x020C
#define META_SETVIEWPORTORG          0x020D
#define META_SETVIEWPORTEXT          0x020E
#define META_OFFSETWINDOWORG         0x020F
#define META_SCALEWINDOWEXT          0x0410
#define META_OFFSETVIEWPORTORG       0x0211
#define META_SCALEVIEWPORTEXT        0x0412
#define META_LINETO                  0x0213
#define META_MOVETO                  0x0214
#define META_EXCLUDECLIPRECT         0x0415
#define META_INTERSECTCLIPRECT       0x0416
#define META_ARC                     0x0817
#define META_ELLIPSE                 0x0418
#define META_FLOODFILL               0x0419
#define META_PIE                     0x081A
#define META_RECTANGLE               0x041B
#define META_ROUNDRECT               0x061C
#define META_PATBLT                  0x061D
#define META_SAVEDC                  0x001E
#define META_SETPIXEL                0x041F
#define META_OFFSETCLIPRGN           0x0220
#define META_TEXTOUT                 0x0521
#define META_BITBLT                  0x0922
#define META_STRETCHBLT              0x0B23
#define META_POLYGON                 0x0324
#define META_POLYLINE                0x0325
#define META_ESCAPE                  0x0626
#define META_RESTOREDC               0x0127
#define META_FILLREGION              0x0228
#define META_FRAMEREGION             0x0429
#define META_INVERTREGION            0x012A
#define META_PAINTREGION             0x012B
#define META_SELECTCLIPREGION        0x012C
#define META_SELECTOBJECT            0x012D
#define META_SETTEXTALIGN            0x012E
#define META_DRAWTEXT                0x062F

#define META_CHORD                   0x0830
#define META_SETMAPPERFLAGS          0x0231
#define META_EXTTEXTOUT              0x0a32
#define META_SETDIBTODEV             0x0d33
#define META_SELECTPALETTE           0x0234
#define META_REALIZEPALETTE          0x0035
#define META_ANIMATEPALETTE          0x0436
#define META_SETPALENTRIES           0x0037
#define META_POLYPOLYGON             0x0538
#define META_RESIZEPALETTE           0x0139

#define META_DIBBITBLT               0x0940
#define META_DIBSTRETCHBLT           0x0b41
#define META_DIBCREATEPATTERNBRUSH   0x0142
#define META_STRETCHDIB              0x0f43

#define META_EXTFLOODFILL            0x0548

#define META_RESETDC                 0x014C
#define META_STARTDOC                0x014D
#define META_STARTPAGE               0x004F
#define META_ENDPAGE                 0x0050
#define META_ABORTDOC                0x0052
#define META_ENDDOC                  0x005E

#define META_DELETEOBJECT            0x01f0

#define META_CREATEPALETTE           0x00f7
#define META_CREATEBRUSH             0x00F8
#define META_CREATEPATTERNBRUSH      0x01F9
#define META_CREATEPENINDIRECT       0x02FA
#define META_CREATEFONTINDIRECT      0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP            0x06FE
#define META_CREATEREGION            0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED               0x4000
#define SP_ERROR                     (-1)
#define SP_APPABORT                  (-2)
#define SP_USERABORT                 (-3)
#define SP_OUTOFDISK                 (-4)
#define SP_OUTOFMEMORY               (-5)

#define PR_JOBSTATUS                 0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS            0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETABORTPROC                 9
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETLINECAP                   21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define MOUSETRAILS                  39

#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define GETFACENAME                  513
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772

#define STRETCHBLT                   2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HWND);

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;      /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN          0
#define SM_CYSCREEN          1
#define SM_CXVSCROLL         2
#define SM_CYHSCROLL         3
#define SM_CYCAPTION         4
#define SM_CXBORDER          5
#define SM_CYBORDER          6
#define SM_CXDLGFRAME        7
#define SM_CYDLGFRAME        8
#define SM_CYVTHUMB          9
#define SM_CXHTHUMB          10
#define SM_CXICON            11
#define SM_CYICON            12
#define SM_CXCURSOR          13
#define SM_CYCURSOR          14
#define SM_CYMENU            15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL         20
#define SM_CXHSCROLL         21
#define SM_DEBUG             22
#define SM_SWAPBUTTON        23
#define SM_RESERVED1         24
#define SM_RESERVED2         25
#define SM_RESERVED3         26
#define SM_RESERVED4         27
#define SM_CXMIN             28
#define SM_CYMIN             29
#define SM_CXSIZE            30
#define SM_CYSIZE            31
#define SM_CXFRAME           32
#define SM_CYFRAME           33
#define SM_CXMINTRACK        34
#define SM_CYMINTRACK        35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_CMETRICS          43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE       0x001E

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_GETKEYBOARDSPEED        10
#define SPI_SETKEYBOARDSPEED        11
#define SPI_LANGDRIVER              12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY      18
#define SPI_SETGRIDGRANULARITY      19
#define SPI_SETDESKWALLPAPER        20
#define SPI_SETDESKPATTERN          21
#define SPI_GETKEYBOARDDELAY        22
#define SPI_SETKEYBOARDDELAY        23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP        25
#define SPI_SETICONTITLEWRAP        26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH       29
#define SPI_SETDOUBLECLKHEIGHT      30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME      32
#define SPI_SETMOUSEBUTTONSWAP      33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE          0x0001
#define SPIF_SENDWININICHANGE       0x0002

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL             0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER             0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE     0x0000
#define PM_REMOVE       0x0001
#define PM_NOYIELD      0x0002

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY          0x0001
#define QS_MOUSEMOVE    0x0002
#define QS_MOUSEBUTTON  0x0004
#define QS_MOUSE        (QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE  0x0008
#define QS_TIMER        0x0010
#define QS_PAINT        0x0020
#define QS_SENDMESSAGE  0x0040

#define QS_ALLINPUT     0x007f
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST  ((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE       3

#define WH_CALLWNDPROC      4

#define WH_MSGFILTER        (-1)
#define WH_SYSMSGFILTER     6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX           0
#define MSGF_MENU                2
#define MSGF_MOVE                3
#define MSGF_SIZE                4
#define MSGF_SCROLLBAR           5
#define MSGF_NEXTWINDOW          6
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST      0x0380
#define WM_PENWINLAST       0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F


#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER            0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION       0x0016

#define WM_QUIT             0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR      0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002

#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080

#define CS_SAVEBITS         0x0800

#define CS_DBLCLKS          0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE          0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT         0x0100

#define CS_GLOBALCLASS      0x4000
#endif  /* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L

/* Main window states */
#define WS_MINIMIZE         0x20000000L
#define WS_MAXIMIZE         0x01000000L

/* Main window styles */
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

/* Control window styles */
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW      (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW      (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST        0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME
#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW


#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE           0x0001
#define WM_NCCREATE         0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY          0x0002
#define WM_NCDESTROY        0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);


#ifndef NOSHOWWINDOW

#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW       0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM      SW_OTHERRESTORED
#endif  /* NOSHOWWINDOW */

#define WM_SETREDRAW        0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE           0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT          0x000C
#define WM_GETTEXT          0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC         (-4)
#define GWW_HINSTANCE       (-6)
#define GWW_HWNDPARENT      (-8)
#define GWW_ID              (-12)
#define GWL_STYLE           (-16)
#define GWL_EXSTYLE         (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT       ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM         ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE             0x0003
#define WM_SIZE             0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/* Obsolete constant names */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN        0x0013
#define WM_CLOSE            0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024


BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST    0
#define GW_HWNDLAST     1
#define GW_HWNDNEXT     2
#define GW_HWNDPREV     3
#define GW_OWNER        4
#define GW_CHILD        5


/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW          0x00000001L
#define DCX_CACHE           0x00000002L
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP      0x00000020L

#define DCX_EXCLUDERGN      0x00000040L
#define DCX_INTERSECTRGN    0x00000080L


#define DCX_LOCKWINDOWUPDATE 0x00000400L


#define DCX_USESTYLE        0x00010000L

#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT            0x000F
#define WM_ERASEBKGND       0x0014
#define WM_ICONERASEBKGND   0x0027

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE          0x0001
#define RDW_INTERNALPAINT       0x0002
#define RDW_ERASE               0x0004

#define RDW_VALIDATE            0x0008
#define RDW_NOINTERNALPAINT     0x0010
#define RDW_NOERASE             0x0020

#define RDW_NOCHILDREN          0x0040
#define RDW_ALLCHILDREN         0x0080

#define RDW_UPDATENOW           0x0100
#define RDW_ERASENOW            0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004


#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT          0x0085

#define WM_NCCALCSIZE       0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW          (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400


/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT           rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST        0x0084

/* WM_NCHITTEST return codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTSIZE              4
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTGROWBOX           HTSIZE
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON

/****** Drag-and-drop support ***********************************************/

#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES        0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE         0
#define WA_ACTIVE           1
#define WA_CLICKACTIVE      2

#define WM_ACTIVATE         0x0006
#define WM_ACTIVATEAPP      0x001C
#define WM_NCACTIVATE       0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS         0x0007
#define WM_KILLFOCUS        0x0008

#define WM_KEYDOWN          0x0100
#define WM_KEYUP            0x0101

#define WM_CHAR             0x0102
#define WM_DEADCHAR         0x0103

#define WM_SYSKEYDOWN       0x0104
#define WM_SYSKEYUP         0x0105

#define WM_SYSCHAR          0x0106
#define WM_SYSDEADCHAR      0x0107


/* Keyboard message range */
#define WM_KEYFIRST         0x0100
#define WM_KEYLAST          0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED         0x0100
#define KF_DLGMODE          0x0800
#define KF_MENUMODE         0x1000
#define KF_ALTDOWN          0x2000
#define KF_REPEAT           0x4000
#define KF_UP               0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON          0x01
#define VK_RBUTTON          0x02
#define VK_CANCEL           0x03
#define VK_MBUTTON          0x04
#define VK_BACK             0x08
#define VK_TAB              0x09
#define VK_CLEAR            0x0C
#define VK_RETURN           0x0D
#define VK_SHIFT            0x10
#define VK_CONTROL          0x11
#define VK_MENU             0x12
#define VK_PAUSE            0x13
#define VK_CAPITAL          0x14
#define VK_ESCAPE           0x1B
#define VK_SPACE            0x20
#define VK_PRIOR            0x21
#define VK_NEXT             0x22
#define VK_END              0x23
#define VK_HOME             0x24
#define VK_LEFT             0x25
#define VK_UP               0x26
#define VK_RIGHT            0x27
#define VK_DOWN             0x28
#define VK_SELECT           0x29
#define VK_PRINT            0x2A
#define VK_EXECUTE          0x2B
#define VK_SNAPSHOT         0x2C
#define VK_INSERT           0x2D
#define VK_DELETE           0x2E
#define VK_HELP             0x2F
#define VK_NUMPAD0          0x60
#define VK_NUMPAD1          0x61
#define VK_NUMPAD2          0x62
#define VK_NUMPAD3          0x63
#define VK_NUMPAD4          0x64
#define VK_NUMPAD5          0x65
#define VK_NUMPAD6          0x66
#define VK_NUMPAD7          0x67
#define VK_NUMPAD8          0x68
#define VK_NUMPAD9          0x69
#define VK_MULTIPLY         0x6A
#define VK_ADD              0x6B
#define VK_SEPARATOR        0x6C
#define VK_SUBTRACT         0x6D
#define VK_DECIMAL          0x6E
#define VK_DIVIDE           0x6F
#define VK_F1               0x70
#define VK_F2               0x71
#define VK_F3               0x72
#define VK_F4               0x73
#define VK_F5               0x74
#define VK_F6               0x75
#define VK_F7               0x76
#define VK_F8               0x77
#define VK_F9               0x78
#define VK_F10              0x79
#define VK_F11              0x7A
#define VK_F12              0x7B
#define VK_F13              0x7C
#define VK_F14              0x7D
#define VK_F15              0x7E
#define VK_F16              0x7F
#define VK_F17              0x80
#define VK_F18              0x81
#define VK_F19              0x82
#define VK_F20              0x83
#define VK_F21              0x84
#define VK_F22              0x85
#define VK_F23              0x86
#define VK_F24              0x87
#define VK_NUMLOCK          0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */


/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD         2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE        0x0200
#define WM_LBUTTONDOWN      0x0201
#define WM_LBUTTONUP        0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN      0x0204
#define WM_RBUTTONUP        0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN      0x0207
#define WM_MBUTTONUP        0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST       0x0200
#define WM_MOUSELAST        0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE      0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP      0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP      0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP      0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE            7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif  /* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE       0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER            0x0113

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT           0x0000
#define MF_CHANGE           0x0080
#define MF_APPEND           0x0100
#define MF_DELETE           0x0200
#define MF_REMOVE           0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND        0x0000
#define MF_BYPOSITION       0x0400

#define MF_SEPARATOR        0x0800

#define MF_ENABLED          0x0000
#define MF_GRAYED           0x0001
#define MF_DISABLED         0x0002

#define MF_UNCHECKED        0x0000
#define MF_CHECKED          0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING           0x0000
#define MF_BITMAP           0x0004
#define MF_OWNERDRAW        0x0100

#define MF_POPUP            0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK        0x0040

#define MF_UNHILITE         0x0000
#define MF_HILITE           0x0080

#define MF_SYSMENU          0x2000
#define MF_HELP             0x4000
#define MF_MOUSESELECT      0x8000


#define MF_END              0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU         0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT       0x011F
#define WM_MENUCHAR         0x0120

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND          0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL          0x0114
#define WM_VSCROLL          0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8

/* Scroll bar selection constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT              1
#define CF_BITMAP            2
#define CF_METAFILEPICT      3
#define CF_SYLK              4
#define CF_DIF               5
#define CF_TIFF              6
#define CF_OEMTEXT           7
#define CF_DIB               8
#define CF_PALETTE           9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT              0x0300
#define WM_COPY             0x0301
#define WM_PASTE            0x0302
#define WM_CLEAR            0x0303
#define WM_UNDO             0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT     0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)
#define IDC_WAIT            MAKEINTRESOURCE(32514)
#define IDC_CROSS           MAKEINTRESOURCE(32515)
#define IDC_UPARROW         MAKEINTRESOURCE(32516)
#define IDC_SIZE            MAKEINTRESOURCE(32640)
#define IDC_ICON            MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)

#define WM_SETCURSOR        0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005
#define MB_TYPEMASK         0x000F

#define MB_ICONHAND         0x0010
#define MB_ICONQUESTION     0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK         0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200
#define MB_DEFMASK          0x0F00

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000

#define MB_NOFOCUS          0x8000



#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND   0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE


#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE        0x0220
#define WM_MDIDESTROY       0x0221
#define WM_MDIACTIVATE      0x0222
#define WM_MDIRESTORE       0x0223
#define WM_MDINEXT          0x0224
#define WM_MDIMAXIMIZE      0x0225
#define WM_MDITILE          0x0226
#define WM_MDICASCADE       0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU       0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL        0x0000
#define MDITILE_HORIZONTAL      0x0001
#define MDITILE_SKIPDISABLED    0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG       (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA  30

/* Dialog styles */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID         0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG       0x0110
#define WM_NEXTDLGCTL       0x0028

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE        0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT   0
#define DWL_DLGPROC     4
#define DWL_USER        8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE       0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR         0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT       1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN        3
#define CTLCOLOR_DLG        4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6

#define WM_SETFONT          0x0030
#define WM_GETFONT          0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU        1
#define ODT_LISTBOX     2
#define ODT_COMBOBOX    3
#define ODT_BUTTON      4

/* Owner draw actions */
#define ODA_DRAWENTIRE  0x0001
#define ODA_SELECT      0x0002
#define ODA_FOCUS       0x0004

/* Owner draw state */
#define ODS_SELECTED    0x0001
#define ODS_GRAYED      0x0002
#define ODS_DISABLED    0x0004
#define ODS_CHECKED     0x0008
#define ODS_FOCUS       0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM      0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON         (WM_USER+0)
#define STM_GETICON         (WM_USER+1)
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT         0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK         (WM_USER+0)
#define BM_SETCHECK         (WM_USER+1)
#define BM_GETSTATE         (WM_USER+2)
#define BM_SETSTATE         (WM_USER+3)
#define BM_SETSTYLE         (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT             0x00000000L
#define ES_CENTER           0x00000001L
#define ES_RIGHT            0x00000002L
#define ES_MULTILINE        0x00000004L
#define ES_UPPERCASE        0x00000008L
#define ES_LOWERCASE        0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL      0x00000040L
#define ES_AUTOHSCROLL      0x00000080L
#define ES_NOHIDESEL        0x00000100L
#define ES_OEMCONVERT       0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY         0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL               (WM_USER+0)
#define EM_SETSEL               (WM_USER+1)
#define EM_GETRECT              (WM_USER+2)
#define EM_SETRECT              (WM_USER+3)
#define EM_SETRECTNP            (WM_USER+4)
#define EM_LINESCROLL           (WM_USER+6)
#define EM_GETMODIFY            (WM_USER+8)
#define EM_SETMODIFY            (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX            (WM_USER+11)
#define EM_SETHANDLE            (WM_USER+12)
#define EM_GETHANDLE            (WM_USER+13)
#define EM_LINELENGTH           (WM_USER+17)
#define EM_REPLACESEL           (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE              (WM_USER+20)
#define EM_LIMITTEXT            (WM_USER+21)
#define EM_CANUNDO              (WM_USER+22)
#define EM_UNDO                 (WM_USER+23)
#define EM_FMTLINES             (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS          (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE  (WM_USER+30)
#define EM_SETREADONLY          (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT            0
#define WB_RIGHT           1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS         0x0100
#define EN_KILLFOCUS        0x0200
#define EN_CHANGE           0x0300
#define EN_UPDATE           0x0400
#define EN_ERRSPACE         0x0500
#define EN_MAXTEXT          0x0501
#define EN_HSCROLL          0x0601
#define EN_VSCROLL          0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING           (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL              (WM_USER+6)
#define LB_SETCURSEL           (WM_USER+7)
#define LB_GETSEL              (WM_USER+8)
#define LB_GETCURSEL           (WM_USER+9)
#define LB_GETTEXT             (WM_USER+10)
#define LB_GETTEXTLEN          (WM_USER+11)
#define LB_GETCOUNT            (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR                 (WM_USER+14)
#define LB_GETTOPINDEX         (WM_USER+15)
#define LB_FINDSTRING          (WM_USER+16)
#define LB_GETSELCOUNT         (WM_USER+17)
#define LB_GETSELITEMS         (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_SETTOPINDEX         (WM_USER+24)
#define LB_GETITEMRECT         (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE        (-2)
#define LBN_SELCHANGE       1
#define LBN_DBLCLK          2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F

/* Listbox message return values */
#define LB_OKAY             0
#define LB_ERR              (-1)
#define LB_ERRSPACE         (-2)

#define LB_CTLCODE          0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */


/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY       0x0010
#define DDL_ARCHIVE         0x0020

#define DDL_POSTMSGS        0x2000
#define DDL_DRIVES          0x4000
#define DDL_EXCLUSIVE       0x8000

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL            (WM_USER+0)
#define CB_LIMITTEXT             (WM_USER+1)
#define CB_SETEDITSEL            (WM_USER+2)
#define CB_ADDSTRING             (WM_USER+3)
#define CB_DELETESTRING          (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT              (WM_USER+6)
#define CB_GETCURSEL             (WM_USER+7)
#define CB_GETLBTEXT             (WM_USER+8)
#define CB_GETLBTEXTLEN          (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT          (WM_USER+11)
#define CB_FINDSTRING            (WM_USER+12)
#define CB_SELECTSTRING          (WM_USER+13)
#define CB_SETCURSEL             (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE        (-1)
#define CBN_SELCHANGE       1
#define CBN_DBLCLK          2
#define CBN_SETFOCUS        3
#define CBN_KILLFOCUS       4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY             0
#define CB_ERR              (-1)
#define CB_ERRSPACE         (-2)

#endif  /* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */


/* Standard hook code */
#define HC_ACTION           0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN        (-3)
#define HC_LPLPFNNEXT       (-2)
#define HC_LPFNNEXT         (-1)

#endif  /* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT              5

#define HCBT_MOVESIZE       0
#define HCBT_MINMAX         1
#define HCBT_QS             2
#define HCBT_CREATEWND      3
#define HCBT_DESTROYWND     4
#define HCBT_ACTIVATE       5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND     8
#define HCBT_SETFOCUS       9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE         8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif  /* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG            9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE     hModuleHook;
    LPARAM      reserved;
    LPARAM      lParam;
    WPARAM      wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY        0
#define S_THRESHOLD         1
#define S_ALLTHRESHOLD      2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY            0
#define ODDPARITY           1
#define EVENPARITY          2
#define MARKPARITY          3
#define SPACEPARITY         4

#define ONESTOPBIT          0
#define ONE5STOPBITS        1
#define TWOSTOPBITS         2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE           EV_RingTe

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110      0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) || (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT || WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT || WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY           0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

#define wsprintf WSPRINTF
int     FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER               0x000F

#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL           0x0000
#define DRVCNF_OK               0x0001
#define DRVCNF_RESTART          0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY   0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE             0x00000002

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __WINDOWS_H */
/*****************************************************************************\
*                                                                             *
* stress.h -    Stress functions definitions                                  *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*******************************************************************************/

#ifndef __STRESS_H      /* prevent multiple includes */
#define __STRESS_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****** Simple types & common helper macros *********************************/

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define UINT        WORD
#define WINAPI      FAR PASCAL
#endif  /* WIN3.0 */

/* stuff for AllocDiskSpace() */
#define  EDS_WIN     1
#define  EDS_CUR     2
#define  EDS_TEMP    3


/* function prototypes */
BOOL    WINAPI AllocMem(DWORD);
void    WINAPI FreeAllMem(void);
int     WINAPI AllocFileHandles(int);
void    WINAPI UnAllocFileHandles(void);
int     WINAPI GetFreeFileHandles(void);
int     WINAPI AllocDiskSpace(long,UINT);
void    WINAPI UnAllocDiskSpace(UINT);
BOOL    WINAPI AllocUserMem(UINT);
void    WINAPI FreeAllUserMem(void);
BOOL    WINAPI AllocGDIMem(UINT);
void    WINAPI FreeAllGDIMem(void);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __STRESS_H */
/*  share.h

    File sharing mode for use with sopen.
    See DOS function 3Dh for definition.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__SHARE_H)
#define __SHARE_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#define SH_COMPAT   0x0000
#define SH_DENYRW   0x0010
#define SH_DENYWR   0x0020
#define SH_DENYRD   0x0030
#define SH_DENYNONE 0x0040

#define SH_DENYNO   SH_DENYNONE /* MS documentation uses both */

#endif  /* __SHARE_H */

/*  fcntl.h

    Define flag values accessible to open.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__FCNTL_H)
#define __FCNTL_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

extern int _Cdecl _fmode;

/* The first three can only be set by open */

#define O_RDONLY         1
#define O_WRONLY         2
#define O_RDWR           4

/* Flag values for open only */

#define O_CREAT     0x0100  /* create and open file */
#define O_TRUNC     0x0200  /* open with truncation */
#define O_EXCL      0x0400  /* exclusive open */

/* The "open flags" defined above are not needed after open, hence they
   are re-used for other purposes when the file is running.  Sorry, it's
   getting crowded !
*/
#define _O_RUNFLAGS 0x0700
#define _O_WRITABLE 0x0100 /* file is not read-only */
#define _O_EOF      0x0200 /* set when text file hits ^Z   */

/* a file in append mode may be written to only at its end.
*/
#define O_APPEND    0x0800  /* to end of file */

/* MSDOS special bits */

#define O_CHANGED   0x1000  /* user may read these bits, but    */
#define O_DEVICE    0x2000  /*   only RTL\io functions may touch.   */
#define O_TEXT      0x4000  /* CR-LF translation    */
#define O_BINARY    0x8000  /* no translation   */

/* DOS 3.x options */

#define O_NOINHERIT 0x80
#define O_DENYALL   0x10
#define O_DENYWRITE 0x20
#define O_DENYREAD  0x30
#define O_DENYNONE  0x40

#endif  /* __FCNTL_H */

/*****************************************************************************\
*                                                                             *
* dlgs.h -      Common dialog's dialog element ID numbers                     *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef __DLGS_H    /* prevent multiple includes */
#define __DLGS_H

#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#endif  /* __DLGS_H */
/*  stdarg.h

    Definitions for accessing parameters in functions that accept
    a variable number of arguments.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __STDARG_H
#define __STDARG_H

#ifdef __VARARGS_H
#error Can't include both STDARG.H and VARARGS.H
#endif

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

typedef void _FAR *va_list;

#define __size(x) ((sizeof(x)+sizeof(int)-1) & ~(sizeof(int)-1))

#if defined(__cplusplus) && !defined(__STDC__)
#define va_start(ap, parmN) (ap = ...)
#else
#define va_start(ap, parmN) ((void)((ap) = (va_list)((char _FAR *)(&parmN)+__size(parmN))))
#endif

#define va_arg(ap, type) (*(type _FAR *)(((*(char _FAR *_FAR *)&(ap))+=__size(type))-(__size(type))))
#define va_end(ap)          ((void)0)

#if !__STDC__
#define _va_ptr             (...)
#endif

#endif
PKBGI Stroked Font V1.1 - Jun 5, 1989
Copyright (c) 1987,1988 Borland International
 BOLD8                             +    5           :   >,Vt.v
^Z&4|X8	 	@	Z			Z

Nb*8F&4B*Z 4dvJ\>b&R:D>~*@ R d  !$!D!d!"$L(Z(p((((()()L)p)))))))**<*Z*z****+H+`++++,&,B,\,v,,,,---.Z../|////40v000>111l23x333484\4z44445B5P5^5z5556( 
!!!(!!!! !! !!$ "!!"& !!! ":#!
(("$$03!.!%*!"%%"'%&'(*(( """""""""""""'"'""! $$! !$!"$/ +

&(   
    & &   
      !  *      &    (   (                          (                   (                                                 "(                    
       %                            "   
   (   (                                 &      	      	      "          "   ~(                 	                    	              y                 !          	$$   '      '$   '   (&         $$   '    $$        '    ..    1/   0   	   ((   	   	%%   	'   	    	'   y$$   //   
..       (%   "   1+   %   '    '   	'   	'   $    2   &       (             (    (         """


~~~(((!"""


~~~((&    "


~~~((("""


~~~((("""


~~~((("""


~~~(((   ))))))#########))))))))))))#########   (   (   (   ((         (w   ((      '%   '                  (      (   (   ((   '%      %      (w      %      '      {   '               y   (   z    1111111111111111111111111111      111111111111111   111111111111111   11111111111111111111111111111   
         #          y         $'    #    (	   		    	         #    
    )       (   y           #            y               /*****************************************************************************\
*                                                                             *
* toolhelp.h -  toolhelp.dll functions, types, and definitions                *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef __TOOLHELP_H    /* prevent multiple includes */
#define __TOOLHELP_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#define HTASK       HANDLE
#endif  /* WIN3.0 */

/****** General symbols ******************************************************/
#define MAX_DATA        11
#define MAX_PATH        255
#define MAX_MODULE_NAME 8 + 1
#define MAX_CLASSNAME   255

/****** Global heap walking ***************************************************/
typedef struct tagGLOBALINFO
{
    DWORD dwSize;
    WORD wcItems;
    WORD wcItemsFree;
    WORD wcItemsLRU;
} GLOBALINFO;

typedef struct tagGLOBALENTRY
{
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HGLOBAL hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    BOOL wHeapPresent;
    HGLOBAL hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
} GLOBALENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

/* GLOBALENTRY.wFlags */
#define GF_PDB_OWNER        0x0100      /* Low byte is KERNEL flags */

BOOL    WINAPI GlobalInfo(GLOBALINFO FAR* lpGlobalInfo);
BOOL    WINAPI GlobalFirst(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalNext(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalEntryHandle(GLOBALENTRY FAR* lpGlobal, HGLOBAL hItem);
BOOL    WINAPI GlobalEntryModule(GLOBALENTRY FAR* lpGlobal, HMODULE hModule, WORD wSeg);
WORD    WINAPI GlobalHandleToSel(HGLOBAL hMem);

/****** Local heap walking ***************************************************/

typedef struct tagLOCALINFO
{
    DWORD dwSize;
    WORD wcItems;
} LOCALINFO;

typedef struct tagLOCALENTRY
{
    DWORD dwSize;
    HLOCAL hHandle;
    WORD wAddress;
    WORD wSize;
    WORD wFlags;
    WORD wcLock;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    WORD wNext;
} LOCALENTRY;

/* LOCALENTRY.wHeapType flags */
#define NORMAL_HEAP     0
#define USER_HEAP       1
#define GDI_HEAP        2

/* LOCALENTRY.wFlags */
#define LF_FIXED        1
#define LF_FREE         2
#define LF_MOVEABLE     4

/* LOCALENTRY.wType */
#define LT_NORMAL                   0
#define LT_FREE                     0xff
#define LT_GDI_PEN                  1   /* LT_GDI_* is for GDI's heap */
#define LT_GDI_BRUSH                2
#define LT_GDI_FONT                 3
#define LT_GDI_PALETTE              4
#define LT_GDI_BITMAP               5
#define LT_GDI_RGN                  6
#define LT_GDI_DC                   7
#define LT_GDI_DISABLED_DC          8
#define LT_GDI_METADC               9
#define LT_GDI_METAFILE             10
#define LT_GDI_MAX                  LT_GDI_METAFILE
#define LT_USER_CLASS               1   /* LT_USER_* is for USER's heap */
#define LT_USER_WND                 2
#define LT_USER_STRING              3
#define LT_USER_MENU                4
#define LT_USER_CLIP                5
#define LT_USER_CBOX                6
#define LT_USER_PALETTE             7
#define LT_USER_ED                  8
#define LT_USER_BWL                 9
#define LT_USER_OWNERDRAW           10
#define LT_USER_SPB                 11
#define LT_USER_CHECKPOINT          12
#define LT_USER_DCE                 13
#define LT_USER_MWP                 14
#define LT_USER_PROP                15
#define LT_USER_LBIV                16
#define LT_USER_MISC                17
#define LT_USER_ATOMS               18
#define LT_USER_LOCKINPUTSTATE      19
#define LT_USER_HOOKLIST            20
#define LT_USER_USERSEEUSERDOALLOC  21
#define LT_USER_HOTKEYLIST          22
#define LT_USER_POPUPMENU           23
#define LT_USER_HANDLETABLE         32
#define LT_USER_MAX                 LT_USER_HANDLETABLE

BOOL    WINAPI LocalInfo(LOCALINFO FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalFirst(LOCALENTRY FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalNext(LOCALENTRY FAR* lpLocal);

/****** Stack Tracing ********************************************************/

typedef struct tagSTACKTRACEENTRY
{
    DWORD dwSize;
    HTASK hTask;
    WORD wSS;
    WORD wBP;
    WORD wCS;
    WORD wIP;
    HMODULE hModule;
    WORD wSegment;
    WORD wFlags;
} STACKTRACEENTRY;

/* STACKTRACEENTRY.wFlags values */
#define FRAME_FAR       0
#define FRAME_NEAR      1

BOOL    WINAPI StackTraceFirst(STACKTRACEENTRY FAR* lpStackTrace, HTASK hTask);
BOOL    WINAPI StackTraceCSIPFirst(STACKTRACEENTRY FAR* lpStackTrace,
            WORD wSS, WORD wCS, WORD wIP, WORD wBP);
BOOL    WINAPI StackTraceNext(STACKTRACEENTRY FAR* lpStackTrace);

/****** Module list walking **************************************************/

typedef struct tagMODULEENTRY
{
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME + 1];
    HMODULE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH + 1];
    WORD wNext;
} MODULEENTRY;

BOOL    WINAPI ModuleFirst(MODULEENTRY FAR* lpModule);
BOOL    WINAPI ModuleNext(MODULEENTRY FAR* lpModule);
HMODULE WINAPI ModuleFindName(MODULEENTRY FAR* lpModule, LPCSTR lpstrName);
HMODULE WINAPI ModuleFindHandle(MODULEENTRY FAR* lpModule, HMODULE hModule);

/****** Task list walking *****************************************************/

typedef struct tagTASKENTRY
{
    DWORD dwSize;
    HTASK hTask;
    HTASK hTaskParent;
    HINSTANCE hInst;
    HMODULE hModule;
    WORD wSS;
    WORD wSP;
    WORD wStackTop;
    WORD wStackMinimum;
    WORD wStackBottom;
    WORD wcEvents;
    HGLOBAL hQueue;
    char szModule[MAX_MODULE_NAME + 1];
    WORD wPSPOffset;
    HANDLE hNext;
} TASKENTRY;

BOOL    WINAPI TaskFirst(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskNext(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskFindHandle(TASKENTRY FAR* lpTask, HTASK hTask);
DWORD   WINAPI TaskSetCSIP(HTASK hTask, WORD wCS, WORD wIP);
DWORD   WINAPI TaskGetCSIP(HTASK hTask);
BOOL    WINAPI TaskSwitch(HTASK hTask, DWORD dwNewCSIP);

/****** Window Class enumeration **********************************************/

typedef struct tagCLASSENTRY
{
    DWORD dwSize;
    HMODULE hInst;              /* This is really an hModule */
    char szClassName[MAX_CLASSNAME + 1];
    WORD wNext;
} CLASSENTRY;

BOOL    WINAPI ClassFirst(CLASSENTRY FAR* lpClass);
BOOL    WINAPI ClassNext(CLASSENTRY FAR* lpClass);

/****** Information functions *************************************************/

typedef struct tagMEMMANINFO
{
    DWORD dwSize;
    DWORD dwLargestFreeBlock;
    DWORD dwMaxPagesAvailable;
    DWORD dwMaxPagesLockable;
    DWORD dwTotalLinearSpace;
    DWORD dwTotalUnlockedPages;
    DWORD dwFreePages;
    DWORD dwTotalPages;
    DWORD dwFreeLinearSpace;
    DWORD dwSwapFilePages;
    WORD wPageSize;
} MEMMANINFO;

BOOL    WINAPI MemManInfo(MEMMANINFO FAR* lpEnhMode);

typedef struct tagSYSHEAPINFO
{
    DWORD dwSize;
    WORD wUserFreePercent;
    WORD wGDIFreePercent;
    HGLOBAL hUserSegment;
    HGLOBAL hGDISegment;
} SYSHEAPINFO;

BOOL    WINAPI SystemHeapInfo(SYSHEAPINFO FAR* lpSysHeap);

/****** Interrupt Handling ****************************************************/

/* Hooked interrupts */
#define INT_DIV0            0
#define INT_1               1
#define INT_3               3
#define INT_UDINSTR         6
#define INT_STKFAULT        12
#define INT_GPFAULT         13
#define INT_BADPAGEFAULT    14
#define INT_CTLALTSYSRQ     256

/* TOOLHELP Interrupt callbacks registered with InterruptRegister should
 *  always be written in assembly language.  The stack frame is not
 *  compatible with high level language conventions.
 *
 *  This stack frame looks as follows to the callback.  All registers
 *  should be preserved across this callback to allow restarting fault.
 *               ------------
 *               |   Flags  |  [SP + 0Eh]
 *               |    CS    |  [SP + 0Ch]
 *               |    IP    |  [SP + 0Ah]
 *               |  Handle  |  [SP + 08h]
 *               |Exception#|  [SP + 06h]
 *               |    AX    |  [SP + 04h]  AX Saved to allow MakeProcInstance
 *               |  Ret CS  |  [SP + 02h]
 *       SP--->  |  Ret IP  |  [SP + 00h]
 *               ------------
 */
BOOL    WINAPI InterruptRegister(HTASK hTask, FARPROC lpfnIntCallback);
BOOL    WINAPI InterruptUnRegister(HTASK hTask);

/*  Notifications:
 *      When a notification callback is called, two parameters are passed
 *      in:  a WORD, wID, and another DWORD, dwData.  wID is one of
 *      the values NFY_* below.  Callback routines should ignore unrecog-
 *      nized values to preserve future compatibility.  Callback routines
 *      are also passed a dwData value.  This may contain data or may be
 *      a FAR pointer to a structure, or may not be used depending on
 *      which notification is being received.
 *
 *      In all cases, if the return value of the callback is TRUE, the
 *      notification will NOT be passed on to other callbacks.  It has
 *      been handled.  This should be used sparingly and only with certain
 *      notifications.  Callbacks almost always return FALSE.
 */

/* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
 *  should ignore these.
 */
#define NFY_UNKNOWN         0

/* NFY_LOADSEG:  dwData points to a NFYLOADSEG structure */
#define NFY_LOADSEG         1
typedef struct tagNFYLOADSEG
{
    DWORD dwSize;
    WORD wSelector;
    WORD wSegNum;
    WORD wType;             /* Low bit set if data seg, clear if code seg */
    WORD wcInstance;        /* Instance count ONLY VALID FOR DATA SEG */
    LPCSTR lpstrModuleName;
} NFYLOADSEG;

/* NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed */
#define NFY_FREESEG         2

/* NFY_STARTDLL:  dwData points to a NFYLOADSEG structure */
#define NFY_STARTDLL        3
typedef struct tagNFYSTARTDLL
{
    DWORD dwSize;
    HMODULE hModule;
    WORD wCS;
    WORD wIP;
} NFYSTARTDLL;

/* NFY_STARTTASK:  dwData is the CS:IP of the start address of the task */
#define NFY_STARTTASK       4

/* NFY_EXITTASK:  The low byte of dwData contains the program exit code */
#define NFY_EXITTASK        5

/* NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed */
#define NFY_DELMODULE       6

/* NFY_RIP:  dwData points to a NFYRIP structure */
#define NFY_RIP             7
typedef struct tagNFYRIP
{
    DWORD dwSize;
    WORD wIP;
    WORD wCS;
    WORD wSS;
    WORD wBP;
    WORD wExitCode;
} NFYRIP;

/* NFY_TASKIN:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKIN          8

/* NFY_TASKOUT:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKOUT         9

/* NFY_INCHAR:  Return value from callback is used.  If NULL, mapped to 'i' */
#define NFY_INCHAR          10

/* NFY_OUTSTR:  dwData points to the string to be displayed */
#define NFY_OUTSTR          11

/* NFY_LOGERROR:  dwData points to a NFYLOGERROR struct */
#define NFY_LOGERROR        12
typedef struct tagNFYLOGERROR
{
    DWORD dwSize;
    UINT wErrCode;
    void FAR* lpInfo;       /* Error code-dependent */
} NFYLOGERROR;

/* NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct */
#define NFY_LOGPARAMERROR   13
typedef struct tagNFYLOGPARAMERROR
{
    DWORD dwSize;
    UINT wErrCode;
    FARPROC lpfnErrorAddr;
    void FAR* FAR* lpBadParam;
} NFYLOGPARAMERROR;

/* NotifyRegister() flags */
#define NF_NORMAL       0
#define NF_TASKSWITCH   1
#define NF_RIP          2

typedef BOOL (CALLBACK* LPFNNOTIFYCALLBACK)(WORD wID, DWORD dwData);

BOOL    WINAPI NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
BOOL    WINAPI NotifyUnRegister(HTASK hTask);

/****** Miscellaneous *********************************************************/

void    WINAPI TerminateApp(HTASK hTask, WORD wFlags);

/* TerminateApp() flag values */
#define UAE_BOX     0
#define NO_UAE_BOX  1

DWORD   WINAPI MemoryRead(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);
DWORD   WINAPI MemoryWrite(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);

typedef struct tagTIMERINFO
{
    DWORD dwSize;
    DWORD dwmsSinceStart;
    DWORD dwmsThisVM;
} TIMERINFO;

BOOL    WINAPI TimerCount(TIMERINFO FAR* lpTimer);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif /* __TOOLHELP_H */
/*  stdio.h

    Definitions for stream input/output.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __STDIO_H
#define __STDIO_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(___NFILE_H)
#include <_nfile.h>
#endif

#ifndef NULL
#include <_null.h>
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

/* Definition of the file position type
*/
typedef long    fpos_t;


/* Definition of the control structure for streams
*/
typedef struct  {
        int             level;          /* fill/empty level of buffer */
        unsigned        flags;          /* File status flags          */
        char            fd;             /* File descriptor            */
        unsigned char   hold;           /* Ungetc char if no buffer   */
        int             bsize;          /* Buffer size                */
        unsigned char   _FAR *buffer;   /* Data transfer buffer       */
        unsigned char   _FAR *curp;     /* Current active pointer     */
        unsigned        istemp;         /* Temporary file indicator   */
        short           token;          /* Used for validity checking */
}       FILE;                           /* This is the FILE object    */

/* Bufferisation type to be used as 3rd argument for "setvbuf" function
*/
#define _IOFBF  0
#define _IOLBF  1
#define _IONBF  2

/*  "flags" bits definitions
*/
#define _F_RDWR 0x0003                  /* Read/write flag       */
#define _F_READ 0x0001                  /* Read only file        */
#define _F_WRIT 0x0002                  /* Write only file       */
#define _F_BUF  0x0004                  /* Malloc'ed Buffer data */
#define _F_LBUF 0x0008                  /* line-buffered file    */
#define _F_ERR  0x0010                  /* Error indicator       */
#define _F_EOF  0x0020                  /* EOF indicator         */
#define _F_BIN  0x0040                  /* Binary file indicator */
#define _F_IN   0x0080                  /* Data is incoming      */
#define _F_OUT  0x0100                  /* Data is outgoing      */
#define _F_TERM 0x0200                  /* File is a terminal    */

/* End-of-file constant definition
*/
#define EOF (-1)            /* End of file indicator */

/* Number of files that can be open simultaneously
*/
#if __STDC__
#define FOPEN_MAX (_NFILE_ - 2) /* (_NFILE_ - stdaux & stdprn) */
#else
#define FOPEN_MAX (_NFILE_)     /* Able to have 20 files */
#define SYS_OPEN  (_NFILE_)
#endif

#define FILENAME_MAX 80

/* Default buffer size use by "setbuf" function
*/
#define BUFSIZ  512         /* Buffer size for stdio */

/* Size of an arry large enough to hold a temporary file name string
*/
#define L_ctermid   5       /* CON: plus null byte */
#define P_tmpdir    ""      /* temporary directory */
#define L_tmpnam    13      /* tmpnam buffer size */

/* Constants to be used as 3rd argument for "fseek" function
*/
#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0

/* Number of unique file names that shall be generated by "tmpnam" function
*/
#define TMP_MAX     0xFFFF

/* Standard I/O predefined streams
*/

#if !defined( _RTLDLL )
extern  FILE    _Cdecl _streams[];
extern  unsigned    _Cdecl _nfile;

#define stdin   (&_streams[0])
#define stdout  (&_streams[1])
#define stderr  (&_streams[2])

#if !__STDC__
#define stdaux  (&_streams[3])
#define stdprn  (&_streams[4])
#endif

#else

#ifdef __cplusplus
extern "C" {
#endif
FILE far * far __getStream(int);
#ifdef __cplusplus
}
#endif

#define stdin   __getStream(0)
#define stdout  __getStream(1)
#define stderr  __getStream(2)
#define stdaux  __getStream(3)
#define stdprn  __getStream(4)

#endif

#ifdef __cplusplus
extern "C" {
#endif
void    _Cdecl clearerr(FILE _FAR *__stream);
int     _Cdecl _FARFUNC fclose(FILE _FAR *__stream);
int     _Cdecl _FARFUNC fflush(FILE _FAR *__stream);
int     _Cdecl _FARFUNC fgetc(FILE _FAR *__stream);
int     _Cdecl fgetpos(FILE _FAR *__stream, fpos_t _FAR *__pos);
char   _FAR *_Cdecl _FARFUNC fgets(char _FAR *__s, int __n, FILE _FAR *__stream);
FILE   _FAR *_Cdecl _FARFUNC fopen(const char _FAR *__path, const char _FAR *__mode);
int     _Cdecl _FARFUNC fprintf(FILE _FAR *__stream, const char _FAR *__format, ...);
int     _Cdecl _FARFUNC fputc(int __c, FILE _FAR *__stream);
int     _Cdecl _FARFUNC fputs(const char _FAR *__s, FILE _FAR *__stream);
size_t  _Cdecl _FARFUNC fread(void _FAR *__ptr, size_t __size, size_t __n,
                     FILE _FAR *__stream);
FILE   _FAR *_Cdecl _FARFUNC freopen(const char _FAR *__path, const char _FAR *__mode,
                            FILE _FAR *__stream);
int     _Cdecl _FARFUNC fscanf(FILE _FAR *__stream, const char _FAR *__format, ...);
int     _Cdecl _FARFUNC fseek(FILE _FAR *__stream, long __offset, int __whence);
int     _Cdecl fsetpos(FILE _FAR *__stream, const fpos_t _FAR *__pos);
long    _Cdecl _FARFUNC ftell(FILE _FAR *__stream);
size_t  _Cdecl _FARFUNC fwrite(const void _FAR *__ptr, size_t __size, size_t __n,
                      FILE _FAR *__stream);
char   _FAR *_Cdecl gets(char _FAR *__s);
void    _Cdecl perror(const char _FAR *__s);
int     _Cdecl printf(const char _FAR *__format, ...);
int     _Cdecl puts(const char _FAR *__s);
int     _CType remove(const char _FAR *__path);
int     _CType _FARFUNC rename(const char _FAR *__oldname,const char _FAR *__newname);
void    _Cdecl _FARFUNC rewind(FILE _FAR *__stream);
int     _Cdecl scanf(const char _FAR *__format, ...);
void    _Cdecl setbuf(FILE _FAR *__stream, char _FAR *__buf);
int     _Cdecl _FARFUNC setvbuf(FILE _FAR *__stream, char _FAR *__buf,
                       int __type, size_t __size);
int     _Cdecl _FARFUNC sprintf(char _FAR *__buffer, const char _FAR *__format, ...);
int     _Cdecl _FARFUNC sscanf(const char _FAR *__buffer,
                      const char _FAR *__format, ...);
char   _FAR *_Cdecl _FARFUNC strerror(int __errnum);
FILE   _FAR *_Cdecl _FARFUNC tmpfile(void);
char   _FAR *_Cdecl _FARFUNC tmpnam(char _FAR *__s);
int     _Cdecl _FARFUNC ungetc(int __c, FILE _FAR *__stream);
int     _Cdecl _FARFUNC vfprintf(FILE _FAR *__stream, const char _FAR *__format,
                        void _FAR *__arglist);
int     _Cdecl _FARFUNC vfscanf(FILE _FAR *__stream, const char _FAR *__format,
                        void _FAR *__arglist);
int     _CType vprintf(const char _FAR *__format, void _FAR *__arglist);
int     _Cdecl vscanf(const char _FAR *__format, void _FAR *__arglist);
int     _Cdecl _FARFUNC vsprintf(char _FAR *__buffer, const char _FAR *__format,
                        void _FAR *__arglist);
int     _Cdecl _FARFUNC vsscanf(const char _FAR *__buffer, const char _FAR *__format,
                        void _FAR *__arglist);
int     _CType unlink(const char _FAR *__path);
int     _Cdecl getc(FILE _FAR *__fp);

int     _Cdecl getchar(void);
int     _Cdecl putchar(const int __c);

int     _Cdecl putc(const int __c, FILE _FAR *__fp);
int     _Cdecl feof(FILE _FAR *__fp);
int     _Cdecl ferror(FILE _FAR *__fp);


#if !__STDC__
int     _Cdecl _FARFUNC fcloseall(void);
FILE   _FAR *_Cdecl _FARFUNC fdopen(int __handle, char _FAR *__type);
int     _Cdecl _FARFUNC fgetchar(void);
int     _Cdecl _FARFUNC flushall(void);
int     _Cdecl _FARFUNC fputchar(int __c);
FILE   _FAR * _Cdecl _fsopen (const char _FAR *__path, const char _FAR *__mode,
                  int __shflag);
int     _Cdecl getw(FILE _FAR *__stream);
int     _Cdecl putw(int __w, FILE _FAR *__stream);
int     _Cdecl rmtmp(void);
char   _FAR * _Cdecl _FARFUNC _strerror(const char _FAR *__s);
char   _FAR * _Cdecl _FARFUNC tempnam(char _FAR *__dir, char _FAR *__pfx);

#define fileno(f)       ((f)->fd)
#ifdef __MSC
#define _fileno(f)  fileno(f)
#endif

#endif  /* !__STDC__ */

int      _Cdecl _FARFUNC _fgetc(FILE _FAR *__stream);           /* used by getc() macro */
int      _Cdecl _FARFUNC _fputc(char __c, FILE _FAR *__stream); /* used by putc() macro */

void    _Cdecl _InitEasyWin(void);  /* Initialization call for Easy Windows */

#ifdef  __cplusplus
}
#endif

/*  The following macros provide for common functions */

#define ferror(f)   ((f)->flags & _F_ERR)
#define feof(f)     ((f)->flags & _F_EOF)

#define getc(f) \
  ((--((f)->level) >= 0) ? (unsigned char)(*(f)->curp++) : \
    _fgetc (f))

#define putc(c,f) \
  ((++((f)->level) < 0) ? (unsigned char)(*(f)->curp++=(c)) : \
    _fputc ((c),f))

#define getchar()  getc(stdin)
#define putchar(c) putc((c), stdout)

#define ungetc(c,f) ungetc((c),f)   /* traditionally a macro */

#endif

/*  strstream.h -- class strstream declarations

    Copyright (c) 1990, 1992 by Borland International
    All rights reserved
*/

#ifndef __cplusplus
#error Must use C++ for the type strstream.
#endif

#ifndef __STRSTREAM_H
#define __STRSTREAM_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(__IOSTREAM_H)
#include <iostream.h>
#endif

#pragma option -Vo-
#if defined(__BCOPT__) && !defined(_RTL_ALLOW_po)
#pragma option -po-
#endif

_CLASSDEF(strstreambuf)
_CLASSDEF(strstreambase)
_CLASSDEF(istrstream)
_CLASSDEF(ostrstream)
_CLASSDEF(strstream)

class _CLASSTYPE strstreambuf : public streambuf {
public:
    _Cdecl strstreambuf();
    _Cdecl strstreambuf(int n);
    _Cdecl strstreambuf(void _FAR * (*a)(long), void (*f)(void _FAR *));
    _Cdecl strstreambuf( signed char _FAR * _s, int,
                         signed char _FAR * _strt=0);
    _Cdecl strstreambuf( unsigned char _FAR * _s, int,
                         unsigned char _FAR * _strt=0);
    _Cdecl ~strstreambuf();

    void    _Cdecl freeze(int = 1);
    char _FAR * _Cdecl str();
virtual int _Cdecl doallocate();
virtual int _Cdecl overflow(int);
virtual int _Cdecl underflow();
virtual int _Cdecl sync();
virtual streambuf _FAR * _Cdecl setbuf(char _FAR *, int);
virtual streampos  _Cdecl seekoff(streamoff, ios::seek_dir, int);

private:
    void _FAR * _Cdecl (*allocf)(long);
    void    _Cdecl (*freef)(void _FAR *);
    short   ssbflags;
    enum    { dynamic = 1, frozen = 2, unlimited = 4 };
    int next_alloc;

    void    _Cdecl init(signed char _FAR *, int, signed char _FAR *);
};


class _CLASSTYPE strstreambase : public virtual ios {
public:
    strstreambuf _FAR * _Cdecl rdbuf();

protected:
        _Cdecl strstreambase(signed char _FAR *, int, signed char _FAR *);
        _Cdecl strstreambase();
        _Cdecl ~strstreambase();
private:
        strstreambuf buf;
};
inline strstreambuf _FAR * _Cdecl strstreambase::rdbuf()
                                    { return &this->buf; }


class _CLASSTYPE istrstream : public strstreambase, public istream {
public:
        _Cdecl istrstream(signed char _FAR *);
        _Cdecl istrstream(unsigned char _FAR *);
        _Cdecl istrstream(signed char _FAR *, int);
        _Cdecl istrstream(unsigned char _FAR *, int);
        _Cdecl ~istrstream();
};


class _CLASSTYPE ostrstream : public strstreambase, public ostream {
public:
        _Cdecl ostrstream(signed char _FAR *, int, int = ios::out);
        _Cdecl ostrstream(unsigned char _FAR *, int, int = ios::out);
        _Cdecl ostrstream();
        _Cdecl ~ostrstream();

    char _FAR * _Cdecl str();
    int     _Cdecl pcount();
};
inline char _FAR * _Cdecl ostrstream::str()
                { return strstreambase::rdbuf()->str(); }
inline int  _Cdecl ostrstream::pcount()
                { return strstreambase::rdbuf()->out_waiting(); }


class _CLASSTYPE strstream : public strstreambase, public iostream {
public:
        _Cdecl strstream();
        _Cdecl strstream(signed char _FAR *, int _sz, int _m);
        _Cdecl strstream(unsigned char _FAR *, int _sz, int _m);
        _Cdecl ~strstream();

    char _FAR * _Cdecl str();
};
inline char _FAR * _Cdecl strstream::str()
                { return strstreambase::rdbuf()->str(); }

#pragma option -Vo.
#if defined(__BCOPT__)
#pragma option -po.
#endif

#endif
pkBGI Device Driver (HERC) 2.00 - Mar 21 1988
Copyright (c) 1987,1988 Borland International
                           HERC                 U ]CB      BY   b   $PUo    r                 ;=?AØ         .> u ˸ " t   ˺$
@ ûe &$. &CC&CC<s
2"t2"y@uÀu> tÀ> u>&?<u 
&GCË&؋ 	
<t  > u |                               [[(#XL  720 x 348 HERCULES <u<u2Ê2@<s 2 &$> u02<r<t#6?6AA?3ɶO22ø  K3À> t3"t"tÉó:v:vããQRȋӇ ZYË6>8    <rU,2@
w> t u u >  Ъ ª2ҳs
uÀ> t"t <t3ۃ	w                  >uK&"t*SQEY[>uKC"x=&  SQrZRY[ x<t
2؋	                       ? (  ? (   (  P  [Z  P  ]Z  <r2
؁C7?G9AG3G0W2P Xش>2t2$ø ø ø@ 0  33 @5-.[WW  3۹ PSQ؎ 2BJY03X󫺸X
@ ûe &Â4t  Á4tðÁ  .3.+3    QuZS$
2.[YQɀuZ    QuPS$
2.[YQɀuP;7w;7w;9w;9vËv>5;rډF^F ;rF쀑+F+ډ^/F^;rF^+؉^+؉^  ^F+ÉF+ÉF  ^V~vF$>s$
F> t@> t fnnE5s t&0'
&"
&S2j"yCCh[Muƀuh֨@uŀuC5s t&0'
&"
&Muƀu֨@uŀuCh5s t&0'
&"
&뽋NV<s <r3р> t"Ŋf"uufv<sF t  ^0<r^㎇<u   U  AEIUQ&&0
&  "&"
&;r;rڋ6> uw+B0S273ދ+â5> t@[PVQS 2^[ .> u.	[ .	].2PSUW.> t.6uV/ ^ .> t w;rw_][Xh.0uSM#t.3GMu.> t.5"*.> u:Z}
.3Gĳ".3Ã.> u? U2BW<s <r3؋ֹ?&"t""uȆ0[&s
t  Àr㎇u                  @8px<iZ-KB$$B3333     "  "                          &
䀈&
$"uÈ
"u
- 
- 
;;|>?+>
;s;=|>A+>
;sSQ _^.
..
PS&V  .
 Ou[8 XuE.
uu7"
7.> u"xCu.
.>s
.h.
.h.
<0uO2<Ar<{r2<r#  |  &&Wt n ^
>
 tA&F &^&N&V
 ֖Muڽ
|
> t"t	"8l  ||    |~  x00000x |     ||  || x`0x 000000 | l8  l8l f< 0` <00000< `0 <<  8l           00       |~~    |~ ~v   |~ 0|0000   ~v|  8<  8 8<         ||     ~v  np```   || 00|000   ~   l8   l   l8l   v|  0` 
 
QSQذaY^VQWS:X [SP.
>f "uE&'.h[_GYXX                                                                ++BQS_[u.> t.	.PRV+ ^ZX.>r.h.h.uԋìଊ#t	&%GJ"&%G   |lpt&0&
& "&"
&+BS2b_ދ+âa> t@[PVQS^[ .> u.	[ .	Z.PSRW _Z[X.h.uSJ2#t._G嬊J.> t.a"*.> u:Z}._G2"._Ã.> uVKFyy0222Ã> t022拄\&"
&Ëڋǃ玅P ڋǃ玅Z 拄|&"
&øZ P RZ 拄|&"
&p ΃A&$Ëǃ玅P ǃ玅Z ΀&$øZ P RZ R蜿P s  Ztr> tr&  ރ	> t"tRMMF 9+MMF   ?MMv  MM~ Zk&"":t2%[N EEu
&Ë~ EEv EE^ EE"SP$x Xtu> u s5 % r+ ; 떡@;uH9~@9áH;t2;sF4;t02&-;6;tN> utO&-"":t8""
;6;t&N> ut&-O&-t& &-Fɀ> utG&-6à&-:u&;6|+6Oa&-"":t8""
;6?}&Fɀ> ut&-G&-t &-N6&-:u&;6s6GÀFɀ> utG &"":u^>u
&t> t:u
t
? u)":t!urMM^ MMv MM~ MMN ;6sn&:u&+&:u;6G&"":t!+Q.&:-u;s6GYÉ6>
 &ËÊt	؀> t"tPR9% > uZwЀ> t u&[Ë6>&&> u2ƴts "t"uÀuSQPwu2
C"u2XY[mP > t ;?+@9+A9+=X%6KPS22ËG[XKu  ÁCuǰÁ  KPCPKZCZà2<r$<s SӃ<t4KSӃuZ.[CSӃuZKSӃuP.[CSӃuP? ?@??  0    @       /*  new.h

    Access to operator new() and newhandler()

    Copyright (c) 1990, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__NEW_H)
#define __NEW_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef __cplusplus
#error Must use C++ with new.h
#endif

typedef void (_FAR * _FARFUNC pvf)();

extern void (_FAR * _Cdecl _FARFUNC _new_handler)();

void (_FAR * _FARFUNC set_new_handler( void (_FAR * _FARFUNC )() ))();

#ifdef __MSC
#define _set_new_handler(f) set_new_handler(f)
#endif

void _FAR * _FARFUNC operator new( unsigned );

#endif  /* __NEW_H */

/*****************************************************************************\
*                                                                             *
* cderr.h -     Common dialog error return codes                              *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef __CDERR_H       /* prevent multiple includes */
#define __CDERR_H

#define CDERR_DIALOGFAILURE   0xFFFF

#define CDERR_GENERALCODES     0x0000
#define CDERR_STRUCTSIZE       0x0001
#define CDERR_INITIALIZATION   0x0002
#define CDERR_NOTEMPLATE       0x0003
#define CDERR_NOHINSTANCE      0x0004
#define CDERR_LOADSTRFAILURE   0x0005
#define CDERR_FINDRESFAILURE   0x0006
#define CDERR_LOADRESFAILURE   0x0007
#define CDERR_LOCKRESFAILURE   0x0008
#define CDERR_MEMALLOCFAILURE  0x0009
#define CDERR_MEMLOCKFAILURE   0x000A
#define CDERR_NOHOOK           0x000B
#define CDERR_REGISTERMSGFAIL  0x000C

#define PDERR_PRINTERCODES     0x1000
#define PDERR_SETUPFAILURE     0x1001
#define PDERR_PARSEFAILURE     0x1002
#define PDERR_RETDEFFAILURE    0x1003
#define PDERR_LOADDRVFAILURE   0x1004
#define PDERR_GETDEVMODEFAIL   0x1005
#define PDERR_INITFAILURE      0x1006
#define PDERR_NODEVICES        0x1007
#define PDERR_NODEFAULTPRN     0x1008
#define PDERR_DNDMMISMATCH     0x1009
#define PDERR_CREATEICFAILURE  0x100A
#define PDERR_PRINTERNOTFOUND  0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C

#define CFERR_CHOOSEFONTCODES  0x2000
#define CFERR_NOFONTS          0x2001
#define CFERR_MAXLESSTHANMIN   0x2002

#define FNERR_FILENAMECODES    0x3000
#define FNERR_SUBCLASSFAILURE  0x3001
#define FNERR_INVALIDFILENAME  0x3002
#define FNERR_BUFFERTOOSMALL   0x3003

#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001

#define CCERR_CHOOSECOLORCODES 0x5000

#endif  /* __CDERR_H */
/*  stddef.h

    Definitions for common types, and NULL

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __STDDEF_H
#define __STDDEF_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef NULL
#include <_null.h>
#endif

#ifndef _PTRDIFF_T
#define _PTRDIFF_T
#if     defined(__LARGE__) || defined(__HUGE__) || defined(__COMPACT__)
typedef long    ptrdiff_t;
#else
typedef int     ptrdiff_t;
#endif
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#define offsetof( s_name, m_name )  (size_t)&(((s_name _FAR *)0)->m_name)

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif

#endif  /* __STDDEF_H */
/*  io.h

    Definitions for low level I/O functions.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __IO_H
#define __IO_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(___NFILE_H)
#include <_nfile.h>
#endif

#define HANDLE_MAX  (_NFILE_)

extern  unsigned int    _Cdecl _nfile;

struct  ftime   {
    unsigned    ft_tsec  : 5;   /* Two second interval */
    unsigned    ft_min   : 6;   /* Minutes */
    unsigned    ft_hour  : 5;   /* Hours */
    unsigned    ft_day   : 5;   /* Days */
    unsigned    ft_month : 4;   /* Months */
    unsigned    ft_year  : 7;   /* Year */
};

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0

#ifdef __cplusplus
extern "C" {
#endif
int  _Cdecl _FARFUNC access   (const char _FAR *path, int amode);
#ifdef __IN_CHMOD
int  _Cdecl _FARFUNC _chmod   ();
#else
int  _Cdecl _FARFUNC _chmod   (const char _FAR *__pathname, int __func, ... );
#endif
int  _Cdecl _FARFUNC chmod    (const char _FAR *__path, int __amode);
int  _Cdecl _FARFUNC chsize   (int __handle, long __size);
int  _CType _FARFUNC _close   (int __handle);
int  _CType _FARFUNC close    (int __handle);
int  _CType _FARFUNC _creat   (const char _FAR *__path, int __attribute);
int  _CType _FARFUNC creat    (const char _FAR *__path, int __amode);
int  _Cdecl _FARFUNC creatnew (const char _FAR *__path, int __mode); /* DOS 3.0 or later */
int  _Cdecl _FARFUNC creattemp(char _FAR *__path, int __amode); /* DOS 3.0 or later */
int  _Cdecl dup      (int __handle);
int  _Cdecl dup2     (int __oldhandle, int __newhandle);
int  _Cdecl _FARFUNC eof      (int __handle);
long _Cdecl _FARFUNC filelength   (int __handle);
int  _Cdecl getftime     (int __handle, struct ftime _FAR *__ftimep);
#ifdef __IN_IOCTL
int  _Cdecl ioctl    ();
#else
int  _Cdecl _FARFUNC ioctl    (int __handle, int __func, ...);
        /* optional 3rd and 4th args are: void _FAR * __argdx, int argcx */
#endif

int  _Cdecl isatty   (int __handle);
int  _Cdecl _FARFUNC lock     (int __handle, long __offset, long __length);
int  _Cdecl _FARFUNC locking  (int __handle, int __mode, long __length);
long _CType lseek    (int __handle, long __offset, int __fromwhere);
char _FAR * _FARFUNC _Cdecl mktemp( char _FAR *__template );
#ifdef __IN_OPEN
int  _Cdecl _FARFUNC open();
#else
int _Cdecl _FARFUNC open(const char _FAR *__path, int __access,... /*unsigned mode*/);
#endif
int  _CType _FARFUNC _open    (const char _FAR *__path, int __oflags);
int  _CType _FARFUNC read     (int __handle, void _FAR *__buf, unsigned __len);
int  _CType _read    (int __handle, void _FAR *__buf, unsigned __len);
int  _CType remove   (const char _FAR *__path);
int  _CType _FARFUNC rename   (const char _FAR *__oldname,const char _FAR *__newname);
int  _Cdecl setftime (int __handle, struct ftime _FAR *__ftimep);
int  _Cdecl _FARFUNC setmode  (int __handle, int __amode);

#ifdef __IN_SOPEN
int  _Cdecl sopen();
#else
int  _Cdecl sopen    (const char _FAR *__path, int __access, int __shflag,
                      ... /* unsigned mode */);
#endif
long _Cdecl tell     (int __handle);
unsigned _Cdecl umask    (unsigned __cmask);
int  _CType unlink   (const char _FAR *__path);
int  _Cdecl _FARFUNC unlock   (int __handle, long __offset, long __length);
int  _CType _FARFUNC _write   (int __handle, const void _FAR *__buf, unsigned __len);
int  _CType _FARFUNC write    (int __handle, const void _FAR *__buf, unsigned __len);
void _Cdecl _InitEasyWin(void);  /* Initialization call for Easy Windows */

#ifdef __MSC
#define _dup(h) dup(h)
#endif

#ifdef __cplusplus
}
#endif

#endif  /* __IO_H */
/*****************************************************************************\
*                                                                             *
* lzexpand.h    Public interfaces for LZEXPAND.DLL.                           *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               NOTE: windows.h must be included first if LIB is NOT #defined *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with LZEXP?.LIB (default is for LZEXPAND.DLL)
*                 NOTE: Not compatible with windows.h if LIB is #defined
*
\*****************************************************************************/

#ifndef __LZEXPAND_H    /* prevent multiple includes */
#define __LZEXPAND_H

#if !defined(__WINDOWS_H) && !defined(LIB)
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#define LZAPI           _pascal

#ifndef WINAPI          /* don't declare if they're already declared */
#define WINAPI          _far _pascal
#define NEAR            _near
#define FAR             _far
#define PASCAL          _pascal
typedef int             BOOL;
#define TRUE            1
#define FALSE           0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT        void            /* Not used by the .lib version */
#endif  /* WINAPI */

#else   /* LIB */

#define LZAPI           _far _pascal

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* WIN3.0 */

#endif  /* !LIB */

/****** Error return codes ***************************************************/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of range */
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */

/****** Public functions *****************************************************/

int     LZAPI LZStart(void);
void    LZAPI LZDone(void);
LONG    LZAPI CopyLZFile(HFILE, HFILE);
LONG    LZAPI LZCopy(HFILE, HFILE);
HFILE   LZAPI LZInit(HFILE);
int     LZAPI GetExpandedName(LPCSTR, LPSTR);
HFILE   LZAPI LZOpenFile(LPCSTR, OFSTRUCT FAR*, UINT);
LONG    LZAPI LZSeek(HFILE, LONG, int);
int     LZAPI LZRead(HFILE, void FAR*, int);
void    LZAPI LZClose(HFILE);

#ifdef __cplusplus
}       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* __LZEXPAND_H */
/*  process.h

    Symbols and structures for process management.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if !defined(__PROCESS_H)
#define __PROCESS_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

/*  Modes available as first argument to the spawnxx functions. */

#define P_WAIT    0 /* child runs separately, parent waits until exit */
#define P_NOWAIT  1 /* both concurrent -- not implemented */
#define P_OVERLAY 2 /* child replaces parent, parent no longer exists */

#define P_NOWAITO 3 /* ASYNCH,       toss RC    */
#define P_DETACH  4 /* DETACHED,     toss RC    */

#define WAIT_CHILD       0
#define WAIT_GRANDCHILD      1

/*  MSDOS does not have any abstract identifier for a process, but the
    process Program Segment Prefix location provides a similar token.
*/

extern  unsigned _Cdecl _psp;    /* provided unconditionally in dos.h */

#define  getpid()   (_psp)

#ifdef __cplusplus
extern "C" {
#endif
void _Cdecl abort(void);
void _Cdecl _cexit(void);
void _Cdecl _c_exit(void);
int  _Cdecl execl(char _FAR *__path, char _FAR *__arg0, ...);
int  _Cdecl execle(char _FAR *__path, char _FAR *__arg0, ...);
int  _Cdecl execlp(char _FAR *__path, char _FAR *__arg0, ...);
int  _Cdecl execlpe(char _FAR *__path, char _FAR *__arg0, ...);
int  _Cdecl execv(char _FAR *__path, char _FAR *__argv[]);
int  _Cdecl execve(char _FAR *__path, char _FAR *__argv[], char _FAR *_FAR *__env);
int  _Cdecl execvp(char _FAR *__path, char _FAR *__argv[]);
int  _Cdecl execvpe(char _FAR *__path, char _FAR *__argv[], char _FAR *_FAR *__env);
void _Cdecl exit(int __status);
void _Cdecl _exit(int __status);
int  _Cdecl spawnl(int __mode, char _FAR *__path, char _FAR *__arg0, ...);
int  _Cdecl spawnle(int __mode, char _FAR *__path, char _FAR *__arg0, ...);
int  _Cdecl spawnlp(int __mode, char _FAR *__path, char _FAR *__arg0, ...);
int  _Cdecl spawnlpe(int __mode, char _FAR *__path, char _FAR *__arg0, ...);
int  _Cdecl spawnv(int __mode, char _FAR *__path, char _FAR *__argv[]);
int  _Cdecl spawnve(int __mode, char _FAR *__path, char _FAR *__argv[], char _FAR *_FAR *__env);
int  _Cdecl spawnvp(int __mode, char _FAR *__path, char _FAR *__argv[]);
int  _Cdecl spawnvpe(int __mode, char _FAR *__path, char _FAR *__argv[], char _FAR *_FAR *__env);
int  _Cdecl _FARFUNC system(const char _FAR *__command);
#ifdef __cplusplus
}
#endif

#endif  /* __PROCESS_H */

;*************************************************************************
;
;       WINDOWS.INC - Windows assembly language structures & constants
;
;*************************************************************************
;
; Conditional Block includes:   (True states)
;     NOTEXT - don't include TextMetric struc & text drawing modes & stock objs.
;     NORASTOPS - don't include binary and ternary raster ops.
;     NOVK      - don't include virtual key definitions
;     NOMB      - don't include message box definitions
;     NOWM      - don't include window messages
;
;
FALSE   =       0
TRUE    =       1
NULL    =       0

;*******************************************************************
;
;       Rectangle
;
;*******************************************************************

RECT    struc
        rcLeft          dw      ?
        rcTop           dw      ?
        rcRight         dw      ?
        rcBottom        dw      ?
RECT    ends

;*******************************************************************
;
;  Window Class structure
;
;*******************************************************************

WNDCLASS struc
        clsStyle        dw      ?       ; class style
        clsLpfnWndProc  dd      ?
        clsCbClsExtra   dw      ?
        clsCbWndExtra   dw      ?
        clsHInstance    dw      ?       ; instance handle
        clsHIcon        dw      ?       ; class icon handle
        clsHCursor      dw      ?       ; class cursor handle
        clsHbrBackground dw     ?       ; class background brush
        clsLpszMenuName dd      ?       ; menu name
        clsLpszClassName dd     ?       ; far ptr to class name
WNDCLASS ends

IFNDEF NOTEXT
TEXTMETRIC struc
    tmHeight        dw      ?
    tmAscent        dw      ?
    tmDescent       dw      ?
    tmIntLeading    dw      ?
    tmExtLeading    dw      ?
    tmAveCharWidth  dw      ?
    tmMaxCharWidth  dw      ?
    tmWeight        dw      ?
    tmItalic        db      ?
    tmUnderlined    db      ?
    tmStruckOut     db      ?
    tmFirstChar     db      ?
    tmLastChar      db      ?
    tmDefaultChar   db      ?
    tmBreakChar     db      ?
    tmPitch         db      ?
    tmCharSet       db      ?
    tmOverhang      dw      ?
    tmAspectX       dw      ?
    tmAspectY       dw      ?
TEXTMETRIC ends

LF_FACESIZE     EQU     32

LOGFONT struc
    lfHeight          dw   ?
    lfWidth           dw   ?
    lfEscapement      dw   ?
    lfOrientation     dw   ?
    lfWeight          dw   ?
    lfItalic          db   ?
    lfUnderline       db   ?
    lfStrikeOut       db   ?
    lfCharSet         db   ?
    lfOutPrecision    db   ?
    lfClipPrecision   db   ?
    lfQuality         db   ?
    lfPitchAndFamily  db   ?
    lfFaceName        db   LF_FACESIZE dup(?)
LOGFONT ends

LOGBRUSH struc
    lbStyle         dw ?
    lbColor         dd ?
    lbHatch         dw ?
LOGBRUSH ends

;
;  Text Drawing modes
;
TRANSPARENT     = 1
OPAQUE          = 2
;
; Mapping Modes
;
MM_TEXT         =   1
MM_LOMETRIC     =   2
MM_HIMETRIC     =   3
MM_LOENGLISH    =   4
MM_HIENGLISH    =   5
MM_TWIPS        =   6
MM_ISOTROPIC    =   7
MM_ANISOTROPIC  =   8
;
; Coordinate Modes
;
ABSOLUTE        =   1
RELATIVE        =   2
;
;  Stock Logical Objects
;
WHITE_BRUSH         =  0
LTGRAY_BRUSH        =  1
GRAY_BRUSH          =  2
DKGRAY_BRUSH        =  3
BLACK_BRUSH         =  4
NULL_BRUSH          =  5
HOLLOW_BRUSH        =  5
WHITE_PEN           =  6
BLACK_PEN           =  7
NULL_PEN            =  8
DOT_MARKER          =  9
OEM_FIXED_FONT      = 10
ANSI_FIXED_FONT     = 11
ANSI_VAR_FONT       = 12
SYSTEM_FONT         = 13
DEVICE_DEFAULT_FONT = 14
DEFAULT_PALETTE     = 15
SYSTEM_FIXED_FONT   = 16
ENDIF
;
; Brush Styles
;
BS_SOLID        =   0
BS_NULL         =   1
BS_HOLLOW       =   BS_NULL
BS_HATCHED      =   2
BS_PATTERN      =   3
BS_INDEXED      =   4
BS_DIBPATTERN   =   5
;
; Hatch Styles
;
HS_HORIZONTAL   =   0       ; -----
HS_VERTICAL     =   1       ; |||||
HS_FDIAGONAL    =   2       ; \\\\\
HS_BDIAGONAL    =   3       ; /////
HS_CROSS        =   4       ; +++++
HS_DIAGCROSS    =   5       ; xxxxx
;
; Pen Styles
;
PS_SOLID        =   0
PS_DASH         =   1       ; -------
PS_DOT          =   2       ; .......
PS_DASHDOT      =   3       ; _._._._
PS_DASHDOTDOT   =   4       ; _.._.._
PS_NULL         =   5
PS_INSIDEFRAME  =   6
;
; Device Parameters for GetDeviceCaps()
;
DRIVERVERSION =0     ; Device driver version
TECHNOLOGY    =2     ; Device classification
HORZSIZE      =4     ; Horizontal size in millimeters
VERTSIZE      =6     ; Vertical size in millimeters
HORZRES       =8     ; Horizontal width in pixels
VERTRES       =10    ; Vertical width in pixels
BITSPIXEL     =12    ; Number of bits per pixel
PLANES        =14    ; Number of planes
NUMBRUSHES    =16    ; Number of brushes the device has
NUMPENS       =18    ; Number of pens the device has
NUMMARKERS    =20    ; Number of markers the device has
NUMFONTS      =22    ; Number of fonts the device has
NUMCOLORS     =24    ; Number of colors the device supports
PDEVICESIZE   =26    ; Size required for device descriptor
CURVECAPS     =28    ; Curve capabilities
LINECAPS      =30    ; Line capabilities
POLYGONALCAPS =32    ; Polygonal capabilities
TEXTCAPS      =34    ; Text capabilities
CLIPCAPS      =36    ; Clipping capabilities
RASTERCAPS    =38    ; Bitblt capabilities
ASPECTX       =40    ; Length of the X leg
ASPECTY       =42    ; Length of the Y leg
ASPECTXY      =44    ; Length of the hypotenuse

LOGPIXELSX    =88    ; Logical pixels/inch in X
LOGPIXELSY    =90    ; Logical pixels/inch in Y

SIZEPALETTE   =104   ; Number of entries in physical palette
NUMRESERVED   =106   ; Number of reserved entries in palette
COLORRES      =108   ; Actual color resolution
;
ifndef NOGDICAPMASKS
;
; Device Capability Masks:
;
; Device Technologies
DT_PLOTTER       =   0  ; /* Vector plotter                   */
DT_RASDISPLAY    =   1  ; /* Raster display                   */
DT_RASPRINTER    =   2  ; /* Raster printer                   */
DT_RASCAMERA     =   3  ; /* Raster camera                    */
DT_CHARSTREAM    =   4  ; /* Character-stream, PLP            */
DT_METAFILE      =   5  ; /* Metafile, VDM                    */
DT_DISPFILE      =   6  ; /* Display-file                     */
;
; Curve Capabilities
CC_NONE          =   0  ; /* Curves not supported             */
CC_CIRCLES       =   1  ; /* Can do circles                   */
CC_PIE           =   2  ; /* Can do pie wedges                */
CC_CHORD         =   4  ; /* Can do chord arcs                */
CC_ELLIPSES      =   8  ; /* Can do ellipese                  */
CC_WIDE          =   16 ; /* Can do wide lines                */
CC_STYLED        =   32 ; /* Can do styled lines              */
CC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
CC_INTERIORS     =   128; /* Can do interiors                 */
;
; Line Capabilities
LC_NONE          =   0  ; /* Lines not supported              */
LC_POLYLINE      =   2  ; /* Can do polylines                 */
LC_MARKER        =   4  ; /* Can do markers                   */
LC_POLYMARKER    =   8  ; /* Can do polymarkers               */
LC_WIDE          =   16 ; /* Can do wide lines                */
LC_STYLED        =   32 ; /* Can do styled lines              */
LC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
LC_INTERIORS     =   128; /* Can do interiors                 */
;
; Polygonal Capabilities
PC_NONE          =   0  ; /* Polygonals not supported         */
PC_POLYGON       =   1  ; /* Can do polygons                  */
PC_RECTANGLE     =   2  ; /* Can do rectangles                */
PC_WINDPOLYGON   =   4  ; /* Can do winding polygons          */
PC_TRAPEZOID     =   4  ; /* Can do trapezoids                */
PC_SCANLINE      =   8  ; /* Can do scanlines                 */
PC_WIDE          =   16 ; /* Can do wide borders              */
PC_STYLED        =   32 ; /* Can do styled borders            */
PC_WIDESTYLED    =   64 ; /* Can do wide styled borders       */
PC_INTERIORS     =   128; /* Can do interiors                 */
;
; Polygonal Capabilities */
CP_NONE          =   0  ; /* No clipping of output            */
CP_RECTANGLE     =   1  ; /* Output clipped to rects          */
;
; Text Capabilities
TC_OP_CHARACTER  =   0001h ; /* Can do OutputPrecision   CHARACTER      */
TC_OP_STROKE     =   0002h ; /* Can do OutputPrecision   STROKE         */
TC_CP_STROKE     =   0004h ; /* Can do ClipPrecision     STROKE         */
TC_CR_90         =   0008h ; /* Can do CharRotAbility    90             */
TC_CR_ANY        =   0010h ; /* Can do CharRotAbility    ANY            */
TC_SF_X_YINDEP   =   0020h ; /* Can do ScaleFreedom      X_YINDEPENDENT */
TC_SA_DOUBLE     =   0040h ; /* Can do ScaleAbility      DOUBLE         */
TC_SA_INTEGER    =   0080h ; /* Can do ScaleAbility      INTEGER        */
TC_SA_CONTIN     =   0100h ; /* Can do ScaleAbility      CONTINUOUS     */
TC_EA_DOUBLE     =   0200h ; /* Can do EmboldenAbility   DOUBLE         */
TC_IA_ABLE       =   0400h ; /* Can do ItalisizeAbility  ABLE           */
TC_UA_ABLE       =   0800h ; /* Can do UnderlineAbility  ABLE           */
TC_SO_ABLE       =   1000h ; /* Can do StrikeOutAbility  ABLE           */
TC_RA_ABLE       =   2000h ; /* Can do RasterFontAble    ABLE           */
TC_VA_ABLE       =   4000h ; /* Can do VectorFontAble    ABLE           */
TC_RESERVED      =   8000h
;
; Raster Capabilities
RC_BITBLT        =   1      ; /* Can do standard BLT.             */
RC_BANDING       =   2      ; /* Device requires banding support  */
RC_SCALING       =   4      ; /* Device requires scaling support  */
RC_BITMAP64      =   8      ; /* Device can support >64K bitmap   */
RC_GDI20_OUTPUT  =   0010h  ; /* has 2.0 output calls         */
RC_DI_BITMAP     =   0080h  ; /* supports DIB to memory       */
RC_PALETTE       =   0100h  ; /* supports a palette           */
RC_DIBTODEV      =   0200h  ; /* supports DIBitsToDevice      */
RC_BIGFONT       =   0400h  ; /* supports >64K fonts          */
RC_STRETCHBLT    =   0800h  ; /* supports StretchBlt          */
RC_FLOODFILL     =   1000h  ; /* supports FloodFill           */
RC_STRETCHDIB    =   2000h  ; /* supports StretchDIBits       */

endif       ;NOGDICAPMASKS

; palette entry flags
;
PC_RESERVED     = 1    ;/* palette index used for animation */
PC_EXPLICIT     = 2    ;/* palette index is explicit to device */
PC_NOCOLLAPSE   = 4    ;/* do not match color to system palette */

; DIB color table identifiers
;
DIB_RGB_COLORS  = 0    ;/* color table in RGBTriples */
DIB_PAL_COLORS  = 1    ;/* color table in palette indices */
;

;constants for Get/SetSystemPaletteUse()
;
SYSPAL_STATIC   = 1
SYSPAL_NOSTATIC = 2

; constants for CreateDIBitmap
CBM_INIT        = 4    ;/* initialize bitmap */
;
; Bitmap format constants
BI_RGB          = 0
BI_RLE8         = 1
BI_RLE4         = 2
;
;
ANSI_CHARSET    = 0
SYMBOL_CHARSET  = 2
OEM_CHARSET     = 255
;
;  styles for CombineRgn
;
RGN_AND  = 1
RGN_OR   = 2
RGN_XOR  = 3
RGN_DIFF = 4
RGN_COPY = 5
;
;  Predefined cursor & icon IDs
;
IDC_ARROW       = 32512
IDC_IBEAM       = 32513
IDC_WAIT        = 32514
IDC_CROSS       = 32515
IDC_UPARROW     = 32516
IDC_SIZE        = 32640
IDC_ICON        = 32641
IDC_SIZENWSE    = 32642
IDC_SIZENESW    = 32643
IDC_SIZEWE      = 32644
IDC_SIZENS      = 32645

IDI_APPLICATION = 32512
IDI_HAND        = 32513
IDI_QUESTION    = 32514
IDI_EXCLAMATION = 32515
IDI_ASTERISK    = 32516

;
; OEM Resource Ordinal Numbers */
;
OBM_CLOSE         =  32754
OBM_UPARROW       =  32753
OBM_DNARROW       =  32752
OBM_RGARROW       =  32751
OBM_LFARROW       =  32750
OBM_REDUCE        =  32749
OBM_ZOOM          =  32748
OBM_RESTORE       =  32747
OBM_REDUCED       =  32746
OBM_ZOOMD         =  32745
OBM_RESTORED      =  32744
OBM_UPARROWD      =  32743
OBM_DNARROWD      =  32742
OBM_RGARROWD      =  32741
OBM_LFARROWD      =  32740
OBM_MNARROW       =  32739
OBM_COMBO         =  32738
OBM_UPARROWI      =  32737
OBM_DNARROWI      =  32736
OBM_RGARROWI      =  32735
OBM_LFARROWI      =  32734

OBM_OLD_CLOSE     =  32767
OBM_SIZE          =  32766
OBM_OLD_UPARROW   =  32765
OBM_OLD_DNARROW   =  32764
OBM_OLD_RGARROW   =  32763
OBM_OLD_LFARROW   =  32762
OBM_BTSIZE        =  32761
OBM_CHECK         =  32760
OBM_CHECKBOXES    =  32759
OBM_BTNCORNERS    =  32758
OBM_OLD_REDUCE    =  32757
OBM_OLD_ZOOM      =  32756
OBM_OLD_RESTORE   =  32755

OCR_NORMAL        =  32512
OCR_IBEAM         =  32513
OCR_WAIT          =  32514
OCR_CROSS         =  32515
OCR_UP            =  32516
OCR_SIZE          =  32640
OCR_ICON          =  32641
OCR_SIZENWSE      =  32642
OCR_SIZENESW      =  32643
OCR_SIZEWE        =  32644
OCR_SIZENS        =  32645
OCR_SIZEALL       =  32646
OCR_ICOCUR        =  32647

OIC_SAMPLE        =  32512
OIC_HAND          =  32513
OIC_QUES          =  32514
OIC_BANG          =  32515
OIC_NOTE          =  32516

;
;   Scroll bar constants
;
SB_HORZ = 0
SB_VERT = 1
SB_CTL  = 2
SB_BOTH = 3
;
;   Scroll Commands
;
SB_LINEUP        = 0
SB_LINEDOWN      = 1
SB_PAGEUP        = 2
SB_PAGEDOWN      = 3
SB_THUMBPOSITION = 4
SB_THUMBTRACK    = 5
SB_TOP           = 6
SB_BOTTOM        = 7
SB_ENDSCROLL     = 8
;
;  MessageBox type flags
;
IFNDEF                  NOMB
MB_OK                   = 0000H
MB_OKCANCEL             = 0001H
MB_ABORTRETRYIGNORE     = 0002H
MB_YESNOCANCEL          = 0003H
MB_YESNO                = 0004H
MB_RETRYCANCEL          = 0005H

MB_ICONHAND             = 0010H
MB_ICONQUESTION         = 0020H
MB_ICONEXCLAMATION      = 0030H
MB_ICONASTERISK         = 0040H

MB_DEFBUTTON1           = 0000H
MB_DEFBUTTON2           = 0100H
MB_DEFBUTTON3           = 0200H

MB_APPLMODAL            = 0000H
MB_SYSTEMMODAL          = 1000H
MB_TASKMODAL            = 2000H

MB_NOFOCUS              = 8000H

;
;  Conventional dialog box and message box command IDs
;
IDOK     =   1
IDCANCEL =   2
IDABORT  =   3
IDRETRY  =   4
IDIGNORE =   5
IDYES    =   6
IDNO     =   7
;
;  Flags for OpenFile
;
OF_READ             = 0000H
OF_WRITE            = 0001H
OF_READWRITE        = 0002H
OF_SHARE_COMPAT     = 0000H
OF_SHARE_EXCLUSIVE  = 0010H
OF_SHARE_DENY_WRITE = 0020H
OF_SHARE_DENY_READ  = 0030H
OF_SHARE_DENY_NONE  = 0040H
OF_PARSE            = 0100H
OF_DELETE           = 0200H
OF_VERIFY           = 0400H     ; Used with OF_REOPEN
OF_SEARCH           = 0400H     ; Used without OF_REOPEN
OF_CANCEL           = 0800H
OF_CREATE           = 1000H
OF_PROMPT           = 2000H
OF_EXIST            = 4000H
OF_REOPEN           = 8000H

TF_FORCEDRIVE   = 80H

OPENSTRUC       STRUC
opLen   db      ?
opDisk  db      ?
opXtra  dw      ?
opDate  dw      ?
opTime  dw      ?
opFile  db      120 dup (?)
OPENSTRUC       ENDS
;
;  DrawText format flags
;
DT_LEFT         = 00H
DT_CENTER       = 01H
DT_RIGHT        = 02H
DT_TOP          = 00H
DT_VCENTER      = 04H
DT_BOTTOM       = 08H
DT_WORDBREAK    = 10H
DT_SINGLELINE   = 20H
DT_EXPANDTABS   = 40H
DT_TABSTOP      = 80H
DT_NOCLIP       =    0100H
DT_EXTERNALLEADING = 0200H
DT_CALCRECT     =    0400H
DT_NOPREFIX     =    0800H
DT_INTERNAL     =    1000H
ENDIF

;
; ExtFloodFill style flags
;
FLOODFILLBORDER  =  0
FLOODFILLSURFACE =  1

;
; Memory manager flags
;
LMEM_FIXED      =   0000h
LMEM_MOVEABLE   =   0002h
LMEM_NOCOMPACT  =   0010H
LMEM_NODISCARD  =   0020H
LMEM_ZEROINIT   =   0040h
LMEM_MODIFY     =   0080H
LMEM_DISCARDABLE=   0F00h
LHND    =    LMEM_MOVEABLE+LMEM_ZEROINIT
LPTR    =    LMEM_FIXED+LMEM_ZEROINIT
; Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE)
LMEM_DISCARDED  =   4000H
LMEM_LOCKCOUNT  =   00FFH

NONZEROLHND     =    LMEM_MOVEABLE
NONZEROLPTR     =    LMEM_FIXED



GMEM_FIXED      =   0000h
GMEM_MOVEABLE   =   0002h
GMEM_NOCOMPACT  =   0010h
GMEM_NODISCARD  =   0020h
GMEM_ZEROINIT   =   0040h
GMEM_MODIFY     =   0080h
GMEM_DISCARDABLE=   0100h
GMEM_NOT_BANKED =   1000h
GMEM_DDESHARE   =   2000h
GMEM_SHARE      =   2000h
GMEM_NOTIFY     =   4000h
GMEM_LOWER      =   GMEM_NOT_BANKED
GHND            =   GMEM_MOVEABLE+GMEM_ZEROINIT
GPTR            =   GMEM_FIXED+GMEM_ZEROINIT

; Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE)
GMEM_DISCARDED  =    4000h
GMEM_LOCKCOUNT  =    00FFh

; Flags returned by GetWinFlags

WF_PMODE        =    0001h
WF_CPU286       =    0002h
WF_CPU386       =    0004h
WF_CPU486       =    0008h
WF_STANDARD     =    0010h
WF_WIN286       =    0010h
WF_ENHANCED     =    0020h
WF_WIN386       =    0020h
WF_CPU086       =    0040h
WF_CPU186       =    0080h
WF_LARGEFRAME   =    0100h
WF_SMALLFRAME   =    0200h
WF_80x87        =    0400h
WF_PAGING       =    0800h
WF_WLO          =    8000h

; WEP fSystemExit flag values
WEP_SYSTEM_EXIT =       1
WEP_FREE_DLL    =       0


;  Virtual Keys, Standard Set

IFNDEF          NOVK
VK_LBUTTON      = 01H
VK_RBUTTON      = 02H
VK_CANCEL       = 03H
VK_BACK         = 08H
VK_TAB          = 09H
VK_CLEAR        = 0cH
VK_RETURN       = 0dH
VK_SHIFT        = 10H
VK_CONTROL      = 11H
VK_MENU         = 12H
VK_PAUSE        = 13H
VK_CAPITAL      = 14H
VK_ESCAPE       = 1bH
VK_SPACE        = 20H

VK_PRIOR        = 21H
VK_NEXT         = 22H
VK_END          = 23H
VK_HOME         = 24H
VK_LEFT         = 25H
VK_UP           = 26H
VK_RIGHT        = 27H
VK_DOWN         = 28H

;  VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z'
;  VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0'

VK_PRINT        = 2aH
VK_EXECUTE      = 2bH
VK_SNAPSHOT     = 2ch   ; Printscreen key..
VK_INSERT       = 2dH
VK_DELETE       = 2eH
VK_HELP         = 2fH

VK_NUMPAD0      = 60H
VK_NUMPAD1      = 61H
VK_NUMPAD2      = 62H
VK_NUMPAD3      = 63H
VK_NUMPAD4      = 64H
VK_NUMPAD5      = 65H
VK_NUMPAD6      = 66H
VK_NUMPAD7      = 67H
VK_NUMPAD8      = 68H
VK_NUMPAD9      = 69H
VK_MULTIPLY     = 6AH
VK_ADD          = 6BH
VK_SEPARATER    = 6CH
VK_SUBTRACT     = 6DH
VK_DECIMAL      = 6EH
VK_DIVIDE       = 6FH

VK_F1           = 70H
VK_F2           = 71H
VK_F3           = 72H
VK_F4           = 73H
VK_F5           = 74H
VK_F6           = 75H
VK_F7           = 76H
VK_F8           = 77H
VK_F9           = 78H
VK_F10          = 79H
VK_F11          = 7aH
VK_F12          = 7bH
VK_F13          = 7cH
VK_F14          = 7dH
VK_F15          = 7eH
VK_F16          = 7fH
VK_F17          = 80H
VK_F18          = 81H
VK_F19          = 82H
VK_F20          = 83H
VK_F21          = 84H
VK_F22          = 85H
VK_F23          = 86H
VK_F24          = 87H

VK_NUMLOCK      = 90H
VK_SCROLL       = 91H
ENDIF

IFNDEF NOWH

; SetWindowsHook() codes
WH_MSGFILTER       = (-1)
WH_JOURNALRECORD   = 0
WH_JOURNALPLAYBACK = 1
WH_KEYBOARD        = 2
WH_GETMESSAGE      = 3
WH_CALLWNDPROC     = 4
IFNDEF NOWIN31
WH_CBT             = 5
WH_SYSMSGFILTER    = 6
WH_MOUSE           = 7
WH_HARDWARE        = 8
WH_DEBUG           = 9
ENDIF
;
; Hook Codes
HC_GETLPLPFN       = (-3)
HC_LPLPFNNEXT      = (-2)
HC_LPFNNEXT        = (-1)
HC_ACTION          = 0
HC_GETNEXT         = 1
HC_SKIP            = 2
HC_NOREM           = 3
HC_NOREMOVE        = 3
HC_SYSMODALON      = 4
HC_SYSMODALOFF     = 5
;
; CBT Hook Codes
HCBT_MOVESIZE      = 0
HCBT_MINMAX        = 1
HCBT_QS            = 2
HCBT_CREATEWND     = 3
HCBT_DESTROYWND    = 4
HCBT_ACTIVATE      = 5
HCBT_CLICKSKIPPED  = 6
HCBT_KEYSKIPPED    = 7
HCBT_SYSCOMMAND    = 8
HCBT_SETFOCUS      = 9

;
; WH_MSGFILTER Filter Proc Codes
MSGF_DIALOGBOX     = 0
MSGF_MENU          = 2
MSGF_MOVE          = 3
MSGF_SIZE          = 4
MSGF_SCROLLBAR     = 5
MSGF_NEXTWINDOW    = 6
;
; Window Manager Hook Codes
WC_INIT            = 1
WC_SWP             = 2
WC_DEFWINDOWPROC   = 3
WC_MINMAX          = 4
WC_MOVE            = 5
WC_SIZE            = 6
WC_DRAWCAPTION     = 7
;

; Message Structure used in Journaling
EVENTMSG    struc
    message     dw ?
    paramL      dw ?
    paramH      dw ?
    time        dd ?
EVENTMSG    ends

ENDIF ;NOWH

; Window field offsets for GetWindowLong() and GetWindowWord()
GWL_WNDPROC       =  (-4)
GWW_HINSTANCE     =  (-6)
GWW_HWNDPARENT    =  (-8)
GWW_ID            =  (-12)
GWL_STYLE         =  (-16)
GWL_EXSTYLE       =  (-20)

; GetWindow() Constants
GW_HWNDFIRST      =  0
GW_HWNDLAST       =  1
GW_HWNDNEXT       =  2
GW_HWNDPREV       =  3
GW_OWNER          =  4
GW_CHILD          =  5

; Class field offsets for GetClassLong() and GetClassWord()
GCL_MENUNAME      =  (-8)
GCW_HBRBACKGROUND =  (-10)
GCW_HCURSOR       =  (-12)
GCW_HICON         =  (-14)
GCW_HMODULE       =  (-16)
GCW_CBWNDEXTRA    =  (-18)
GCW_CBCLSEXTRA    =  (-20)
GCL_WNDPROC       =  (-24)
GCW_STYLE         =  (-26)

; WinWhere() Area Codes
HTERROR           =  (-2)
HTTRANSPARENT     =  (-1)
HTNOWHERE         =  0
HTCLIENT          =  1
HTCAPTION         =  2
HTSYSMENU         =  3
HTGROWBOX         =  4
HTSIZE            =  HTGROWBOX
HTMENU            =  5
HTHSCROLL         =  6
HTVSCROLL         =  7
HTREDUCE          =  8
HTZOOM            =  9
HTLEFT            =  10
HTRIGHT           =  11
HTTOP             =  12
HTTOPLEFT         =  13
HTTOPRIGHT        =  14
HTBOTTOM          =  15
HTBOTTOMLEFT      =  16
HTBOTTOMRIGHT     =  17
HTSIZEFIRST       =  HTLEFT
HTSIZELAST        =  HTBOTTOMRIGHT



;*************************************************************************
;
;       Misc structures & constants
;
;*************************************************************************

IFNDEF  NOMST
POINT   struc
        ptX             dw      ?
        ptY             dw      ?
POINT   ends

LOGPEN struc
    lopnStyle       dw ?
    lopnWidth       db (SIZE POINT) DUP(?)
    lopnColor       dd ?
LOGPEN ends


BITMAP STRUC
        bmType         DW ?
        bmWidth        DW ?
        bmHeight       DW ?
        bmWidthBytes   DW ?
        bmPlanes       DB ?
        bmBitsPixel    DB ?
        bmBits         DD ?
BITMAP ENDS

RGBTRIPLE       struc
        rgbBlue         db ?
        rgbGreen        db ?
        rgbRed          db ?
RGBTRIPLE       ends

RGBQUAD         struc
        rgbqBlue        db ?
        rgbqGreen       db ?
        rgbqRed         db ?
        rgbqReserved    db ?
RGBQUAD         ends

; structures for defining DIBs
BITMAPCOREHEADER struc
        bcSize      dd ?
        bcWidth     dw ?
        bcHeight    dw ?
        bcPlanes    dw ?
        bcBitCount  dw ?
BITMAPCOREHEADER ends

BITMAPINFOHEADER struc
        biSize           dd ?
        biWidth          dd ?
        biHeight         dd ?
        biPlanes         dw ?
        biBitCount       dw ?

        biCompression    dd ?
        biSizeImage      dd ?
        biXPelsPerMeter  dd ?
        biYPelsPerMeter  dd ?
        biClrUsed        dd ?
        biClrImportant   dd ?
BITMAPINFOHEADER ends

BITMAPINFO  struc
    bmiHeader   db (SIZE BITMAPINFOHEADER) DUP (?)
    bmiColors   db ?            ; array of RGBQUADs
BITMAPINFO  ends

BITMAPCOREINFO  struc
    bmciHeader  db (SIZE BITMAPCOREHEADER) DUP (?)
    bmciColors  db ?            ; array of RGBTRIPLEs
BITMAPCOREINFO  ends

BITMAPFILEHEADER struc
    bfType          dw ?
    bfSize          dd ?
    bfReserved1     dw ?
    bfReserved2     dw ?
    bfOffBits       dd ?
BITMAPFILEHEADER ends


WNDSTRUC struc
        WSwndStyle        dd      ?
        WSwndID           dw      ?
        WSwndText         dw      ?
        WSwndParent       dw      ?
        WSwndInstance     dw      ?
        WSwndClassProc    dd      ?
WNDSTRUC ends
;
;  Message structure
;
MSGSTRUCT       struc
msHWND          dw      ?
msMESSAGE       dw      ?
msWPARAM        dw      ?
msLPARAM        dd      ?
msTIME          dd      ?
msPT            dd      ?
MSGSTRUCT       ends

NEWPARMS struc
        nprmHwnd        dw      ?
        nprmCmd         db      ?
NEWPARMS ends
ENDIF

PAINTSTRUCT STRUC
    PShdc         DW ?
    PSfErase      DW ?
    PSrcPaint     DB size RECT dup(?)
    PSfRestore    DW ?
    PSfIncUpdate  DW ?
    PSrgbReserved DB 16 dup(?)
PAINTSTRUCT ENDS


CREATESTRUCT struc
    cs_lpCreateParams  dd ?
    cs_hInstance       dw ?
    cs_hMenu           dw ?
    cs_hwndParent      dw ?
    cs_cy              dw ?
    cs_cx              dw ?
    cs_y               dw ?
    cs_x               dw ?
    cs_style           dd ?
    cs_lpszName        dd ?
    cs_lpszClass       dd ?
    cs_dwExStyle       dd ?
CREATESTRUCT  ends
;
;       PostError constants
;
WARNING     = 0           ; command codes
MINOR_ERROR = 1
FATAL_ERROR = 2

IGNORE      = 0           ; response codes
RETRY       = 1
ABORT       = 2
;
; GDI-related constants & commands
;
ERRORREGION     = 0
NULLREGION      = 1
SIMPLEREGION    = 2
COMPLEXREGION   = 3

IFNDEF NORASTOPS
;
; Binary raster ops
;
R2_BLACK        =  1
R2_NOTMERGEPEN  =  2
R2_MASKNOTPEN   =  3
R2_NOTCOPYPEN   =  4
R2_MASKPENNOT   =  5
R2_NOT          =  6
R2_XORPEN       =  7
R2_NOTMASKPEN   =  8
R2_MASKPEN      =  9
R2_NOTXORPEN    = 10
R2_NOP          = 11
R2_MERGENOTPEN  = 12
R2_COPYPEN      = 13
R2_MERGEPENNOT  = 14
R2_MERGEPEN     = 15
R2_WHITE        = 16
;
; Ternary raster ops
;
SRCCOPY_L     = 0020h   ;dest=source
SRCCOPY_H     = 00CCh
SRCPAINT_L    = 0086h   ;dest=source OR dest
SRCPAINT_H    = 00EEh
SRCAND_L      = 00C6h   ;dest=source AND   dest
SRCAND_H      = 0088h
SRCINVERT_L   = 0046h   ;dest= source XOR      dest
SRCINVERT_H   = 0066h
SRCERASE_L    = 0328h   ;dest= source AND (not dest )
SRCERASE_H    = 0044h
NOTSRCCOPY_L  = 0008h   ;dest= (not source)
NOTSRCCOPY_H  = 0033h
NOTSRCERASE_L = 00A6h   ;dest= (not source) AND (not dest)
NOTSRCERASE_H = 0011h
MERGECOPY_L   = 00CAh   ;dest= (source AND pattern)
MERGECOPY_H   = 00C0h
MERGEPAINT_L  = 0226h   ;dest= (source AND pattern) OR dest
MERGEPAINT_H  = 00BBh
PATCOPY_L     = 0021h   ;dest= pattern
PATCOPY_H     = 00F0h
PATPAINT_L    = 0A09h   ;DPSnoo
PATPAINT_H    = 00FBh
PATINVERT_L   = 0049h   ;dest= pattern XOR     dest
PATINVERT_H   = 005Ah
DSTINVERT_L   = 0009h   ;dest= (not dest)
DSTINVERT_H   = 0055h
BLACKNESS_L   = 0042h   ;dest= BLACK
BLACKNESS_H   = 0000h
WHITENESS_L   = 0062h   ;dest= WHITE
WHITENESS_H   = 00FFh
;
; StretchBlt modes
;
BLACKONWHITE    = 1
WHITEONBLACK    = 2
COLORONCOLOR    = 3
;
; New StretchBlt modes
;
STRETCH_ANDSCANS    = 1
STRETCH_ORSCANS     = 2
STRETCH_DELETESCANS = 3
;
; PolyFill modes
;
ALTERNATE       = 1
WINDING         = 2
ENDIF
;
; Text Alignment Options
;
TA_NOUPDATECP   =  0
TA_UPDATECP     =  1

TA_LEFT         =  0
TA_RIGHT        =  2
TA_CENTER       =  6

TA_TOP          =  0
TA_BOTTOM       =  8
TA_BASELINE     =  24

ETO_GRAYED      =  1
ETO_OPAQUE      =  2
ETO_CLIPPED     =  4

ASPECT_FILTERING = 1

ifndef NOMETAFILE

; Metafile Functions */
META_SETBKCOLOR            =  0201h
META_SETBKMODE             =  0102h
META_SETMAPMODE            =  0103h
META_SETROP2               =  0104h
META_SETRELABS             =  0105h
META_SETPOLYFILLMODE       =  0106h
META_SETSTRETCHBLTMODE     =  0107h
META_SETTEXTCHAREXTRA      =  0108h
META_SETTEXTCOLOR          =  0209h
META_SETTEXTJUSTIFICATION  =  020Ah
META_SETWINDOWORG          =  020Bh
META_SETWINDOWEXT          =  020Ch
META_SETVIEWPORTORG        =  020Dh
META_SETVIEWPORTEXT        =  020Eh
META_OFFSETWINDOWORG       =  020Fh
META_SCALEWINDOWEXT        =  0400h
META_OFFSETVIEWPORTORG     =  0211h
META_SCALEVIEWPORTEXT      =  0412h
META_LINETO                =  0213h
META_MOVETO                =  0214h
META_EXCLUDECLIPRECT       =  0415h
META_INTERSECTCLIPRECT     =  0416h
META_ARC                   =  0817h
META_ELLIPSE               =  0418h
META_FLOODFILL             =  0419h
META_PIE                   =  081Ah
META_RECTANGLE             =  041Bh
META_ROUNDRECT             =  061Ch
META_PATBLT                =  061Dh
META_SAVEDC                =  001Eh
META_SETPIXEL              =  041Fh
META_OFFSETCLIPRGN         =  0220h
META_TEXTOUT               =  0521h
META_BITBLT                =  0922h
META_STRETCHBLT            =  0B23h
META_POLYGON               =  0324h
META_POLYLINE              =  0325h
META_ESCAPE                =  0626h
META_RESTOREDC             =  0127h
META_FILLREGION            =  0228h
META_FRAMEREGION           =  0429h
META_INVERTREGION          =  012Ah
META_PAINTREGION           =  012Bh
META_SELECTCLIPREGION      =  012Ch
META_SELECTOBJECT          =  012Dh
META_SETTEXTALIGN          =  012Eh
META_DRAWTEXT              =  062Fh

META_CHORD                 =  0830h
META_SETMAPPERFLAGS        =  0231h
META_EXTTEXTOUT            =  0a32h
META_SETDIBTODEV           =  0d33h
META_SELECTPALETTE         =  0234h
META_REALIZEPALETTE        =  0035h
META_ANIMATEPALETTE        =  0436h
META_SETPALENTRIES         =  0037h
META_POLYPOLYGON           =  0538h
META_RESIZEPALETTE         =  0139h

META_DIBBITBLT             =  0940h
META_DIBSTRETCHBLT         =  0b41h
META_DIBCREATEPATTERNBRUSH =  0142h
META_STRETCHDIB            =  0f43h

META_DELETEOBJECT          =  01f0h

META_CREATEPALETTE         =  00f7h
META_CREATEBRUSH           =  00F8h
META_CREATEPATTERNBRUSH    =  01F9h
META_CREATEPENINDIRECT     =  02FAh
META_CREATEFONTINDIRECT    =  02FBh
META_CREATEBRUSHINDIRECT   =  02FCh
META_CREATEBITMAPINDIRECT  =  02FDh
META_CREATEBITMAP          =  06FEh
META_CREATEREGION          =  06FFh

; /* Clipboard Metafile Picture Structure */
HANDLETABLE struc
    ht_objectHandle  dw      ?
HANDLETABLE ends

METARECORD struc
    mr_rdSize        dd      ?
    mr_rdFunction    dw      ?
    mr_rdParm        dw      ?
METARECORD ends

METAFILEPICT struc
    mfp_mm      dw      ?
    mfp_xExt    dw      ?
    mfp_yExt    dw      ?
    mfp_hMF     dw      ?
METAFILEPICT ends

METAHEADER struc
  mtType        dw      ?
  mtHeaderSize  dw      ?
  mtVersion     dw      ?
  mtSize        dd      ?
  mtNoObjects   dw      ?
  mtMaxRecord   dd      ?
  mtNoParameters dw     ?
METAHEADER ends

endif ; NOMETAFILE

; GDI Escapes
NEWFRAME                  =   1
ABORTDOC                  =   2
NEXTBAND                  =   3
SETCOLORTABLE             =   4
GETCOLORTABLE             =   5
FLUSHOUTPUT               =   6
DRAFTMODE                 =   7
QUERYESCSUPPORT           =   8
SETABORTPROC              =   9
STARTDOC                  =   10
;; This value conflicts with a std WIN386 MACRO definition
;;ENDDOC                    =   11
GETPHYSPAGESIZE           =   12
GETPRINTINGOFFSET         =   13
GETSCALINGFACTOR          =   14
MFCOMMENT                 =   15
GETPENWIDTH               =   16
SETCOPYCOUNT              =   17
SELECTPAPERSOURCE         =   18
DEVICEDATA                =   19
PASSTHROUGH               =   19
GETTECHNOLGY              =   20
GETTECHNOLOGY             =   20
SETENDCAP                 =   21
SETLINEJOIN               =   22
SETMITERLIMIT             =   23
BANDINFO                  =   24
DRAWPATTERNRECT           =   25
GETVECTORPENSIZE          =   26
GETVECTORBRUSHSIZE        =   27
ENABLEDUPLEX              =   28
ENABLEMANUALFEED          =   29
GETSETPAPERBINS           =   29
GETSETPRINTORIENT         =   30
ENUMPAPERBINS             =   31

GETEXTENDEDTEXTMETRICS    =   256
GETEXTENTTABLE            =   257
GETPAIRKERNTABLE          =   258
GETTRACKKERNTABLE         =   259

EXTTEXTOUT                =   512

ENABLERELATIVEWIDTHS      =   768
ENABLEPAIRKERNING         =   769
SETKERNTRACK              =   770
SETALLJUSTVALUES          =   771
SETCHARSET                =   772

GETSETSCREENPARAMS        =   3072

STRETCHBLT                =   2048


; Spooler Error Codes
SP_NOTREPORTED            =   4000h
SP_ERROR                  =   (-1)
SP_APPABORT               =   (-2)
SP_USERABORT              =   (-3)
SP_OUTOFDISK              =   (-4)
SP_OUTOFMEMORY            =   (-5)

PR_JOBSTATUS              =   0000

; Object Definitions for EnumObjects()
OBJ_PEN                   =   1
OBJ_BRUSH                 =   2

;
; Menu flags for Change/Check/Enable MenuItem
;
MF_INSERT       =   0000h
MF_CHANGE       =   0080h
MF_APPEND       =   0100h
MF_DELETE       =   0200h
MF_REMOVE       =   1000h

MF_BYCOMMAND    =   0000h
MF_BYPOSITION   =   0400h

MF_SEPARATOR    =   0800h

MF_ENABLED      =   0000h
MF_GRAYED       =   0001h
MF_DISABLED     =   0002h

MF_UNCHECKED    =   0000h
MF_CHECKED      =   0008h
MF_USECHECKBITMAPS= 0200h

MF_STRING       =   0000h
MF_BITMAP       =   0004h
MF_OWNERDRAW    =   0100h

MF_POPUP        =   0010h
MF_MENUBARBREAK =   0020h
MF_MENUBREAK    =   0040h

MF_UNHILITE     =   0000h
MF_HILITE       =   0080h

MF_SYSMENU      =   2000h
MF_HELP         =   4000h
MF_MOUSESELECT  =   8000h


;
;  System Menu Command Values
;
SC_SIZE        = 0F000h
SC_MOVE        = 0F010h
SC_MINIMIZE    = 0F020h
SC_MAXIMIZE    = 0F030h
SC_NEXTWINDOW  = 0F040h
SC_PREVWINDOW  = 0F050h
SC_CLOSE       = 0F060h
SC_VSCROLL     = 0F070h
SC_HSCROLL     = 0F080h
SC_MOUSEMENU   = 0F090h
SC_KEYMENU     = 0F100h
SC_ARRANGE     = 0F110h
SC_RESTORE     = 0F120h
SC_TASKLIST    = 0F130h
SC_SCREENSAVE  = 0F140h
SC_HOTKEY      = 0F150h

SC_ICON        = SC_MINIMIZE
SC_ZOOM        = SC_MAXIMIZE

;
;  Window State Messages
;
IFNDEF  NOWM
WM_STATE            = 0000H

WM_NULL             = 0000h
WM_CREATE           = 0001h
WM_DESTROY          = 0002h
WM_MOVE             = 0003h
WM_SIZE             = 0005h
WM_ACTIVATE         = 0006h
WM_SETFOCUS         = 0007h
WM_KILLFOCUS        = 0008h
WM_ENABLE           = 000Ah
WM_SETREDRAW        = 000Bh
WM_SETTEXT          = 000Ch
WM_GETTEXT          = 000Dh
WM_GETTEXTLENGTH    = 000Eh
WM_PAINT            = 000Fh
WM_CLOSE            = 0010h
WM_QUERYENDSESSION  = 0011h
WM_QUIT             = 0012h
WM_QUERYOPEN        = 0013h
WM_ERASEBKGND       = 0014h
WM_SYSCOLORCHANGE   = 0015h
WM_ENDSESSION       = 0016h
WM_SYSTEMERROR      = 0017h
WM_SHOWWINDOW       = 0018h
WM_CTLCOLOR         = 0019h
WM_WININICHANGE     = 001Ah
WM_DEVMODECHANGE    = 001Bh
WM_ACTIVATEAPP      = 001Ch
WM_FONTCHANGE       = 001Dh
WM_TIMECHANGE       = 001Eh
WM_CANCELMODE       = 001Fh
WM_SETCURSOR        = 0020h
WM_MOUSEACTIVATE    = 0021h
WM_CHILDACTIVATE    = 0022h
WM_QUEUESYNC        = 0023h
WM_GETMINMAXINFO    = 0024h
WM_PAINTICON        = 0026h
WM_ICONERASEBKGND   = 0027h
WM_NEXTDLGCTL       = 0028h
WM_SPOOLERSTATUS    = 002Ah
WM_DRAWITEM         = 002Bh
WM_MEASUREITEM      = 002Ch
WM_DELETEITEM       = 002Dh
WM_VKEYTOITEM       = 002Eh
WM_CHARTOITEM       = 002Fh
WM_SETFONT          = 0030h
WM_GETFONT          = 0031h
WM_QUERYDRAGICON    = 0037h
WM_COMPAREITEM      = 0039h
WM_COMPACTING       = 0041h
IFNDEF NOWIN31
WM_COMMNOTIFY       = 0044h
WM_WINDOWPOSCHANGING= 0046h
WM_WINDOWPOSCHANGED = 0047h
WM_POWER            = 0048h
ENDIF


WM_NCCREATE         = 0081h
WM_NCDESTROY        = 0082h
WM_NCCALCSIZE       = 0083h
WM_NCHITTEST        = 0084h
WM_NCPAINT          = 0085h
WM_NCACTIVATE       = 0086h
WM_GETDLGCODE       = 0087h
WM_NCMOUSEMOVE      = 00A0h
WM_NCLBUTTONDOWN    = 00A1h
WM_NCLBUTTONUP      = 00A2h
WM_NCLBUTTONDBLCLK  = 00A3h
WM_NCRBUTTONDOWN    = 00A4h
WM_NCRBUTTONUP      = 00A5h
WM_NCRBUTTONDBLCLK  = 00A6h
WM_NCMBUTTONDOWN    = 00A7h
WM_NCMBUTTONUP      = 00A8h
WM_NCMBUTTONDBLCLK  = 00A9h

WM_KEYFIRST         = 0100h
WM_KEYDOWN          = 0100h
WM_KEYUP            = 0101h
WM_CHAR             = 0102h
WM_DEADCHAR         = 0103h
WM_SYSKEYDOWN       = 0104h
WM_SYSKEYUP         = 0105h
WM_SYSCHAR          = 0106h
WM_SYSDEADCHAR      = 0107h
WM_KEYLAST          = 0108h

WM_INITDIALOG       = 0110h
WM_COMMAND          = 0111h
WM_SYSCOMMAND       = 0112h
WM_TIMER            = 0113h
WM_HSCROLL          = 0114h
WM_VSCROLL          = 0115h
WM_INITMENU         = 0116h
WM_INITMENUPOPUP    = 0117h
WM_MENUSELECT       = 011Fh
WM_MENUCHAR         = 0120h
WM_ENTERIDLE        = 0121h


WM_MOUSEFIRST       = 0200h
WM_MOUSEMOVE        = 0200h
WM_LBUTTONDOWN      = 0201h
WM_LBUTTONUP        = 0202h
WM_LBUTTONDBLCLK    = 0203h
WM_RBUTTONDOWN      = 0204h
WM_RBUTTONUP        = 0205h
WM_RBUTTONDBLCLK    = 0206h
WM_MBUTTONDOWN      = 0207h
WM_MBUTTONUP        = 0208h
WM_MBUTTONDBLCLK    = 0209h
WM_MOUSELAST        = 0209h

WM_PARENTNOTIFY     = 0210h
WM_MDICREATE        = 0220h
WM_MDIDESTROY       = 0221h
WM_MDIACTIVATE      = 0222h
WM_MDIRESTORE       = 0223h
WM_MDINEXT          = 0224h
WM_MDIMAXIMIZE      = 0225h
WM_MDITILE          = 0226h
WM_MDICASCADE       = 0227h
WM_MDIICONARRANGE   = 0228h
WM_MDIGETACTIVE     = 0229h
WM_MDISETMENU       = 0230h
WM_DROPFILES        = 0233h


WM_CUT              = 0300h
WM_COPY             = 0301h
WM_PASTE            = 0302h
WM_CLEAR            = 0303h
WM_UNDO             = 0304h
WM_RENDERFORMAT     = 0305h
WM_RENDERALLFORMATS = 0306h
WM_DESTROYCLIPBOARD = 0307h
WM_DRAWCLIPBOARD    = 0308h
WM_PAINTCLIPBOARD   = 0309h
WM_VSCROLLCLIPBOARD = 030Ah
WM_SIZECLIPBOARD    = 030Bh
WM_ASKCBFORMATNAME  = 030Ch
WM_CHANGECBCHAIN    = 030Dh
WM_HSCROLLCLIPBOARD = 030Eh
WM_QUERYNEWPALETTE  = 030Fh
WM_PALETTEISCHANGING = 0310h
WM_PALETTECHANGED   = 0311h

IFNDEF NOWIN31
WM_PENWINFIRST      equ 0380h
WM_PENWINLAST       equ 038Fh


WM_COALESCE_FIRST  equ 0390h
WM_COALESCE_LAST   equ 039Fh




ENDIF



;  private window messages start here
WM_USER             = 0400H
ENDIF           ; NOWM

; WM_MOUSEACTIVATE Return Codes
MA_ACTIVATE       =  1
MA_ACTIVATEANDEAT =  2
MA_NOACTIVATE     =  3

; Size message commands
SIZENORMAL       = 0
SIZEICONIC       = 1
SIZEFULLSCREEN   = 2
SIZEZOOMSHOW     = 3
SIZEZOOMHIDE     = 4

; ShowWindow() Commands
SW_HIDE            = 0
SW_SHOWNORMAL      = 1
SW_NORMAL          = 1
SW_SHOWMINIMIZED   = 2
SW_SHOWMAXIMIZED   = 3
SW_MAXIMIZE        = 3
SW_SHOWNOACTIVATE  = 4
SW_SHOW            = 5
SW_MINIMIZE        = 6
SW_SHOWMINNOACTIVE = 7
SW_SHOWNA          = 8
SW_RESTORE         = 9

; Old ShowWindow() Commands
HIDE_WINDOW        = 0
SHOW_OPENWINDOW    = 1
SHOW_ICONWINDOW    = 2
SHOW_FULLSCREEN    = 3
SHOW_OPENNOACTIVATE= 4

;  identifiers for the WM_SHOWWINDOW message
SW_PARENTCLOSING =  1
SW_OTHERZOOM     =  2
SW_PARENTOPENING =  3
SW_OTHERUNZOOM   =  4
;
; Key state masks for mouse messages
;
MK_LBUTTON       = 0001h
MK_RBUTTON       = 0002h
MK_SHIFT         = 0004h
MK_CONTROL       = 0008h
MK_MBUTTON       = 0010h
;
; Class styles
;
CS_VREDRAW         = 0001h
CS_HREDRAW         = 0002h
CS_KEYCVTWINDOW    = 0004H
CS_DBLCLKS         = 0008h
;                    0010h reserved
CS_OWNDC           = 0020h
CS_CLASSDC         = 0040h
CS_PARENTDC        = 0080h
CS_NOKEYCVT        = 0100h
CS_SAVEBITS        = 0800h
CS_NOCLOSE         = 0200h
CS_BYTEALIGNCLIENT = 1000h
CS_BYTEALIGNWINDOW = 2000h
CS_GLOBALCLASS     = 4000h    ; Global window class

;
; Special CreateWindow position value
;
CW_USEDEFAULT   EQU    8000h

;
; Windows styles (the high words)
;
WS_OVERLAPPED   = 00000h
WS_ICONICPOPUP  = 0C000h
WS_POPUP        = 08000h
WS_CHILD        = 04000h
WS_MINIMIZE     = 02000h
WS_VISIBLE      = 01000h
WS_DISABLED     = 00800h
WS_CLIPSIBLINGS = 00400h
WS_CLIPCHILDREN = 00200h
WS_MAXIMIZE     = 00100h
WS_CAPTION      = 000C0h     ; WS_BORDER | WS_DLGFRAME
WS_BORDER       = 00080h
WS_DLGFRAME     = 00040h
WS_VSCROLL      = 00020h
WS_HSCROLL      = 00010h
WS_SYSMENU      = 00008h
WS_THICKFRAME   = 00004h
WS_HREDRAW      = 00002h
WS_VREDRAW      = 00001h
WS_GROUP        = 00002h
WS_TABSTOP      = 00001h
WS_MINIMIZEBOX  = 00002h
WS_MAXIMIZEBOX  = 00001h

; Common Window Styles

WS_OVERLAPPEDWINDOW = WS_OVERLAPPED + WS_CAPTION + WS_SYSMENU + WS_THICKFRAME + WS_MINIMIZEBOX + WS_MAXIMIZEBOX
WS_POPUPWINDOW  = WS_POPUP + WS_BORDER + WS_SYSMENU
WS_CHILDWINDOW  = WS_CHILD
WS_TILEDWINDOW  = WS_OVERLAPPEDWINDOW

WS_TILED        = WS_OVERLAPPED
WS_ICONIC       = WS_MINIMIZE
WS_SIZEBOX      = WS_THICKFRAME

; Extended Window Styles (low words)
WS_EX_DLGMODALFRAME  = 0001
WS_EX_DRAGOBJECT     = 0002
WS_EX_NOPARENTNOTIFY = 0004
WS_EX_TOPMOST        = 0008

;
; predefined clipboard formats
;
CF_TEXT         =  1
CF_BITMAP       =  2
CF_METAFILEPICT =  3
CF_SYLK         =  4
CF_DIF          =  5
CF_TIFF         =  6
CF_OEMTEXT      =  7
CF_DIB          =  8
CF_PALETTE      =  9
CF_PENDATA      = 10
CF_RIFF         = 11
CF_WAVE         = 12

CF_OWNERDISPLAY = 80h       ; owner display
CF_DSPTEXT      = 81h       ; display text
CF_DSPBITMAP    = 82h       ; display bitmap
CF_DSPMETAFILEPICT  = 83h   ; display metafile
;
; Private clipboard format range
;
CF_PRIVATEFIRST       = 200h       ; Anything in this range doesn't
CF_PRIVATELAST        = 2ffh       ; get GlobalFree'd
CF_GDIOBJFIRST        = 300h       ; Anything in this range gets
CF_GDIOBJLAST         = 3ffh       ; DeleteObject'ed


MAKEINTRESOURCE MACRO a
        mov     ax,a
        xor     dx,dx
        ENDM
;
;  Predefined resource types
;
RT_CURSOR       = 1              ; must be passed through MAKEINTRESOURCE
RT_BITMAP       = 2
RT_ICON         = 3
RT_MENU         = 4
RT_DIALOG       = 5
RT_STRING       = 6
RT_FONTDIR      = 7
RT_FONT         = 8
RT_ACCELERATOR  = 9
RT_RCDATA       = 10

;** NOTE: if any new resource types are introduced above this point, then the
;** value of DIFFERENCE must be changed.
;** (RT_GROUP_CURSOR - RT_CURSOR) must always be equal to DIFFERENCE
;** (RT_GROUP_ICON - RT_ICON) must always be equal to DIFFERENCE

DIFFERENCE       =   11

RT_GROUP_CURSOR  =   RT_CURSOR + DIFFERENCE
RT_GROUP_ICON    =   RT_ICON + DIFFERENCE



IFNDEF NOMDI
MDICREATESTRUCT     struc
    szClass         dd ?
    szTitle         dd ?
    hOwner          dw ?
    x               dw ?
    y               dw ?
    cxc             dw ?
    cyc             dw ?
    style           dd ?
MDICREATESTRUCT ends

CLIENTCREATESTRUCT  struc
    hWindowMenu     dw ?
    idFirstChild    dw ?
CLIENTCREATESTRUCT ends
ENDIF

; NOMDI


PALETTEENTRY        struc
    peRed           db ?
    peGreen         db ?
    peBlue          db ?
    peFlags         db ?
PALETTEENTRY        ends

; Logical Palette
LOGPALETTE          struc
    palVersion      dw ?
    palNumEntries   dw ?
    palPalEntry     db ?  ; array of PALETTEENTRY
LOGPALETTE          ends

; DRAWITEMSTRUCT for ownerdraw
DRAWITEMSTRUCT      struc
    drCtlType         dw ?
    drCtlID           dw ?
    dritemID          dw ?
    dritemAction      dw ?
    dritemState       dw ?
    drhwndItem        dw ?
    drhDC             dw ?
    drrcItem          DB size RECT dup(?)
    dritemData        dd ?
DRAWITEMSTRUCT ends

; DELETEITEMSTRUCT for ownerdraw
DELETEITEMSTRUCT    struc
    deCtlType         dw ?
    deCtlID           dw ?
    deitemID          dw ?
    dehwndItem        dw ?
    deitemData        dd ?
DELETEITEMSTRUCT ends

; MEASUREITEMSTRUCT for ownerdraw
MEASUREITEMSTRUCT   struc
    meCtlType         dw ?
    meCtlID           dw ?
    meitemID          dw ?
    meitemWidth       dw ?
    meitemHeight      dw ?
    meitemData        dd ?
MEASUREITEMSTRUCT ends

; COMPAREITEMSTUCT for ownerdraw sorting
COMPAREITEMSTRUCT   struc
    coCtlType   dw ?
    coCtlID     dw ?
    cohwndItem  dw ?
    coitemID1   dw ?
    coitemData1 dd ?
    coitemID2   dw ?
    coitemData2 dd ?
COMPAREITEMSTRUCT   ends

; Owner draw control types
ODT_MENU      =  1
ODT_LISTBOX   =  2
ODT_COMBOBOX  =  3
ODT_BUTTON    =  4

; Owner draw actions
ODA_DRAWENTIRE = 1
ODA_SELECT     = 2
ODA_FOCUS      = 4

; Owner draw state
ODS_SELECTED   = 0001h
ODS_GRAYED     = 0002h
ODS_DISABLED   = 0004h
ODS_CHECKED    = 0008h
ODS_FOCUS      = 0010h

; PeekMessage() Options
PM_NOREMOVE    = 0000h
PM_REMOVE      = 0001h
PM_NOYIELD     = 0002h

; SetWindowPos Flags
SWP_NOSIZE       =  0001h
SWP_NOMOVE       =  0002h
SWP_NOZORDER     =  0004h
SWP_NOREDRAW     =  0008h
SWP_NOACTIVATE   =  0010h
SWP_DRAWFRAME    =  0020h
SWP_SHOWWINDOW   =  0040h
SWP_HIDEWINDOW   =  0080h
SWP_NOCOPYBITS   =  0100h
SWP_NOREPOSITION =  0200h


IFNDEF NOWINMESSAGES

; Listbox messages
LB_ADDSTRING           = (WM_USER+1)
LB_INSERTSTRING        = (WM_USER+2)
LB_DELETESTRING        = (WM_USER+3)
LB_RESETCONTENT        = (WM_USER+5)
LB_SETSEL              = (WM_USER+6)
LB_SETCURSEL           = (WM_USER+7)
LB_GETSEL              = (WM_USER+8)
LB_GETCURSEL           = (WM_USER+9)
LB_GETTEXT             = (WM_USER+10)
LB_GETTEXTLEN          = (WM_USER+11)
LB_GETCOUNT            = (WM_USER+12)
LB_SELECTSTRING        = (WM_USER+13)
LB_DIR                 = (WM_USER+14)
LB_GETTOPINDEX         = (WM_USER+15)
LB_FINDSTRING          = (WM_USER+16)
LB_GETSELCOUNT         = (WM_USER+17)
LB_GETSELITEMS         = (WM_USER+18)
LB_SETTABSTOPS         = (WM_USER+19)
LB_GETHORIZONTALEXTENT = (WM_USER+20)
LB_SETHORIZONTALEXTENT = (WM_USER+21)
LB_SETTOPINDEX         = (WM_USER+24)
LB_GETITEMRECT         = (WM_USER+25)
LB_GETITEMDATA         = (WM_USER+26)
LB_SETITEMDATA         = (WM_USER+27)
LB_SELITEMRANGE        = (WM_USER+28)
LB_SETCARETINDEX       = (WM_USER+31)
LB_GETCARETINDEX       = (WM_USER+32)
IFNDEF NOWIN31
LB_SETITEMHEIGHT       = (WM_USER+33)
LB_GETITEMHEIGHT       = (WM_USER+34)
LB_FINDSTRINGEXACT     = (WM_USER+35)
ENDIF

ENDIF
; NOWINMESSAGES

; Listbox Styles
LBS_NOTIFY            = 0001h
LBS_SORT              = 0002h
LBS_NOREDRAW          = 0004h
LBS_MULTIPLESEL       = 0008h
LBS_OWNERDRAWFIXED    = 0010h
LBS_OWNERDRAWVARIABLE = 0020h
LBS_HASSTRINGS        = 0040h
LBS_USETABSTOPS       = 0080h
LBS_NOINTEGRALHEIGHT  = 0100h
LBS_MULTICOLUMN       = 0200h
LBS_WANTKEYBOARDINPUT = 0400h
LBS_EXTENDEDSEL       = 0800h
LBS_STANDARD          = LBS_NOTIFY + LBS_SORT + WS_VSCROLL + WS_BORDER
LBS_DISABLENOSCROLL   = 1000h

; Listbox Notification Codes
LBN_ERRSPACE      =  (-2)
LBN_SELCHANGE     =  1
LBN_DBLCLK        =  2
LBN_SELCANCEL     =  3
LBN_SETFOCUS      =  4
LBN_KILLFOCUS     =  5

IFNDEF NOWINMESSAGES

; Edit Control Messages
EM_GETSEL              = (WM_USER+0)
EM_SETSEL              = (WM_USER+1)
EM_GETRECT             = (WM_USER+2)
EM_SETRECT             = (WM_USER+3)
EM_SETRECTNP           = (WM_USER+4)
EM_SCROLL              = (WM_USER+5)
EM_LINESCROLL          = (WM_USER+6)
EM_GETMODIFY           = (WM_USER+8)
EM_SETMODIFY           = (WM_USER+9)
EM_GETLINECOUNT        = (WM_USER+10)
EM_LINEINDEX           = (WM_USER+11)
EM_SETHANDLE           = (WM_USER+12)
EM_GETHANDLE           = (WM_USER+13)
EM_LINELENGTH          = (WM_USER+17)
EM_REPLACESEL          = (WM_USER+18)
EM_SETFONT             = (WM_USER+19)
EM_GETLINE             = (WM_USER+20)
EM_LIMITTEXT           = (WM_USER+21)
EM_CANUNDO             = (WM_USER+22)
EM_UNDO                = (WM_USER+23)
EM_FMTLINES            = (WM_USER+24)
EM_LINEFROMCHAR        = (WM_USER+25)
EM_SETWORDBREAK        = (WM_USER+26)
EM_SETTABSTOPS         = (WM_USER+27)
EM_SETPASSWORDCHAR     = (WM_USER+28)
EM_EMPTYUNDOBUFFER     = (WM_USER+29)
IFNDEF NOWIN31
EM_GETFIRSTVISIBLELINE = (WM_USER+30)
EM_SETREADONLY         = (WM_USER+31)
EM_SETWORDBREAKPROC    = (WM_USER+32)
EM_GETWORDBREAKPROC    = (WM_USER+33)
EM_GETPASSWORDCHAR     = (WM_USER+34)
ENDIF

ENDIF
; NOWINMESSAGES


; Edit Control Styles (low word)
ES_LEFT            = 0000h
ES_CENTER          = 0001h
ES_RIGHT           = 0002h
ES_MULTILINE       = 0004h
ES_UPPERCASE       = 0008h
ES_LOWERCASE       = 0010h
ES_PASSWORD        = 0020h
ES_AUTOVSCROLL     = 0040h
ES_AUTOHSCROLL     = 0080h
ES_NOHIDESEL       = 0100h
ES_OEMCONVERT      = 0400h
IFNDEF NOWIN31
ES_READONLY        = 0800h
ES_WANTRETURN      = 1000h
ENDIF


; Edit Control Notification Codes
EN_SETFOCUS        = 0100h
EN_KILLFOCUS       = 0200h
EN_CHANGE          = 0300h
EN_UPDATE          = 0400h
EN_ERRSPACE        = 0500h
EN_MAXTEXT         = 0501h
EN_HSCROLL         = 0601h
EN_VSCROLL         = 0602h

IFNDEF NOWINMESSAGES

; Button Control Messages
BM_GETCHECK        = (WM_USER+0)
BM_SETCHECK        = (WM_USER+1)
BM_GETSTATE        = (WM_USER+2)
BM_SETSTATE        = (WM_USER+3)
BM_SETSTYLE        = (WM_USER+4)

ENDIF
; NOWINMESSAGES

; Button Control Styles (low word)
BS_PUSHBUTTON      = 00h
BS_DEFPUSHBUTTON   = 01h
BS_CHECKBOX        = 02h
BS_AUTOCHECKBOX    = 03h
BS_RADIOBUTTON     = 04h
BS_3STATE          = 05h
BS_AUTO3STATE      = 06h
BS_GROUPBOX        = 07h
BS_USERBUTTON      = 08h
BS_AUTORADIOBUTTON = 09h
BS_OWNERDRAW       = 0Bh
BS_LEFTTEXT        = 20h

; User Button Notification Codes
BN_CLICKED         = 0
BN_PAINT           = 1
BN_HILITE          = 2
BN_UNHILITE        = 3
BN_DISABLE         = 4
BN_DOUBLECLICKED   = 5

; Dialog Styles (low words)
DS_ABSALIGN        = 01h
DS_SYSMODAL        = 02h
DS_LOCALEDIT       = 20h  ;/* Edit items get Local storage. */
DS_SETFONT         = 40h  ;/* User specified font for Dlg controls */
DS_MODALFRAME      = 80h  ;/* Can be combined with WS_CAPTION  */
DS_NOIDLEMSG       = 100h ;/* WM_ENTERIDLE message will not be sent */

IFNDEF NOWINMESSAGES

; Dialog box messages
DM_GETDEFID        = (WM_USER+0)
DM_SETDEFID        = (WM_USER+1)

ENDIF   ;NOWINMESSAGES

; Dialog Codes
DLGC_WANTARROWS     = 0001h    ;  /* Control wants arrow keys         */
DLGC_WANTTAB        = 0002h    ;  /* Control wants tab keys           */
DLGC_WANTALLKEYS    = 0004h    ;  /* Control wants all keys           */
DLGC_WANTMESSAGE    = 0004h    ;  /* Pass message to control          */
DLGC_HASSETSEL      = 0008h    ;  /* Understands EM_SETSEL message    */
DLGC_DEFPUSHBUTTON  = 0010h    ;  /* Default pushbutton               */
DLGC_UNDEFPUSHBUTTON= 0020h    ;  /* Non-default pushbutton           */
DLGC_RADIOBUTTON    = 0040h    ;  /* Radio button                     */
DLGC_WANTCHARS      = 0080h    ;  /* Want WM_CHAR messages            */
DLGC_STATIC         = 0100h    ;  /* Static item: don't include       */
DLGC_BUTTON         = 2000h    ;  /* Button item: can be checked      */

; Combo Box return Values
CB_OKAY          =   0
CB_ERR           =   (-1)
CB_ERRSPACE      =   (-2)

; Combo Box Notification Codes
CBN_ERRSPACE     =   (-1)
CBN_SELCHANGE    =   1
CBN_DBLCLK       =   2
CBN_SETFOCUS     =   3
CBN_KILLFOCUS    =   4
CBN_EDITCHANGE   =   5
CBN_EDITUPDATE   =   6
CBN_DROPDOWN     =   7

; Combo Box styles (low words)
CBS_SIMPLE           = 0001h
CBS_DROPDOWN         = 0002h
CBS_DROPDOWNLIST     = 0003h
CBS_OWNERDRAWFIXED   = 0010h
CBS_OWNERDRAWVARIABLE= 0020h
CBS_AUTOHSCROLL      = 0040h
CBS_OEMCONVERT       = 0080h
CBS_SORT             = 0100h
CBS_HASSTRINGS       = 0200h
CBS_NOINTEGRALHEIGHT = 0400h

IFNDEF NOWINMESSAGES

; Combo Box messages
CB_GETEDITSEL            = (WM_USER+0)
CB_LIMITTEXT             = (WM_USER+1)
CB_SETEDITSEL            = (WM_USER+2)
CB_ADDSTRING             = (WM_USER+3)
CB_DELETESTRING          = (WM_USER+4)
CB_DIR                   = (WM_USER+5)
CB_GETCOUNT              = (WM_USER+6)
CB_GETCURSEL             = (WM_USER+7)
CB_GETLBTEXT             = (WM_USER+8)
CB_GETLBTEXTLEN          = (WM_USER+9)
CB_INSERTSTRING          = (WM_USER+10)
CB_RESETCONTENT          = (WM_USER+11)
CB_FINDSTRING            = (WM_USER+12)
CB_SELECTSTRING          = (WM_USER+13)
CB_SETCURSEL             = (WM_USER+14)
CB_SHOWDROPDOWN          = (WM_USER+15)
CB_GETITEMDATA           = (WM_USER+16)
CB_SETITEMDATA           = (WM_USER+17)
IFNDEF NOWIN31
CB_GETDROPPEDCONTROLRECT = (WM_USER+18)
CB_SETITEMHEIGHT         = (WM_USER+19)
CB_GETITEMHEIGHT         = (WM_USER+20)
CB_SETEXTENDEDUI         = (WM_USER+21)
CB_GETEXTENDEDUI         = (WM_USER+22)
CB_GETDROPPEDSTATE       = (WM_USER+23)
CB_FINDSTRINGEXACT       = (WM_USER+24)
ENDIF

ENDIF ; NOWINMESSAGES

; Static Control styles (low word)
SS_LEFT            = 00h
SS_CENTER          = 01h
SS_RIGHT           = 02h
SS_ICON            = 03h
SS_BLACKRECT       = 04h
SS_GRAYRECT        = 05h
SS_WHITERECT       = 06h
SS_BLACKFRAME      = 07h
SS_GRAYFRAME       = 08h
SS_WHITEFRAME      = 09h
SS_SIMPLE          = 0Bh
SS_LEFTNOWORDWRAP  = 0Ch
SS_NOPREFIX        = 80h    ; Don't do "&" character translation

IFNDEF NOWIN31
IFNDEF NOWINMESSAGES

;Static Control Messages
STM_SETICON        = (WM_USER+0)
STM_GETICON        = (WM_USER+1)
ENDIF
ENDIF

; Scroll Bar Styles (low word)
SBS_HORZ                    = 0000h
SBS_VERT                    = 0001h
SBS_TOPALIGN                = 0002h
SBS_LEFTALIGN               = 0002h
SBS_BOTTOMALIGN             = 0004h
SBS_RIGHTALIGN              = 0004h
SBS_SIZEBOXTOPLEFTALIGN     = 0002h
SBS_SIZEBOXBOTTOMRIGHTALIGN = 0004h
SBS_SIZEBOX                 = 0008h

IFNDEF NOSYSMETRICS

; GetSystemMetrics() codes
SM_CXSCREEN           =  0
SM_CYSCREEN           =  1
SM_CXVSCROLL          =  2
SM_CYHSCROLL          =  3
SM_CYCAPTION          =  4
SM_CXBORDER           =  5
SM_CYBORDER           =  6
SM_CXDLGFRAME         =  7
SM_CYDLGFRAME         =  8
SM_CYVTHUMB           =  9
SM_CXHTHUMB           =  10
SM_CXICON             =  11
SM_CYICON             =  12
SM_CXCURSOR           =  13
SM_CYCURSOR           =  14
SM_CYMENU             =  15
SM_CXFULLSCREEN       =  16
SM_CYFULLSCREEN       =  17
SM_CYKANJIWINDOW      =  18
SM_MOUSEPRESENT       =  19
SM_CYVSCROLL          =  20
SM_CXHSCROLL          =  21
SM_DEBUG              =  22
SM_SWAPBUTTON         =  23
SM_RESERVED1          =  24
SM_RESERVED2          =  25
SM_RESERVED3          =  26
SM_RESERVED4          =  27
SM_CXMIN              =  28
SM_CYMIN              =  29
SM_CXSIZE             =  30
SM_CYSIZE             =  31
SM_CXFRAME            =  32
SM_CYFRAME            =  33
SM_CXMINTRACK         =  34
SM_CYMINTRACK         =  35
IFNDEF NOWIN31
SM_CXDOUBLECLK        =  36
SM_CYDOUBLECLK        =  37
SM_CXICONSPACING      =  38
SM_CYICONSPACING      =  39
SM_MENUDROPALIGNMENT  =  40
SM_PENWINDOWS         =  41
SM_DBCSENABLED        =  42
ENDIF
SM_CMETRICSMAX        =  43

ENDIF   ;NOSYSMETRICS

IFNDEF  NOCOLOR

COLOR_SCROLLBAR           = 0
COLOR_BACKGROUND          = 1
COLOR_ACTIVECAPTION       = 2
COLOR_INACTIVECAPTION     = 3
COLOR_MENU                = 4
COLOR_WINDOW              = 5
COLOR_WINDOWFRAME         = 6
COLOR_MENUTEXT            = 7
COLOR_WINDOWTEXT          = 8
COLOR_CAPTIONTEXT         = 9
COLOR_ACTIVEBORDER        = 10
COLOR_INACTIVEBORDER      = 11
COLOR_APPWORKSPACE        = 12
COLOR_HIGHLIGHT           = 13
COLOR_HIGHLIGHTTEXT       = 14
COLOR_BTNFACE             = 15
COLOR_BTNSHADOW           = 16
COLOR_GRAYTEXT            = 17
COLOR_BTNTEXT             = 18
IFNDEF NOWIN31
COLOR_INACTIVECAPTIONTEXT = 19
COLOR_BTNHILIGHT          = 20
ENDIF
ENDIF   ;NOCOLOR

; Commands to pass WinHelp()
HELP_CONTEXT    =0001h  ;/* Display topic in ulTopic */
HELP_QUIT       =0002h  ;/* Terminate help */
HELP_INDEX      =0003h  ;/* Display index */
HELP_HELPONHELP =0004h  ;/* Display help on using help */
HELP_SETINDEX   =0005h  ;/* Set the current Index for multi index help */
HELP_KEY        =0101h  ;/* Display topic for keyword in offabData */

IFNDEF NOCOMM

NOPARITY        =   0
ODDPARITY       =   1
EVENPARITY      =   2
MARKPARITY      =   3
SPACEPARITY     =   4

ONESTOPBIT      =   0
ONE5STOPBITS    =   1
TWOSTOPBITS     =   2

IGNORE          =   0      ; /* Ignore signal    */
INFINITE        =   0FFFFh ; /* Infinite timeout */

; Error Flags
CE_RXOVER       =    0001h ; /* Receive Queue overflow       */
CE_OVERRUN      =    0002h ; /* Receive Overrun Error        */
CE_RXPARITY     =    0004h ; /* Receive Parity Error         */
CE_FRAME        =    0008h ; /* Receive Framing error        */
CE_BREAK        =    0010h ; /* Break Detected               */
CE_CTSTO        =    0020h ; /* CTS Timeout                  */
CE_DSRTO        =    0040h ; /* DSR Timeout                  */
CE_RLSDTO       =    0080h ; /* RLSD Timeout                 */
CE_TXFULL       =    0100h ; /* TX Queue is full             */
CE_PTO          =    0200h ; /* LPTx Timeout                 */
CE_IOE          =    0400h ; /* LPTx I/O Error               */
CE_DNS          =    0800h ; /* LPTx Device not selected     */
CE_OOP          =    1000h ; /* LPTx Out-Of-Paper            */
CE_MODE         =    8000h ; /* Requested mode unsupported   */

IE_BADID        =    (-1)  ;  /* Invalid or unsupported id    */
IE_OPEN         =    (-2)  ;  /* Device Already Open          */
IE_NOPEN        =    (-3)  ;  /* Device Not Open              */
IE_MEMORY       =    (-4)  ;  /* Unable to allocate queues    */
IE_DEFAULT      =    (-5)  ;  /* Error in default parameters  */
IE_HARDWARE     =    (-10) ;  /* Hardware Not Present         */
IE_BYTESIZE     =    (-11) ;  /* Illegal Byte Size            */
IE_BAUDRATE     =    (-12) ;  /* Unsupported BaudRate         */

; Events
EV_RXCHAR       =    0001h ; /* Any Character received       */
EV_RXFLAG       =    0002h ; /* Received certain character   */
EV_TXEMPTY      =    0004h ; /* Transmitt Queue Empty        */
EV_CTS          =    0008h ; /* CTS changed state            */
EV_DSR          =    0010h ; /* DSR changed state            */
EV_RLSD         =    0020h ; /* RLSD changed state           */
EV_BREAK        =    0040h ; /* BREAK received               */
EV_ERR          =    0080h ; /* Line status error occurred   */
EV_RING         =    0100h ; /* Ring signal detected         */
EV_PERR         =    0200h ; /* Printer error occured        */
EV_CTSS         =    0400h ; /* CTS state                    */
EV_DSRS         =    0800h ; /* DSR state                    */
EV_RLSDS        =    1000h ; /* RLSD state                   */
EV_RingTe       =    2000h ; /* Ring Trailing Edge Indicator */


; Escape Functions
SETXOFF         =    1     ;  /* Simulate XOFF received       */
SETXON          =    2     ;  /* Simulate XON received        */
SETRTS          =    3     ;  /* Set RTS high                 */
CLRRTS          =    4     ;  /* Set RTS low                  */
SETDTR          =    5     ;  /* Set DTR high                 */
CLRDTR          =    6     ;  /* Set DTR low                  */
RESETDEV        =    7     ;  /* Reset device if possible     */

LPTx            =    80h   ; /* Set if ID is for LPT device  */

IFNDEF NOWIN31
; new escape functions
GETMAXLPT   equ  8         ; Max supported LPT id
GETMAXCOM   equ  9         ; Max supported COM id
GETBASEIRQ  equ 10         ; Get port base & irq for a port

; Comm Baud Rate indices
CBR_110     equ 0FF10h
CBR_300     equ 0FF11h
CBR_600     equ 0FF12h
CBR_1200    equ 0FF13h
CBR_2400    equ 0FF14h
CBR_4800    equ 0FF15h
CBR_9600    equ 0FF16h
CBR_14400   equ 0FF17h
CBR_19200   equ 0FF18h
;               0FF19h  (reserved)
;               0FF1Ah  (reserved)
CBR_38400   equ 0FF1Bh
;               0FF1Ch  (reserved)
;               0FF1Dh  (reserved)
;               0FF1Eh  (reserved)
CBR_56000   equ 0FF1Fh
;               0FF20h  (reserved)
;               0FF21h  (reserved)
;               0FF22h  (reserved)
CBR_128000  equ 0FF23h
;               0FF24h  (reserved)
;               0FF25h  (reserved)
;               0FF26h  (reserved)
CBR_256000  equ 0FF27h

; notifications passed in low word of lParam on WM_COMMNOTIFY messages
CN_RECEIVE  equ 1           ; bytes are available in the input queue
CN_TRANSMIT equ 2           ; fewer than wOutTrigger bytes still
                            ; remain in the output queue waiting
                            ; to be transmitted.
CN_EVENT    equ 4           ; an enabled event has occurred

ENDIF


DCB     struc
    DCB_Id             db ?  ; /* Internal Device ID              */
    DCB_BaudRate       dw ?  ; /* Baudrate at which runing        */
    DCB_ByteSize       db ?  ; /* Number of bits/byte, 4-8        */
    DCB_Parity         db ?  ; /* 0-4=None,Odd,Even,Mark,Space    */
    DCB_StopBits       db ?  ; /* 0,1,2 = 1, 1.5, 2               */
    DCB_RlsTimeout     dw ?  ; /* Timeout for RLSD to be set      */
    DCB_CtsTimeout     dw ?  ; /* Timeout for CTS to be set       */
    DCB_DsrTimeout     dw ?  ; /* Timeout for DSR to be set       */

    DCB_BitMask1       db ?

    ;   BYTE fBinary: 1;     /* Binary Mode (skip EOF check     */
    ;   BYTE fRtsDisable:1;  /* Don't assert RTS at init time   */
    ;   BYTE fParity: 1;     /* Enable parity checking          */
    ;   BYTE fOutxCtsFlow:1; /* CTS handshaking on output       */
    ;   BYTE fOutxDsrFlow:1; /* DSR handshaking on output       */
    ;   BYTE fDummy: 2;      /* Reserved                        */
    ;   BYTE fDtrDisable:1;  /* Don't assert DTR at init time   */

    DCB_BitMask2       db ?

    ;   BYTE fOutX: 1;       /* Enable output X-ON/X-OFF        */
    ;   BYTE fInX: 1;        /* Enable input X-ON/X-OFF         */
    ;   BYTE fPeChar: 1;     /* Enable Parity Err Replacement   */
    ;   BYTE fNull: 1;       /* Enable Null stripping           */
    ;   BYTE fChEvt: 1;      /* Enable Rx character event.      */
    ;   BYTE fDtrflow: 1;    /* DTR handshake on input          */
    ;   BYTE fRtsflow: 1;    /* RTS handshake on input          */
    ;   BYTE fDummy2: 1;

    DCB_XonChar        db ? ; /* Tx and Rx X-ON character        */
    DCB_XoffChar       db ? ; /* Tx and Rx X-OFF character       */
    DCB_XonLim         dw ? ; /* Transmit X-ON threshold         */
    DCB_XoffLim        dw ? ; /* Transmit X-OFF threshold        */
    DCB_PeChar         db ? ; /* Parity error replacement char   */
    DCB_EofChar        db ? ; /* End of Input character          */
    DCB_EvtChar        db ? ; /* Recieved Event character        */
    DCB_TxDelay        dw ? ; /* Amount of time between chars    */
DCB     ends

COMSTAT     struc
    COMS_BitMask1   db ?

;    BYTE fCtsHold: 1;   /* Transmit is on CTS hold         */
;    BYTE fDsrHold: 1;   /* Transmit is on DSR hold         */
;    BYTE fRlsdHold: 1;  /* Transmit is on RLSD hold        */
;    BYTE fXoffHold: 1;  /* Received handshake              */
;    BYTE fXoffSent: 1;  /* Issued handshake                */
;    BYTE fEof: 1;       /* End of file character found     */
;    BYTE fTxim: 1;      /* Character being transmitted     */


    COMS_cbInQue    dw ?  ;   /* count of characters in Rx Queue */
    COMS_cbOutQue   dw ?  ;   /* count of characters in Tx Queue */
COMSTAT     ends

ENDIF       ;NOCOM

;
; Installable Driver Support
;
; Driver Messages
DRV_LOAD            = 0001h
DRV_ENABLE          = 0002h
DRV_OPEN            = 0003h
DRV_CLOSE           = 0004h
DRV_DISABLE         = 0005h
DRV_FREE            = 0006h
DRV_CONFIGURE       = 0007h
DRV_QUERYCONFIGURE  = 0008h
DRV_INSTALL         = 0009h
DRV_REMOVE          = 000Ah
DRV_EXITSESSION     = 000Bh
DRV_POWER           = 000Fh
DRV_RESERVED        = 0800h
DRV_USER            = 4000h

;LPARAM of DRV_CONFIGURE message and return values
DRVCONFIGINFO struc
    DRVCNF_dwDCISize          dw ?
    DRVCNF_lpszDCISectionName dd ?
    DRVCNF_lpszDCIAliasName   dd ?
DRVCONFIGINFO ends

DRVCNF_CANCEL       = 0000h
DRVCNF_OK           = 0001h
DRVCNF_RESTART      = 0002h


IFNDEF  NOKERNEL
;
; Common Kernel errors
;
ERR_GALLOC      = 01030h        ; GlobalAlloc Failed
ERR_GREALLOC    = 01031h        ; GlobalReAlloc Failed
ERR_GLOCK       = 01032h        ; GlobalLock Failed
ERR_LALLOC      = 01033h        ; LocalAlloc Failed
ERR_LREALLOC    = 01034h        ; LocalReAlloc Failed
ERR_LLOCK       = 01035h        ; LocalLock Failed
ERR_ALLOCRES    = 01036h        ; AllocResource Failed
ERR_LOCKRES     = 01037h        ; LockResource Failed
ERR_LOADMODULE  = 01038h        ; LoadModule failed

;
; Common User Errors
;
ERR_CREATEDLG        =  01045h ; /* Create Dlg failure due to LoadMenu failure */
ERR_CREATEDLG2       =  01046h ; /* Create Dlg failure due to CreateWindow Failure */
ERR_REGISTERCLASS    =  01047h ; /* RegisterClass failure due to Class already registered */
ERR_DCBUSY           =  01048h ; /* DC Cache is full */
ERR_CREATEWND        =  01049h ; /* Create Wnd failed due to class not found */
ERR_STRUCEXTRA       =  01050h ; /* Unallocated Extra space is used */
ERR_LOADSTR          =  01051h ; /* LoadString() failed */
ERR_LOADMENU         =  01052h ; /* LoadMenu Failed     */
ERR_NESTEDBEGINPAINT =  01053h ; /* Nested BeginPaint() calls */
ERR_BADINDEX         =  01054h ; /* Bad index to Get/Set Class/Window Word/Long */
ERR_CREATEMENU       =  01055h ; /* Error creating menu */

;
; Common GDI Errors
;
ERR_CREATEDC        = 01070h    ; /* CreateDC/CreateIC etc., failure */
ERR_CREATEMETA      = 01071h    ; /* CreateMetafile failure */
ERR_DELOBJSELECTED  = 01072h    ; /* Bitmap being deleted is selected into DC */
ERR_SELBITMAP       = 01073h    ; /* Bitmap being selected is already selected elsewhere */

ENDIF       ;NOKERNEL
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef __VER_H         /* prevent multiple includes */
#define __VER_H

#if !defined(__WINDOWS_H) && !defined(LIB)
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI          /* don't declare if they're already declared */
#define WINAPI          _far _pascal
#define NEAR            _near
#define FAR             _far
#define PASCAL          _pascal
typedef int             BOOL;
#define TRUE            1
#define FALSE           0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT        void    /* Not used by the .lib version */
#define LOWORD(l)               ((WORD)(l))
#define HIWORD(l)               ((WORD)((DWORD)(l) >> 16))
#define MAKEINTRESOURCE(i)      (LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used then windows.h is including     */
/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#define WINAPI      FAR PASCAL
#endif  /* WIN3.0 */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)                  id
#else
#define ID(id)                  MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO            ID(16)          /* Version stamp res type */
#define VS_VERSION_INFO         ID(1)           /* Version stamp res ID */
#define VS_USER_DEFINED         ID(100)         /* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FFI_SIGNATURE        0xFEEF04BDL
#define VS_FFI_STRUCVERSION     0x00010000L
#define VS_FFI_FILEFLAGSMASK    0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FF_DEBUG             0x00000001L
#define VS_FF_PRERELEASE        0x00000002L
#define VS_FF_PATCHED           0x00000004L
#define VS_FF_PRIVATEBUILD      0x00000008L
#define VS_FF_INFOINFERRED      0x00000010L
#define VS_FF_SPECIALBUILD      0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define VOS_UNKNOWN             0x00000000L
#define VOS_DOS                 0x00010000L
#define VOS_OS216               0x00020000L
#define VOS_OS232               0x00030000L
#define VOS_NT                  0x00040000L

#define VOS__BASE               0x00000000L
#define VOS__WINDOWS16          0x00000001L
#define VOS__PM16               0x00000002L
#define VOS__PM32               0x00000003L
#define VOS__WINDOWS32          0x00000004L

#define VOS_DOS_WINDOWS16       0x00010001L
#define VOS_DOS_WINDOWS32       0x00010004L
#define VOS_OS216_PM16          0x00020002L
#define VOS_OS232_PM32          0x00030003L
#define VOS_NT_WINDOWS32        0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define VFT_UNKNOWN             0x00000000L
#define VFT_APP                 0x00000001L
#define VFT_DLL                 0x00000002L
#define VFT_DRV                 0x00000003L
#define VFT_FONT                0x00000004L
#define VFT_VXD                 0x00000005L
#define VFT_STATIC_LIB          0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define VFT2_UNKNOWN            0x00000000L
#define VFT2_DRV_PRINTER        0x00000001L
#define VFT2_DRV_KEYBOARD       0x00000002L
#define VFT2_DRV_LANGUAGE       0x00000003L
#define VFT2_DRV_DISPLAY        0x00000004L
#define VFT2_DRV_MOUSE          0x00000005L
#define VFT2_DRV_NETWORK        0x00000006L
#define VFT2_DRV_SYSTEM         0x00000007L
#define VFT2_DRV_INSTALLABLE    0x00000008L
#define VFT2_DRV_SOUND          0x00000009L
#define VFT2_DRV_COMM           0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER        0x00000001L
#define VFT2_FONT_VECTOR        0x00000002L
#define VFT2_FONT_TRUETYPE      0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE       0x0001

#define VFF_CURNEDEST           0x0001
#define VFF_FILEINUSE           0x0002
#define VFF_BUFFTOOSMALL        0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL       0x0001
#define VIFF_DONTDELETEOLD      0x0002

#define VIF_TEMPFILE            0x00000001L
#define VIF_MISMATCH            0x00000002L
#define VIF_SRCOLD              0x00000004L

#define VIF_DIFFLANG            0x00000008L
#define VIF_DIFFCODEPG          0x00000010L
#define VIF_DIFFTYPE            0x00000020L

#define VIF_WRITEPROT           0x00000040L
#define VIF_FILEINUSE           0x00000080L
#define VIF_OUTOFSPACE          0x00000100L
#define VIF_ACCESSVIOLATION     0x00000200L
#define VIF_SHARINGVIOLATION    0x00000400L
#define VIF_CANNOTCREATE        0x00000800L
#define VIF_CANNOTDELETE        0x00001000L
#define VIF_CANNOTRENAME        0x00002000L
#define VIF_CANNOTDELETECUR     0x00004000L
#define VIF_OUTOFMEMORY         0x00008000L

#define VIF_CANNOTREADSRC       0x00010000L
#define VIF_CANNOTREADDST       0x00020000L

#define VIF_BUFFTOOSMALL        0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#pragma option -a.      /* Revert to default packing */

#endif  /* RC_INVOKED */

#endif  /* __VER_H */
/*****************************************************************************\
*                                                                             *
* commdlg.h -   Common dialog functions, types, and definitions               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef __COMMDLG_H     /* prevent multiple includes */
#define __COMMDLG_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* If included with the 3.0 windows.h, define compatible aliases */
#if !defined(WINVER) || (WINVER < 0x030a)
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* WIN3.0 */

typedef struct tagOFN
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE hInstance;
    LPCSTR  lpstrFilter;
    LPSTR   lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    LPSTR   lpstrFile;
    DWORD   nMaxFile;
    LPSTR   lpstrFileTitle;
    DWORD   nMaxFileTitle;
    LPCSTR  lpstrInitialDir;
    LPCSTR  lpstrTitle;
    DWORD   Flags;
    UINT    nFileOffset;
    UINT    nFileExtension;
    LPCSTR  lpstrDefExt;
    LPARAM  lCustData;
    UINT    (CALLBACK *lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
}   OPENFILENAME;
typedef OPENFILENAME FAR* LPOPENFILENAME;

BOOL    WINAPI GetOpenFileName(OPENFILENAME FAR*);
BOOL    WINAPI GetSaveFileName(OPENFILENAME FAR*);
int     WINAPI GetFileTitle(LPCSTR, LPSTR, UINT);

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000

/* Return values for the registered message sent to the hook function
 * when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
 * filename to be accepted, OFN_SHARENOWARN rejects the name but puts
 * up no warning (returned when the app has already put up a warning
 * message), and OFN_SHAREWARN puts up the default warning message
 * for sharing violations.
 *
 * Note:  Undefined return values map to OFN_SHAREWARN, but are
 *        reserved for future use.
 */

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef struct tagCHOOSECOLOR
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HWND    hInstance;
    COLORREF rgbResult;
    COLORREF FAR* lpCustColors;
    DWORD   Flags;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
} CHOOSECOLOR;
typedef CHOOSECOLOR FAR *LPCHOOSECOLOR;

BOOL    WINAPI ChooseColor(CHOOSECOLOR FAR*);

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040

typedef struct tagFINDREPLACE
{
    DWORD    lStructSize;            /* size of this struct 0x20 */
    HWND     hwndOwner;              /* handle to owner's window */
    HINSTANCE hInstance;             /* instance handle of.EXE that
                                      * contains cust. dlg. template
                                      */
    DWORD    Flags;                  /* one or more of the FR_?? */
    LPSTR    lpstrFindWhat;          /* ptr. to search string    */
    LPSTR    lpstrReplaceWith;       /* ptr. to replace string   */
    UINT     wFindWhatLen;           /* size of find buffer      */
    UINT     wReplaceWithLen;        /* size of replace buffer   */
    LPARAM   lCustData;              /* data passed to hook fn.  */
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                     /* ptr. to hook fn. or NULL */
    LPCSTR   lpTemplateName;         /* custom template name     */
} FINDREPLACE;
typedef FINDREPLACE FAR *LPFINDREPLACE;

#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004
#define FR_FINDNEXT                     0x00000008
#define FR_REPLACE                      0x00000010
#define FR_REPLACEALL                   0x00000020
#define FR_DIALOGTERM                   0x00000040
#define FR_SHOWHELP                     0x00000080
#define FR_ENABLEHOOK                   0x00000100
#define FR_ENABLETEMPLATE               0x00000200
#define FR_NOUPDOWN                     0x00000400
#define FR_NOMATCHCASE                  0x00000800
#define FR_NOWHOLEWORD                  0x00001000
#define FR_ENABLETEMPLATEHANDLE         0x00002000
#define FR_HIDEUPDOWN                   0x00004000
#define FR_HIDEMATCHCASE                0x00008000
#define FR_HIDEWHOLEWORD                0x00010000

HWND    WINAPI FindText(FINDREPLACE FAR*);
HWND    WINAPI ReplaceText(FINDREPLACE FAR*);

typedef struct tagCHOOSEFONT
{
    DWORD           lStructSize;        /* */
    HWND            hwndOwner;          /* caller's window handle   */
    HDC             hDC;                /* printer DC/IC or NULL    */
    LOGFONT FAR*    lpLogFont;          /* ptr. to a LOGFONT struct */
    int             iPointSize;         /* 10 * size in points of selected font */
    DWORD           Flags;              /* enum. type flags         */
    COLORREF        rgbColors;          /* returned text color      */
    LPARAM          lCustData;          /* data passed to hook fn.  */
    UINT (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                        /* ptr. to hook function    */
    LPCSTR          lpTemplateName;     /* custom template name     */
    HINSTANCE       hInstance;          /* instance handle of.EXE that
                                         * contains cust. dlg. template
                                         */
    LPSTR           lpszStyle;          /* return the style field here
                                         * must be LF_FACESIZE or bigger */
    UINT            nFontType;          /* same value reported to the EnumFonts
                                         * call back with the extra FONTTYPE_
                                         * bits added */
    int             nSizeMin;           /* minimum pt size allowed & */
    int             nSizeMax;           /* max pt size allowed if    */
                                        /* CF_LIMITSIZE is used      */
} CHOOSEFONT;
typedef CHOOSEFONT FAR *LPCHOOSEFONT;

BOOL WINAPI ChooseFont(CHOOSEFONT FAR*);

#define CF_SCREENFONTS               0x00000001
#define CF_PRINTERFONTS              0x00000002
#define CF_BOTH                      (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP                  0x00000004L
#define CF_ENABLEHOOK                0x00000008L
#define CF_ENABLETEMPLATE            0x00000010L
#define CF_ENABLETEMPLATEHANDLE      0x00000020L
#define CF_INITTOLOGFONTSTRUCT       0x00000040L
#define CF_USESTYLE                  0x00000080L
#define CF_EFFECTS                   0x00000100L
#define CF_APPLY                     0x00000200L
#define CF_ANSIONLY                  0x00000400L
#define CF_NOVECTORFONTS             0x00000800L
#define CF_NOOEMFONTS                CF_NOVECTORFONTS
#define CF_NOSIMULATIONS             0x00001000L
#define CF_LIMITSIZE                 0x00002000L
#define CF_FIXEDPITCHONLY            0x00004000L
#define CF_WYSIWYG                   0x00008000L /* must also have CF_SCREENFONTS & CF_PRINTERFONTS */
#define CF_FORCEFONTEXIST            0x00010000L
#define CF_SCALABLEONLY              0x00020000L
#define CF_TTONLY                    0x00040000L
#define CF_NOFACESEL                 0x00080000L
#define CF_NOSTYLESEL                0x00100000L
#define CF_NOSIZESEL                 0x00200000L

/* these are extra nFontType bits that are added to what is returned to the
 * EnumFonts callback routine */

#define SIMULATED_FONTTYPE      0x8000
#define PRINTER_FONTTYPE        0x4000
#define SCREEN_FONTTYPE         0x2000
#define BOLD_FONTTYPE           0x0100
#define ITALIC_FONTTYPE         0x0200
#define REGULAR_FONTTYPE        0x0400

#define WM_CHOOSEFONT_GETLOGFONT        (WM_USER + 1)


/* strings used to obtain unique window message for communication
 * between dialog and caller
 */
#define LBSELCHSTRING  "commdlg_LBSelChangedNotify"
#define SHAREVISTRING  "commdlg_ShareViolation"
#define FILEOKSTRING   "commdlg_FileNameOK"
#define COLOROKSTRING  "commdlg_ColorOK"
#define SETRGBSTRING   "commdlg_SetRGBColor"
#define FINDMSGSTRING  "commdlg_FindReplace"
#define HELPMSGSTRING  "commdlg_help"

/* HIWORD values for lParam of commdlg_LBSelChangeNotify message */
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef struct tagPD
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    HDC     hDC;
    DWORD   Flags;
    UINT    nFromPage;
    UINT    nToPage;
    UINT    nMinPage;
    UINT    nMaxPage;
    UINT    nCopies;
    HINSTANCE hInstance;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnPrintHook)(HWND, UINT, WPARAM, LPARAM);
    UINT    (CALLBACK* lpfnSetupHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpPrintTemplateName;
    LPCSTR  lpSetupTemplateName;
    HGLOBAL hPrintTemplate;
    HGLOBAL hSetupTemplate;
} PRINTDLG;
typedef PRINTDLG  FAR* LPPRINTDLG;

BOOL    WINAPI PrintDlg(PRINTDLG FAR*);

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000

typedef struct tagDEVNAMES
{
    UINT wDriverOffset;
    UINT wDeviceOffset;
    UINT wOutputOffset;
    UINT wDefault;
} DEVNAMES;
typedef DEVNAMES FAR* LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD   WINAPI CommDlgExtendedError(void);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif  /* __COMMDLG_H */
/* stdiostream.h -- class stdiobuf and stdiostream declarations

    Copyright (c) 1990, 1992 by Borland International
    All rights reserved

    NOTE: These are inefficient and obsolete.  Use the standard classes and
    functions in <fstream.h> instead.
*/

#ifndef __cplusplus
#error Must use C++ for the type stdiostream.
#endif

#ifndef __STDSTREAM_H
#define __STDSTREAM_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(__IOSTREAM_H)
#include <iostream.h>
#endif

#if !defined(__STDIO_H)
#include <stdio.h>
#endif

#pragma option -Vo-
#if defined(__BCOPT__) && !defined(_RTL_ALLOW_po)
#pragma option -po-
#endif

_CLASSDEF(stdiobuf)
_CLASSDEF(stdiostream)

class _CLASSTYPE stdiobuf : public streambuf {
public:
    _Cdecl stdiobuf(FILE _FAR *);
    FILE _FAR * _Cdecl stdiofile();
    _Cdecl ~stdiobuf();

    virtual int _Cdecl overflow(int=EOF);
    virtual int _Cdecl pbackfail(int);
    virtual int _Cdecl sync();
    virtual streampos _Cdecl seekoff(streamoff, ios::seek_dir, int);
    virtual int _Cdecl underflow();

private:
    FILE _FAR * sio;
    char    lahead[2];
};
inline  FILE _FAR * _Cdecl stdiobuf::stdiofile() { return sio; }


class _CLASSTYPE stdiostream : public ios {
public:
        _Cdecl stdiostream(FILE _FAR *);
        _Cdecl ~stdiostream();
    stdiobuf _FAR * _Cdecl rdbuf();

private:
    stdiobuf buf;
};
inline  stdiobuf _FAR * _Cdecl stdiostream::rdbuf() { return &buf; }

#pragma option -Vo.
#if defined(__BCOPT__)
#pragma option -po.
#endif

#endif
/* OBSOLETE: Use print.h instead */
#include <print.h>
/*  memory.h

    Memory manipulation functions

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#include <mem.h>
PKBGI Stroked Font V1.1 - Jun 5, 1989
Copyright (c) 1987,1988 Borland International
 SIMPu                              +              : N   <Nv @bn@Xv,:h.>J^n4@Xdx Dd.>Fj 	&	8	N	Z	n	z					B
N
b


 .f(b6|2Rv6R Jn*<^v 8DTdr $8LXt $v\~&`(Rh6Ldr
	
		

	          
                         	      	      }                                                                                                       
                                              y                           
               

   
                                                        |                                                                                    }      }   
   |               
                                         		    		}}}}     		  		  		  		}}}}}}}}   						}}}}}}}}}}}}						         y	         	   	      	   	   		   	      	   		               y	      	   	   	   	y   	   	   	y   		   	   	   yy   		   	   	         	   	                      
       	                   		   	}}}   
             }          	                  z   
                            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;         MMSYSTEM.INC - Multimedia assembly language structures & constants
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;     If defined, the following flags inhibit inclusion
;     of the indicated items:
;
;       MMNODRV          - Installable driver support
;       MMNOSOUND        - Sound support
;       MMNOWAVE         - Waveform support
;       MMNOMIDI         - MIDI support
;       MMNOAUX          - Auxiliary audio support
;       MMNOTIMER        - Timer support
;       MMNOJOY          - Joystick support
;       MMNOMCI          - MCI support
;       MMNOMMIO         - Multimedia file I/O support
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   General constants and data types
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; general constants
MAXPNAMELEN        equ    32     ; max product name length (including NULL)
MAXERRORLENGTH     equ    128    ; max error text length (including NULL)

; MMTIME data structure
MMTIME  struc
    mmt_wType           dw    ?  ; indicates the contents of the union
    mmt_TimeUnion       dd    ?  ; union
MMTIME  ends

SMPTE struc
    smpte_hour      db    ?  ; hours
    smpte_min       db    ?  ; minutes
    smpte_sec       db    ?  ; seconds
    smpte_frame     db    ?  ; frames
    smpte_fps       db    ?  ; frames per second
    smpte_reserved  db    ?  ; pad
SMPTE ends

; types for wType field in MMTIME struct
TIME_MS         equ    0001h   ; time in milliseconds
TIME_SAMPLES    equ    0002h   ; number of wave samples
TIME_BYTES      equ    0004h   ; current byte offset
TIME_SMPTE      equ    0008h   ; SMPTE time
TIME_MIDI       equ    0010h   ; MIDI time


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   Multimedia Extensions Window Messages
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MM_JOY1MOVE         equ    3A0h            ; joystick
MM_JOY2MOVE         equ    3A1h
MM_JOY1ZMOVE        equ    3A2h
MM_JOY2ZMOVE        equ    3A3h
MM_JOY1BUTTONDOWN   equ    3B5h
MM_JOY2BUTTONDOWN   equ    3B6h
MM_JOY1BUTTONUP     equ    3B7h
MM_JOY2BUTTONUP     equ    3B8h

MM_MCINOTIFY        equ    3B9h            ; MCI
MM_MCISYSTEM_STRING equ    3CAh

MM_WOM_OPEN         equ    3BBh            ; waveform output
MM_WOM_CLOSE        equ    3BCh
MM_WOM_DONE         equ    3BDh

MM_WIM_OPEN         equ    3BEh            ; waveform input
MM_WIM_CLOSE        equ    3BFh
MM_WIM_DATA         equ    3C0h

MM_MIM_OPEN         equ    3C1h            ; MIDI input
MM_MIM_CLOSE        equ    3C2h
MM_MIM_DATA         equ    3C3h
MM_MIM_LONGDATA     equ    3C4h
MM_MIM_ERROR        equ    3C5h
MM_MIM_LONGERROR    equ    3C6h

MM_MOM_OPEN         equ    3C7h            ; MIDI output
MM_MOM_CLOSE        equ    3C8h
MM_MOM_DONE         equ    3C9h


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;               String resource number bases (internal use)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MMSYSERR_BASE          equ    0
WAVERR_BASE            equ    32
MIDIERR_BASE           equ    64
TIMERR_BASE            equ    96
JOYERR_BASE            equ    160
MCIERR_BASE            equ    256

MCI_STRING_OFFSET      equ    512
MCI_VD_OFFSET          equ    1024
MCI_CD_OFFSET          equ    1088
MCI_WAVE_OFFSET        equ    1152
MCI_SEQ_OFFSET         equ    1216

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       General error return values
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; general error return values
MMSYSERR_NOERROR      equ    0                    ; no error
MMSYSERR_ERROR        equ    (MMSYSERR_BASE + 1)  ; unspecified error
MMSYSERR_BADDEVICEID  equ    (MMSYSERR_BASE + 2)  ; device ID out of range
MMSYSERR_NOTENABLED   equ    (MMSYSERR_BASE + 3)  ; driver failed enable
MMSYSERR_ALLOCATED    equ    (MMSYSERR_BASE + 4)  ; device already allocated
MMSYSERR_INVALHANDLE  equ    (MMSYSERR_BASE + 5)  ; device handle is invalid
MMSYSERR_NODRIVER     equ    (MMSYSERR_BASE + 6)  ; no device driver present
MMSYSERR_NOMEM        equ    (MMSYSERR_BASE + 7)  ; memory allocation error
MMSYSERR_NOTSUPPORTED equ    (MMSYSERR_BASE + 8)  ; function isn't supported
MMSYSERR_BADERRNUM    equ    (MMSYSERR_BASE + 9)  ; error value out of range
MMSYSERR_INVALFLAG    equ    (MMSYSERR_BASE + 10) ; invalid flags passed
MMSYSERR_INVALPARAM   equ    (MMSYSERR_BASE + 11) ; invalid parameter passed
MMSYSERR_LASTERROR    equ    (MMSYSERR_BASE + 11) ; last error in range


ifndef MMNODRV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Installable driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DRV_MCI_FIRST          equ    DRV_RESERVED
DRV_MCI_LAST           equ    (DRV_RESERVED + 0FFFh)

endif  ;ifndef MMNODRV


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                         Driver callback support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and
; midiOutOpen() to specify the type of the dwCallback parameter.
CALLBACK_TYPEMASK   equ    00070000h     ; callback type mask
CALLBACK_NULL       equ    00000000h     ; no callback
CALLBACK_WINDOW     equ    00010000h     ; dwCallback is a HWND
CALLBACK_TASK       equ    00020000h     ; dwCallback is a HTASK
CALLBACK_FUNCTION   equ    00030000h     ; dwCallback is a FARPROC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                        Manufacturer and product IDs
;
;   Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS,
;   MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; manufacturer IDs
MM_MICROSOFT            equ    1       ; Microsoft Corp.

; product IDs
MM_MIDI_MAPPER          equ    1       ; MIDI Mapper
MM_WAVE_MAPPER          equ    2       ; Wave Mapper

MM_SNDBLST_MIDIOUT      equ    3       ; Sound Blaster MIDI output port
MM_SNDBLST_MIDIIN       equ    4       ; Sound Blaster MIDI input port
MM_SNDBLST_SYNTH        equ    5       ; Sound Blaster internal synthesizer
MM_SNDBLST_WAVEOUT      equ    6       ; Sound Blaster waveform output
MM_SNDBLST_WAVEIN       equ    7       ; Sound Blaster waveform input

MM_ADLIB                equ    9       ; Ad Lib-compatible synthesizer

MM_MPU401_MIDIOUT       equ    10      ; MPU401-compatible MIDI output port
MM_MPU401_MIDIIN        equ    11      ; MPU401-compatible MIDI input port

MM_PC_JOYSTICK          equ    12      ; Joystick adapter


ifndef MMNOSOUND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Sound support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; flag values for wFlags parameter
SND_SYNC            equ    0000h   ; play synchronously (default)
SND_ASYNC           equ    0001h   ; play asynchronously
SND_NODEFAULT       equ    0002h   ; don't use default sound
SND_MEMORY          equ    0004h   ; lpszSoundName points to a memory file
SND_LOOP            equ    0008h   ; loop the sound until next sndPlaySound
SND_NOSTOP          equ    0010h   ; don't stop any currently playing sound

endif  ;ifndef MMNOSOUND


ifndef MMNOWAVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Waveform audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; waveform audio error return values
WAVERR_BADFORMAT      equ    (WAVERR_BASE + 0)    ; unsupported wave format
WAVERR_STILLPLAYING   equ    (WAVERR_BASE + 1)    ; still something playing
WAVERR_UNPREPARED     equ    (WAVERR_BASE + 2)    ; header not prepared
WAVERR_SYNC           equ    (WAVERR_BASE + 3)    ; device is synchronous
WAVERR_LASTERROR      equ    (WAVERR_BASE + 3)    ; last error in range

; wave callback messages
WOM_OPEN        equ    MM_WOM_OPEN
WOM_CLOSE       equ    MM_WOM_CLOSE
WOM_DONE        equ    MM_WOM_DONE
WIM_OPEN        equ    MM_WIM_OPEN
WIM_CLOSE       equ    MM_WIM_CLOSE
WIM_DATA        equ    MM_WIM_DATA

; device ID for wave device mapper
WAVE_MAPPER     equ    (-1)

; flags for dwFlags parameter in waveOutOpen() and waveInOpen()
WAVE_FORMAT_QUERY     equ    0001h
WAVE_ALLOWSYNC        equ    0002h

; wave data block header
WAVEHDR struc
    lpWaveData               dd    ?     ; pointer to locked data buffer
    dwWaveBufferLength       dd    ?     ; length of data buffer
    dwWaveBytesRecorded      dd    ?     ; used for input only
    dwWaveUser               dd    ?     ; for client's use
    dwWaveFlags              dd    ?     ; assorted flags (see defines)
    dwWaveLoops              dd    ?     ; loop control counter
    lpWaveNext               dd    ?     ; reserved for driver
    Wavereserved             dd    ?     ; reserved for driver
WAVEHDR ends

; flags for dwFlags field of WAVEHDR
WHDR_DONE       equ    00000001h   ; done bit
WHDR_PREPARED   equ    00000002h   ; set if this header has been prepared
WHDR_BEGINLOOP  equ    00000004h   ; loop start block
WHDR_ENDLOOP    equ    00000008h   ; loop end block
WHDR_INQUEUE    equ    00000010h   ; reserved for driver

; waveform output device capabilities structure
WAVEOUTCAPS struc
    woc_wMid            dw      ?      ; manufacturer ID
    woc_wPid            dw      ?      ; product ID
    woc_vDriverVersion  dw      ?      ; version of the driver
    woc_szPname         db MAXPNAMELEN dup (?)  ; product name (NULL terminated string)
    woc_dwFormats       dd      ?      ; formats supported
    woc_wChannels       dw      ?      ; number of sources supported
    woc_dwSupport       dd      ?      ; functionality supported by driver
WAVEOUTCAPS ends

; flags for dwSupport field of WAVEOUTCAPS
WAVECAPS_PITCH          equ    0001h    ; supports pitch control
WAVECAPS_PLAYBACKRATE   equ    0002h    ; supports playback rate control
WAVECAPS_VOLUME         equ    0004h    ; supports volume control
WAVECAPS_LRVOLUME       equ    0008h    ; separate left-right volume control
WAVECAPS_SYNC           equ    0010h

; waveform input device capabilities structure
WAVEINCAPS struc
    wic_wMid            dw      ?      ; manufacturer ID
    wic_wPid            dw      ?      ; product ID
    wic_vDriverVersion  dw      ?      ; version of the driver
    wic_szPname         db MAXPNAMELEN dup (?)  ; product name (NULL terminated string)
    wic_dwFormats       dd      ?      ; formats supported
    wic_wChannels       dw      ?      ; number of channels supported
WAVEINCAPS ends

; defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
WAVE_INVALIDFORMAT     equ    00000000h        ; invalid format
WAVE_FORMAT_1M08       equ    00000001h        ; 11.025 kHz, Mono,   8-bit
WAVE_FORMAT_1S08       equ    00000002h        ; 11.025 kHz, Stereo, 8-bit
WAVE_FORMAT_1M16       equ    00000004h        ; 11.025 kHz, Mono,   16-bit
WAVE_FORMAT_1S16       equ    00000008h        ; 11.025 kHz, Stereo, 16-bit
WAVE_FORMAT_2M08       equ    00000010h        ; 22.05  kHz, Mono,   8-bit
WAVE_FORMAT_2S08       equ    00000020h        ; 22.05  kHz, Stereo, 8-bit
WAVE_FORMAT_2M16       equ    00000040h        ; 22.05  kHz, Mono,   16-bit
WAVE_FORMAT_2S16       equ    00000080h        ; 22.05  kHz, Stereo, 16-bit
WAVE_FORMAT_4M08       equ    00000100h        ; 44.1   kHz, Mono,   8-bit
WAVE_FORMAT_4S08       equ    00000200h        ; 44.1   kHz, Stereo, 8-bit
WAVE_FORMAT_4M16       equ    00000400h        ; 44.1   kHz, Mono,   16-bit
WAVE_FORMAT_4S16       equ    00000800h        ; 44.1   kHz, Stereo, 16-bit

; general waveform format structure (information common to all formats)
WAVEFORMAT struc
    wfmt_wFormatTag       dw    ?   ; format type
    wfmt_nChannels        dw    ?   ; number of channels (i.e. mono, stereo, etc.)
    wfmt_nSamplesPerSec   dd    ?   ; sample rate
    wfmt_nAvgBytesPerSec  dd    ?   ; for buffer estimation
    wfmt_nBlockAlign      dw    ?   ; block size of data
WAVEFORMAT ends

; flags for wFormatTag field of WAVEFORMAT
WAVE_FORMAT_PCM     equ    1

; specific waveform format structure for PCM data
PCMWAVEFORMAT struc
    pcm_wf               db (SIZE WAVEFORMAT) dup (?)
    pcm_wBitsPerSample   dw    ?
PCMWAVEFORMAT ends

endif  ;ifndef MMNOWAVE


ifndef MMNOMIDI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MIDI audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MIDI error return values
MIDIERR_UNPREPARED    equ    (MIDIERR_BASE + 0)   ; header not prepared
MIDIERR_STILLPLAYING  equ    (MIDIERR_BASE + 1)   ; still something playing
MIDIERR_NOMAP         equ    (MIDIERR_BASE + 2)   ; no current map
MIDIERR_NOTREADY      equ    (MIDIERR_BASE + 3)   ; hardware is still busy
MIDIERR_NODEVICE      equ    (MIDIERR_BASE + 4)   ; port no longer connected
MIDIERR_INVALIDSETUP  equ    (MIDIERR_BASE + 5)   ; invalid setup
MIDIERR_LASTERROR     equ    (MIDIERR_BASE + 5)   ; last error in range

; MIDI audio data types
MIDIPATCHSIZE   equ    128

; MIDI callback messages
MIM_OPEN        equ    MM_MIM_OPEN
MIM_CLOSE       equ    MM_MIM_CLOSE
MIM_DATA        equ    MM_MIM_DATA
MIM_LONGDATA    equ    MM_MIM_LONGDATA
MIM_ERROR       equ    MM_MIM_ERROR
MIM_LONGERROR   equ    MM_MIM_LONGERROR
MOM_OPEN        equ    MM_MOM_OPEN
MOM_CLOSE       equ    MM_MOM_CLOSE
MOM_DONE        equ    MM_MOM_DONE

; device ID for MIDI mapper
MIDIMAPPER     equ    (-1)
MIDI_MAPPER    equ    (-1)

; flags for wFlags parm of midiOutCachePatches(),
; midiOutCacheDrumPatches()
MIDI_CACHE_ALL      equ    1
MIDI_CACHE_BESTFIT  equ    2
MIDI_CACHE_QUERY    equ    3
MIDI_UNCACHE        equ    4

; MIDI output device capabilities structure
MIDIOUTCAPS struc
    moc_wMid            dw    ?        ; manufacturer ID
    moc_wPid            dw    ?        ; product ID
    moc_vDriverVersion  dw    ?        ; version of the driver
    moc_szPname         db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    moc_wTechnology     dw    ?        ; type of device
    moc_wVoices         dw    ?        ; # of voices (internal synth only)
    moc_wNotes          dw    ?        ; max # of notes (internal synth only)
    moc_wChannelMask    dw    ?        ; channels used (internal synth only)
    moc_dwSupport       dd    ?        ; functionality supported by driver
MIDIOUTCAPS ends

; flags for wTechnology field of MIDIOUTCAPS structure
MOD_MIDIPORT    equ    1  ; output port
MOD_SYNTH       equ    2  ; generic internal synth
MOD_SQSYNTH     equ    3  ; square wave internal synth
MOD_FMSYNTH     equ    4  ; FM internal synth
MOD_MAPPER      equ    5  ; MIDI mapper

; flags for dwSupport field of MIDIOUTCAPS structure
MIDICAPS_VOLUME          equ    0001h   ; supports volume control
MIDICAPS_LRVOLUME        equ    0002h   ; separate left-right volume control
MIDICAPS_CACHE           equ    0004h

; MIDI output device capabilities structure
MIDIINCAPS struc
    mic_wMid            dw    ?       ; manufacturer ID
    mic_wPid            dw    ?       ; product ID
    mic_vDriverVersion  dw    ?       ; version of the driver
    mic_szPname         db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
MIDIINCAPS ends

; MIDI data block header
MIDIHDR struc
    lpMidiData            dd    ?      ; pointer to locked data block
    dwMidiBufferLength    dd    ?      ; length of data in data block
    dwMidiBytesRecorded   dd    ?      ; used for input only
    dwMidiUser            dd    ?      ; for client's use
    dwMidiFlags           dd    ?      ; assorted flags (see defines)
    lpMidiNext            dd    ?      ; reserved for driver
    Midireserved          dd    ?      ; reserved for driver
MIDIHDR ends

; flags for dwFlags field of MIDIHDR structure
MHDR_DONE       equ    00000001h        ; done bit
MHDR_PREPARED   equ    00000002h        ; set if header prepared
MHDR_INQUEUE    equ    00000004h        ; reserved for driver

endif  ;ifndef MMNOMIDI


ifndef MMNOAUX
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Auxiliary audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; device ID for aux device mapper
AUX_MAPPER     equ    (-1)

; Auxiliary audio device capabilities structure
AUXCAPS struc
    acaps_wMid              dw    ?      ; manufacturer ID
    acaps_wPid              dw    ?      ; product ID
    acaps_vDriverVersion    dw    ?      ; version of the driver
    acaps_szPname           db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    acaps_wTechnology       dw    ?      ; type of device
    acaps_dwSupport         dd    ?      ; functionality supported by driver
AUXCAPS ends

; flags for wTechnology field in AUXCAPS structure
AUXCAPS_CDAUDIO    equ    1       ; audio from internal CD-ROM drive
AUXCAPS_AUXIN      equ    2       ; audio from auxiliary input jacks

; flags for dwSupport field in AUXCAPS structure
AUXCAPS_VOLUME          equ    0001h   ; supports volume control
AUXCAPS_LRVOLUME        equ    0002h   ; separate left-right volume control

endif  ;ifndef MMNOAUX


ifndef MMNOTIMER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Timer support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; timer error return values
TIMERR_NOERROR        equ    (0)                  ; no error
TIMERR_NOCANDO        equ    (TIMERR_BASE+1)      ; request not completed
TIMERR_STRUCT         equ    (TIMERR_BASE+33)     ; time struct size

; flags for wFlags parameter of timeSetEvent() function
TIME_ONESHOT    equ    0   ; program timer for single event
TIME_PERIODIC   equ    1   ; program for continuous periodic event

; timer device capabilities data structure
TIMECAPS struc
    tc_wPeriodMin    dw    ?     ; minimum period supported
    tc_wPeriodMax    dw    ?     ; maximum period supported
TIMECAPS ends

endif  ;ifndef MMNOTIMER


ifndef MMNOJOY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Joystick support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; joystick error return values
JOYERR_NOERROR        equ    (0)                  ; no error
JOYERR_PARMS          equ    (JOYERR_BASE+5)      ; bad parameters
JOYERR_NOCANDO        equ    (JOYERR_BASE+6)      ; request not completed
JOYERR_UNPLUGGED      equ    (JOYERR_BASE+7)      ; joystick is unplugged

; constants used with JOYINFO structure and MM_JOY* messages
JOY_BUTTON1         equ    0001h
JOY_BUTTON2         equ    0002h
JOY_BUTTON3         equ    0004h
JOY_BUTTON4         equ    0008h
JOY_BUTTON1CHG      equ    0100h
JOY_BUTTON2CHG      equ    0200h
JOY_BUTTON3CHG      equ    0400h
JOY_BUTTON4CHG      equ    0800h

; joystick ID constants
JOYSTICKID1         equ    0
JOYSTICKID2         equ    1

; joystick device capabilities data structure
JOYCAPS struc
    jcaps_wMid         dw    ?    ; manufacturer ID
    jcaps_wPid         dw    ?    ; product ID
    jcaps_szPname      db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    jcaps_wXmin        dw    ?    ; minimum x position value
    jcaps_wXmax        dw    ?    ; maximum x position value
    jcaps_wYmin        dw    ?    ; minimum y position value
    jcaps_wYmax        dw    ?    ; maximum y position value
    jcaps_wZmin        dw    ?    ; minimum z position value
    jcaps_wZmax        dw    ?    ; maximum z position value
    jcaps_wNumButtons  dw    ?    ; number of buttons
    jcaps_wPeriodMin   dw    ?    ; minimum message period when captured
    jcaps_wPeriodMax   dw    ?    ; maximum message period when captured
JOYCAPS ends

; joystick information data structure
JOYINFO struc
    jinfo_wXpos        dw    ?  ; x position
    jinfo_wYpos        dw    ?  ; y position
    jinfo_wZpos        dw    ?  ; z position
    jinfo_wButtons     dw    ?  ; button states
JOYINFO ends

endif  ;ifndef MMNOJOY

ifndef MMNOMMIO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Multimedia File I/O support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MMIO error return values
MMIOERR_BASE            equ    256
MMIOERR_FILENOTFOUND    equ    (MMIOERR_BASE + 1)  ; file not found
MMIOERR_OUTOFMEMORY     equ    (MMIOERR_BASE + 2)  ; out of memory
MMIOERR_CANNOTOPEN      equ    (MMIOERR_BASE + 3)  ; cannot open
MMIOERR_CANNOTCLOSE     equ    (MMIOERR_BASE + 4)  ; cannot close
MMIOERR_CANNOTREAD      equ    (MMIOERR_BASE + 5)  ; cannot read
MMIOERR_CANNOTWRITE     equ    (MMIOERR_BASE + 6)  ; cannot write
MMIOERR_CANNOTSEEK      equ    (MMIOERR_BASE + 7)  ; cannot seek
MMIOERR_CANNOTEXPAND    equ    (MMIOERR_BASE + 8)  ; cannot expand file
MMIOERR_CHUNKNOTFOUND   equ    (MMIOERR_BASE + 9)  ; chunk not found
MMIOERR_UNBUFFERED      equ    (MMIOERR_BASE + 10) ; file is unbuffered

; MMIO constants
CFSEPCHAR    equ   '+'             ; compound file name separator char.

; general MMIO information data structure
MMIOINFO struc
        ; general fields
    mmio_dwFlags        dd    ?      ; general status flags
    mmio_fccIOProc      dd    ?      ; pointer to I/O procedure
    mmio_pIOProc        dd    ?      ; pointer to I/O procedure
    mmio_wErrorRet      dw    ?      ; place for error to be returned
    mmio_htask          dw    ?      ; alternate local task

        ; fields maintained by MMIO functions during buffered I/O
    mmio_cchBuffer      dd    ?      ; size of I/O buffer (or 0L)
    mmio_pchBuffer      dd    ?      ; start of I/O buffer (or NULL)
    mmio_pchNext        dd    ?      ; pointer to next byte to read/write
    mmio_pchEndRead     dd    ?      ; pointer to last valid byte to read
    mmio_pchEndWrite    dd    ?      ; pointer to last byte to write
    mmio_lBufOffset     dd    ?      ; disk offset of start of buffer

        ; fields maintained by I/O procedure
    mmio_lDiskOffset    dd    ?      ; disk offset of next read or write
    mmio_adwInfo        dd 3 dup (?) ; data specific to type of MMIOPROC

        ; other fields maintained by MMIO
    mmio_dwReserved1    dd    ?      ; reserved for MMIO use
    mmio_dwReserved2    dd    ?      ; reserved for MMIO use
    mmio_hmmio          dw    ?      ; handle to open file
MMIOINFO ends

; RIFF chunk information data structure
MMCKINFO struc
    mmck_ckid          dd    ?  ; chunk ID
    mmck_cksize        dd    ?  ; chunk size
    mmck_fccType       dd    ?  ; form type or list type
    mmck_dwDataOffset  dd    ?  ; offset of data portion of chunk
    mmck_dwFlags       dd    ?  ; flags used by MMIO functions
MMCKINFO ends

; bit field masks
MMIO_RWMODE     equ    00000003h       ; open file for reading/writing/both
MMIO_SHAREMODE  equ    00000070h       ; file sharing mode number

; constants for dwFlags field of MMIOINFO
MMIO_CREATE     equ    00001000h       ; create new file (or truncate file)
MMIO_PARSE      equ    00000100h       ; parse new file returning path
MMIO_DELETE     equ    00000200h       ; create new file (or truncate file)
MMIO_EXIST      equ    00004000h       ; checks for existence of file
MMIO_ALLOCBUF   equ    00010000h       ; mmioOpen() should allocate a buffer
MMIO_GETTEMP    equ    00020000h       ; mmioOpen() should retrieve temp name

MMIO_DIRTY      equ    10000000h       ; I/O buffer is dirty


; read/write mode numbers (bit field MMIO_RWMODE)
MMIO_READ       equ    00000000h       ; open file for reading only
MMIO_WRITE      equ    00000001h       ; open file for writing only
MMIO_READWRITE  equ    00000002h       ; open file for reading and writing

; share mode numbers (bit field MMIO_SHAREMODE)
MMIO_COMPAT     equ    00000000h       ; compatibility mode
MMIO_EXCLUSIVE  equ    00000010h       ; exclusive-access mode
MMIO_DENYWRITE  equ    00000020h       ; deny writing to other processes
MMIO_DENYREAD   equ    00000030h       ; deny reading to other processes
MMIO_DENYNONE   equ    00000040h       ; deny nothing to other processes

; various MMIO flags
MMIO_FHOPEN             equ    0010h   ; mmioClose: keep file handle open
MMIO_EMPTYBUF           equ    0010h   ; mmioFlush: empty the I/O buffer
MMIO_TOUPPER            equ    0010h   ; mmioStringToFOURCC: to u-case
MMIO_INSTALLPROC    equ    00010000h   ; mmioInstallIOProc: install MMIOProc
MMIO_GLOBALPROC     equ    10000000h   ; mmioInstallIOProc: install globally
MMIO_REMOVEPROC     equ    00020000h   ; mmioInstallIOProc: remove MMIOProc
MMIO_FINDPROC       equ    00040000h   ; mmioInstallIOProc: find an MMIOProc
MMIO_FINDCHUNK          equ    0010h   ; mmioDescend: find a chunk by ID
MMIO_FINDRIFF           equ    0020h   ; mmioDescend: find a LIST chunk
MMIO_FINDLIST           equ    0040h   ; mmioDescend: find a RIFF chunk
MMIO_CREATERIFF         equ    0020h   ; mmioCreateChunk: make a LIST chunk
MMIO_CREATELIST         equ    0040h   ; mmioCreateChunk: make a RIFF chunk


; message numbers for MMIOPROC I/O procedure functions
MMIOM_READ      equ    MMIO_READ       ; read
MMIOM_WRITE    equ    MMIO_WRITE       ; write
MMIOM_SEEK              equ    2       ; seek to a new position in file
MMIOM_OPEN              equ    3       ; open file
MMIOM_CLOSE             equ    4       ; close file
MMIOM_WRITEFLUSH        equ    5       ; write and flush
MMIOM_RENAME            equ    6       ; rename specified file
MMIOM_USER         equ    8000h        ; beginning of user-defined messages

mmioFOURCC MACRO ch0,ch1,ch2,ch3
        mov     al,ch0
        mov     ah,ch1
        mov     dl,ch2
        mov     dh,ch3
        ENDM

; standard four character codes
; FOURCC_RIFF     equ    mmioFOURCC('R', 'I', 'F', 'F')
; FOURCC_LIST     equ    mmioFOURCC('L', 'I', 'S', 'T')

; four character codes used to identify standard built-in I/O procedures
; FOURCC_DOS      equ    mmioFOURCC('D', 'O', 'S', ' ')
; FOURCC_MEM      equ    mmioFOURCC('M', 'E', 'M', ' ')

; flags for mmioSeek()
ifndef SEEK_SET
SEEK_SET        equ    0               ; seek to an absolute position
SEEK_CUR        equ    1               ; seek relative to current position
SEEK_END        equ    2               ; seek relative to end of file
endif  ;ifndef SEEK_SET

; other constants
MMIO_DEFAULTBUFFER      equ    8192    ; default buffer size

endif   ;ifndef MMNOMMIO

ifndef MMNOMCI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MCI support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MCI error return values
MCIERR_INVALID_DEVICE_ID        equ    (MCIERR_BASE + 1)
MCIERR_UNRECOGNIZED_KEYWORD     equ    (MCIERR_BASE + 3)
MCIERR_UNRECOGNIZED_COMMAND     equ    (MCIERR_BASE + 5)
MCIERR_HARDWARE                 equ    (MCIERR_BASE + 6)
MCIERR_INVALID_DEVICE_NAME      equ    (MCIERR_BASE + 7)
MCIERR_OUT_OF_MEMORY            equ    (MCIERR_BASE + 8)
MCIERR_DEVICE_OPEN              equ    (MCIERR_BASE + 9)
MCIERR_CANNOT_LOAD_DRIVER       equ    (MCIERR_BASE + 10)
MCIERR_MISSING_COMMAND_STRING   equ    (MCIERR_BASE + 11)
MCIERR_PARAM_OVERFLOW           equ    (MCIERR_BASE + 12)
MCIERR_MISSING_STRING_ARGUMENT  equ    (MCIERR_BASE + 13)
MCIERR_BAD_INTEGER              equ    (MCIERR_BASE + 14)
MCIERR_PARSER_INTERNAL          equ    (MCIERR_BASE + 15)
MCIERR_DRIVER_INTERNAL          equ    (MCIERR_BASE + 16)
MCIERR_MISSING_PARAMETER        equ    (MCIERR_BASE + 17)
MCIERR_UNSUPPORTED_FUNCTION     equ    (MCIERR_BASE + 18)
MCIERR_FILE_NOT_FOUND           equ    (MCIERR_BASE + 19)
MCIERR_DEVICE_NOT_READY         equ    (MCIERR_BASE + 20)
MCIERR_INTERNAL                 equ    (MCIERR_BASE + 21)
MCIERR_DRIVER                   equ    (MCIERR_BASE + 22)
MCIERR_CANNOT_USE_ALL           equ    (MCIERR_BASE + 23)
MCIERR_MULTIPLE                 equ    (MCIERR_BASE + 24)
MCIERR_EXTENSION_NOT_FOUND      equ    (MCIERR_BASE + 25)
MCIERR_OUTOFRANGE               equ    (MCIERR_BASE + 26)
MCIERR_FLAGS_NOT_COMPATIBLE     equ    (MCIERR_BASE + 28)
MCIERR_FILE_NOT_SAVED           equ    (MCIERR_BASE + 30)
MCIERR_DEVICE_TYPE_REQUIRED     equ    (MCIERR_BASE + 31)
MCIERR_DEVICE_LOCKED            equ    (MCIERR_BASE + 32)
MCIERR_DUPLICATE_ALIAS          equ    (MCIERR_BASE + 33)
MCIERR_BAD_CONSTANT             equ    (MCIERR_BASE + 34)
MCIERR_MUST_USE_SHAREABLE       equ    (MCIERR_BASE + 35)
MCIERR_MISSING_DEVICE_NAME      equ    (MCIERR_BASE + 36)
MCIERR_BAD_TIME_FORMAT          equ    (MCIERR_BASE + 37)
MCIERR_NO_CLOSING_QUOTE         equ    (MCIERR_BASE + 38)
MCIERR_DUPLICATE_FLAGS          equ    (MCIERR_BASE + 39)
MCIERR_INVALID_FILE             equ    (MCIERR_BASE + 40)
MCIERR_NULL_PARAMETER_BLOCK     equ    (MCIERR_BASE + 41)
MCIERR_UNNAMED_RESOURCE         equ    (MCIERR_BASE + 42)
MCIERR_NEW_REQUIRES_ALIAS       equ    (MCIERR_BASE + 43)
MCIERR_NOTIFY_ON_AUTO_OPEN      equ    (MCIERR_BASE + 44)
MCIERR_NO_ELEMENT_ALLOWED       equ    (MCIERR_BASE + 45)
MCIERR_NONAPPLICABLE_FUNCTION   equ    (MCIERR_BASE + 46)
MCIERR_ILLEGAL_FOR_AUTO_OPEN    equ    (MCIERR_BASE + 47)
MCIERR_FILENAME_REQUIRED        equ    (MCIERR_BASE + 48)
MCIERR_EXTRA_CHARACTERS         equ    (MCIERR_BASE + 49)
MCIERR_DEVICE_NOT_INSTALLED     equ    (MCIERR_BASE + 50)
MCIERR_GET_CD                   equ    (MCIERR_BASE + 51)
MCIERR_SET_CD                   equ    (MCIERR_BASE + 52)
MCIERR_SET_DRIVE                equ    (MCIERR_BASE + 53)
MCIERR_DEVICE_LENGTH            equ    (MCIERR_BASE + 54)
MCIERR_DEVICE_ORD_LENGTH        equ    (MCIERR_BASE + 55)
MCIERR_NO_INTEGER               equ    (MCIERR_BASE + 56)

MCIERR_WAVE_OUTPUTSINUSE        equ    (MCIERR_BASE + 64)
MCIERR_WAVE_SETOUTPUTINUSE      equ    (MCIERR_BASE + 65)
MCIERR_WAVE_INPUTSINUSE         equ    (MCIERR_BASE + 66)
MCIERR_WAVE_SETINPUTINUSE       equ    (MCIERR_BASE + 67)
MCIERR_WAVE_OUTPUTUNSPECIFIED   equ    (MCIERR_BASE + 68)
MCIERR_WAVE_INPUTUNSPECIFIED    equ    (MCIERR_BASE + 69)
MCIERR_WAVE_OUTPUTSUNSUITABLE   equ    (MCIERR_BASE + 70)
MCIERR_WAVE_SETOUTPUTUNSUITABLE equ    (MCIERR_BASE + 71)
MCIERR_WAVE_INPUTSUNSUITABLE    equ    (MCIERR_BASE + 72)
MCIERR_WAVE_SETINPUTUNSUITABLE  equ    (MCIERR_BASE + 73)

MCIERR_SEQ_DIV_INCOMPATIBLE     equ    (MCIERR_BASE + 80)
MCIERR_SEQ_PORT_INUSE           equ    (MCIERR_BASE + 81)
MCIERR_SEQ_PORT_NONEXISTENT     equ    (MCIERR_BASE + 82)
MCIERR_SEQ_PORT_MAPNODEVICE     equ    (MCIERR_BASE + 83)
MCIERR_SEQ_PORT_MISCERROR       equ    (MCIERR_BASE + 84)
MCIERR_SEQ_TIMER                equ    (MCIERR_BASE + 85)
MCIERR_SEQ_PORTUNSPECIFIED      equ    (MCIERR_BASE + 86)
MCIERR_SEQ_NOMIDIPRESENT        equ    (MCIERR_BASE + 87)

MCIERR_NO_WINDOW                equ    (MCIERR_BASE + 90)
MCIERR_CREATEWINDOW             equ    (MCIERR_BASE + 91)
MCIERR_FILE_READ                equ    (MCIERR_BASE + 92)
MCIERR_FILE_WRITE               equ    (MCIERR_BASE + 93)

; all custom device driver errors must be >= than this value
MCIERR_CUSTOM_DRIVER_BASE       equ    (MCIERR_BASE + 256)

; MCI command message identifiers
MCI_OPEN                        equ    0803h
MCI_CLOSE                       equ    0804h
MCI_ESCAPE                      equ    0805h
MCI_PLAY                        equ    0806h
MCI_SEEK                        equ    0807h
MCI_STOP                        equ    0808h
MCI_PAUSE                       equ    0809h
MCI_INFO                        equ    080Ah
MCI_GETDEVCAPS                  equ    080Bh
MCI_SPIN                        equ    080Ch
MCI_SET                         equ    080Dh
MCI_STEP                        equ    080Eh
MCI_RECORD                      equ    080Fh
MCI_SYSINFO                     equ    0810h
MCI_BREAK                       equ    0811h
MCI_SOUND                       equ    0812h
MCI_SAVE                        equ    0813h
MCI_STATUS                      equ    0814h
MCI_CUE                         equ    0830h
MCI_REALIZE                     equ    0840h
MCI_WINDOW                      equ    0841h
MCI_PUT                         equ    0842h
MCI_WHERE                       equ    0843h
MCI_FREEZE                      equ    0844h
MCI_UNFREEZE                    equ    0845h
MCI_LOAD                        equ    0850h
MCI_CUT                         equ    0851h
MCI_COPY                        equ    0852h
MCI_PASTE                       equ    0853h
MCI_UPDATE                      equ    0854h
MCI_RESUME                      equ    0855h
MCI_DELETE                      equ    0856h

; all custom MCI command messages must be >= than this value
MCI_USER_MESSAGES               equ    (400h + DRV_MCI_FIRST)


; device ID for "all devices"
MCI_ALL_DEVICE_ID               equ    0FFFFh

; constants for predefined MCI device types
MCI_DEVTYPE_VCR                 equ    (MCI_STRING_OFFSET + 1)
MCI_DEVTYPE_VIDEODISC           equ    (MCI_STRING_OFFSET + 2)
MCI_DEVTYPE_OVERLAY             equ    (MCI_STRING_OFFSET + 3)
MCI_DEVTYPE_CD_AUDIO            equ    (MCI_STRING_OFFSET + 4)
MCI_DEVTYPE_DAT                 equ    (MCI_STRING_OFFSET + 5)
MCI_DEVTYPE_SCANNER             equ    (MCI_STRING_OFFSET + 6)
MCI_DEVTYPE_ANIMATION           equ    (MCI_STRING_OFFSET + 7)
MCI_DEVTYPE_DIGITAL_VIDEO       equ    (MCI_STRING_OFFSET + 8)
MCI_DEVTYPE_OTHER               equ    (MCI_STRING_OFFSET + 9)
MCI_DEVTYPE_WAVEFORM_AUDIO      equ    (MCI_STRING_OFFSET + 10)
MCI_DEVTYPE_SEQUENCER           equ    (MCI_STRING_OFFSET + 11)

MCI_DEVTYPE_FIRST               equ    MCI_DEVTYPE_VCR
MCI_DEVTYPE_LAST                equ    MCI_DEVTYPE_SEQUENCER

; return values for 'status mode' command
MCI_MODE_NOT_READY              equ    (MCI_STRING_OFFSET + 12)
MCI_MODE_STOP                   equ    (MCI_STRING_OFFSET + 13)
MCI_MODE_PLAY                   equ    (MCI_STRING_OFFSET + 14)
MCI_MODE_RECORD                 equ    (MCI_STRING_OFFSET + 15)
MCI_MODE_SEEK                   equ    (MCI_STRING_OFFSET + 16)
MCI_MODE_PAUSE                  equ    (MCI_STRING_OFFSET + 17)
MCI_MODE_OPEN                   equ    (MCI_STRING_OFFSET + 18)

; constants used in 'set time format' and 'status time format' commands
MCI_FORMAT_MILLISECONDS         equ    0
MCI_FORMAT_HMS                  equ    1
MCI_FORMAT_MSF                  equ    2
MCI_FORMAT_FRAMES               equ    3
MCI_FORMAT_SMPTE_24             equ    4
MCI_FORMAT_SMPTE_25             equ    5
MCI_FORMAT_SMPTE_30             equ    6
MCI_FORMAT_SMPTE_30DROP         equ    7
MCI_FORMAT_BYTES                equ    8
MCI_FORMAT_SAMPLES              equ    9
MCI_FORMAT_TMSF                 equ    10

; flags for wParam of MM_MCINOTIFY message
MCI_NOTIFY_SUCCESSFUL           equ    0001h
MCI_NOTIFY_SUPERSEDED           equ    0002h
MCI_NOTIFY_ABORTED              equ    0004h
MCI_NOTIFY_FAILURE              equ    0008h


; common flags for dwFlags parameter of MCI command messages
MCI_NOTIFY                      equ    00000001h
MCI_WAIT                        equ    00000002h
MCI_FROM                        equ    00000004h
MCI_TO                          equ    00000008h
MCI_TRACK                       equ    00000010h

; flags for dwFlags parameter of MCI_OPEN command message
MCI_OPEN_SHAREABLE              equ    00000100h
MCI_OPEN_ELEMENT                equ    00000200h
MCI_OPEN_ALIAS                  equ    00000400h
MCI_OPEN_ELEMENT_ID             equ    00000800h
MCI_OPEN_TYPE_ID                equ    00001000h
MCI_OPEN_TYPE                   equ    00002000h

; flags for dwFlags parameter of MCI_SEEK command message
MCI_SEEK_TO_START               equ    00000100h
MCI_SEEK_TO_END                 equ    00000200h

; flags for dwFlags parameter of MCI_STATUS command message
MCI_STATUS_ITEM                 equ    00000100h
MCI_STATUS_START                equ    00000200h

; flags for dwItem field of the MCI_STATUS_PARMS parameter block
MCI_STATUS_LENGTH               equ    00000001h
MCI_STATUS_POSITION             equ    00000002h
MCI_STATUS_NUMBER_OF_TRACKS     equ    00000003h
MCI_STATUS_MODE                 equ    00000004h
MCI_STATUS_MEDIA_PRESENT        equ    00000005h
MCI_STATUS_TIME_FORMAT          equ    00000006h
MCI_STATUS_READY                equ    00000007h
MCI_STATUS_CURRENT_TRACK        equ    00000008h

; flags for dwFlags parameter of MCI_INFO command message
MCI_INFO_PRODUCT                equ    00000100h
MCI_INFO_FILE                   equ    00000200h

; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_ITEM             equ    00000100h

; flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block
MCI_GETDEVCAPS_CAN_RECORD       equ    00000001h
MCI_GETDEVCAPS_HAS_AUDIO        equ    00000002h
MCI_GETDEVCAPS_HAS_VIDEO        equ    00000003h
MCI_GETDEVCAPS_DEVICE_TYPE      equ    00000004h
MCI_GETDEVCAPS_USES_FILES       equ    00000005h
MCI_GETDEVCAPS_COMPOUND_DEVICE  equ    00000006h
MCI_GETDEVCAPS_CAN_EJECT        equ    00000007h
MCI_GETDEVCAPS_CAN_PLAY         equ    00000008h
MCI_GETDEVCAPS_CAN_SAVE         equ    00000009h

; flags for dwFlags parameter of MCI_SYSINFO command message
MCI_SYSINFO_QUANTITY            equ    00000100h
MCI_SYSINFO_OPEN                equ    00000200h
MCI_SYSINFO_NAME                equ    00000400h
MCI_SYSINFO_INSTALLNAME         equ    00000800h

; flags for dwFlags parameter of MCI_SET command message
MCI_SET_DOOR_OPEN               equ    00000100h
MCI_SET_DOOR_CLOSED             equ    00000200h
MCI_SET_TIME_FORMAT             equ    00000400h
MCI_SET_AUDIO                   equ    00000800h
MCI_SET_VIDEO                   equ    00001000h
MCI_SET_ON                      equ    00002000h
MCI_SET_OFF                     equ    00004000h

; flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS
MCI_SET_AUDIO_ALL               equ    00000000h
MCI_SET_AUDIO_LEFT              equ    00000001h
MCI_SET_AUDIO_RIGHT             equ    00000002h

; flags for dwFlags parameter of MCI_BREAK command message
MCI_BREAK_KEY                   equ    00000100h
MCI_BREAK_HWND                  equ    00000200h
MCI_BREAK_OFF                   equ    00000400h

; flags for dwFlags parameter of MCI_RECORD command message
MCI_RECORD_INSERT               equ    00000100h
MCI_RECORD_OVERWRITE            equ    00000200h

; flags for dwFlags parameter of MCI_SOUND command message
MCI_SOUND_NAME                  equ    00000100h

; flags for dwFlags parameter of MCI_SAVE command message
MCI_SAVE_FILE                   equ    00000100h

; flags for dwFlags parameter of MCI_LOAD command message
MCI_LOAD_FILE                   equ    00000100h

; generic parameter block for MCI command messages with no special parameters
MCI_GENERIC_PARMS struc
    mcigen_dwCallback         dd    ?
MCI_GENERIC_PARMS ends

; parameter block for MCI_OPEN command message
MCI_OPEN_PARMS struc
    mciopen_dwCallback        dd    ?
    mciopen_wDeviceID         dw    ?
    mciopen_wReserved0        dw    ?
    mciopen_lpstrDeviceType   dd    ?
    mciopen_lpstrElementName  dd    ?
    mciopen_lpstrAlias        dd    ?
MCI_OPEN_PARMS ends

; parameter block for MCI_PLAY command message
MCI_PLAY_PARMS struc
    mciplay_dwCallback        dd    ?
    mciplay_dwFrom            dd    ?
    mciplay_dwTo              dd    ?
MCI_PLAY_PARMS ends

; parameter block for MCI_SEEK command message
MCI_SEEK_PARMS struc
    mciseek_dwCallback        dd    ?
    mciseek_dwTo              dd    ?
MCI_SEEK_PARMS ends

; parameter block for MCI_STATUS command message
MCI_STATUS_PARMS struc
    mcistat_dwCallback        dd    ?
    mcistat_dwReturn          dd    ?
    mcistat_dwItem            dd    ?
    mcistat_dwTrack           dd    ?
MCI_STATUS_PARMS ends

; parameter block for MCI_INFO command message
MCI_INFO_PARMS struc
    mciinfo_dwCallback        dd    ?
    mciinfo_lpstrReturn       dd    ?
    mciinfo_dwRetSize         dd    ?
MCI_INFO_PARMS ends

; parameter block for MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_PARMS struc
    mcigdc_dwCallback         dd    ?
    mcigdc_dwReturn           dd    ?
    mcigdc_dwItem             dd    ?
MCI_GETDEVCAPS_PARMS ends

; parameter block for MCI_SYSINFO command message
MCI_SYSINFO_PARMS struc
    mcisi_dwCallback          dd    ?
    mcisi_lpstrReturn         dd    ?
    mcisi_dwRetSize           dd    ?
    mcisi_dwNumber            dd    ?
    mcisi_wDeviceType         dw    ?
    mcisi_wReserved0          dw    ?
MCI_SYSINFO_PARMS ends

; parameter block for MCI_SET command message
MCI_SET_PARMS struc
    mciset_dwCallback         dd    ?
    mciset_dwTimeFormat       dd    ?
    mciset_dwAudio            dd    ?
MCI_SET_PARMS ends

; parameter block for MCI_BREAK command message
MCI_BREAK_PARMS struc
    mcibreak_dwCallback       dd    ?
    mcibreak_nVirtKey         dw    ?
    mcibreak_wReserved0       dw    ?
    mcibreak_hwndBreak        dw    ?
    mcibreak_wReserved1       dw    ?
MCI_BREAK_PARMS ends

; parameter block for MCI_SOUND command message
MCI_SOUND_PARMS struc
    mcisnd_dwCallback         dd    ?
    mcisnd_lpstrSoundName     dd    ?
MCI_SOUND_PARMS ends

; parameter block for MCI_SAVE command message
MCI_SAVE_PARMS struc
    mcisave_dwCallback        dd    ?
    mcisave_lpfilename        dd    ?
MCI_SAVE_PARMS ends

; parameter block for MCI_LOAD command message
MCI_LOAD_PARMS struc
    mciload_dwCallback        dd    ?
    mciload_lpfilename        dd    ?
MCI_LOAD_PARMS ends

; parameter block for MCI_RECORD command message
MCI_RECORD_PARMS struc
    mcirec_dwCallback         dd    ?
    mcirec_dwFrom             dd    ?
    mcirec_dwTo               dd    ?
MCI_RECORD_PARMS ends


;
; MCI extensions for videodisc devices
;

; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_STATUS_MODE)
MCI_VD_MODE_PARK                equ    (MCI_VD_OFFSET + 1)

; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE)
MCI_VD_MEDIA_CLV                equ    (MCI_VD_OFFSET + 2)
MCI_VD_MEDIA_CAV                equ    (MCI_VD_OFFSET + 3)
MCI_VD_MEDIA_OTHER              equ    (MCI_VD_OFFSET + 4)

MCI_VD_FORMAT_TRACK             equ    4001h

; flags for dwFlags parameter of MCI_PLAY command message
MCI_VD_PLAY_REVERSE             equ    00010000h
MCI_VD_PLAY_FAST                equ    00020000h
MCI_VD_PLAY_SPEED               equ    00040000h
MCI_VD_PLAY_SCAN                equ    00080000h
MCI_VD_PLAY_SLOW                equ    00100000h

; flag for dwFlags parameter of MCI_SEEK command message
MCI_VD_SEEK_REVERSE             equ    00010000h

; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_VD_STATUS_SPEED             equ    00004002h
MCI_VD_STATUS_FORWARD           equ    00004003h
MCI_VD_STATUS_MEDIA_TYPE        equ    00004004h
MCI_VD_STATUS_SIDE              equ    00004005h
MCI_VD_STATUS_DISC_SIZE         equ    00004006h

; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_VD_GETDEVCAPS_CLV           equ    00010000h
MCI_VD_GETDEVCAPS_CAV           equ    00020000h

MCI_VD_SPIN_UP                  equ    0001h
MCI_VD_SPIN_DOWN                equ    0002h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_VD_GETDEVCAPS_CAN_REVERSE   equ    00004002h
MCI_VD_GETDEVCAPS_FAST_RATE     equ    00004003h
MCI_VD_GETDEVCAPS_SLOW_RATE     equ    00004004h
MCI_VD_GETDEVCAPS_NORMAL_RATE   equ    00004005h

; flags for the dwFlags parameter of MCI_STEP command message
MCI_VD_STEP_FRAMES              equ    00010000h
MCI_VD_STEP_REVERSE             equ    00020000h

; flag for the MCI_ESCAPE command message
MCI_VD_ESCAPE_STRING            equ    00000100h

; parameter block for MCI_PLAY command message
MCI_VD_PLAY_PARMS struc
    mcivdplay_dwCallback      dd    ?
    mcivdplay_dwFrom          dd    ?
    mcivdplay_dwTo            dd    ?
    mcivdplay_dwSpeed         dd    ?
MCI_VD_PLAY_PARMS ends

; parameter block for MCI_STEP command message
MCI_VD_STEP_PARMS struc
    mcivdstep_dwCallback      dd    ?
    mcivdstep_dwFrames        dd    ?
MCI_VD_STEP_PARMS ends

; parameter block for MCI_ESCAPE command message
MCI_VD_ESCAPE_PARMS struc
    mcivcesc_dwCallback       dd    ?
    mcivcesc_lpstrCommand     dd    ?
MCI_VD_ESCAPE_PARMS ends


;
; MCI extensions for waveform audio devices
;

; flags for the dwFlags parameter of MCI_OPEN command message
MCI_WAVE_OPEN_BUFFER            equ    00010000h

; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_FORMATTAG          equ    00010000h
MCI_WAVE_SET_CHANNELS           equ    00020000h
MCI_WAVE_SET_SAMPLESPERSEC      equ    00040000h
MCI_WAVE_SET_AVGBYTESPERSEC     equ    00080000h
MCI_WAVE_SET_BLOCKALIGN         equ    00100000h
MCI_WAVE_SET_BITSPERSAMPLE      equ    00200000h

; flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages
MCI_WAVE_INPUT                  equ    00400000h
MCI_WAVE_OUTPUT                 equ    00800000h

; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_WAVE_STATUS_FORMATTAG       equ    00004001h
MCI_WAVE_STATUS_CHANNELS        equ    00004002h
MCI_WAVE_STATUS_SAMPLESPERSEC   equ    00004003h
MCI_WAVE_STATUS_AVGBYTESPERSEC  equ    00004004h
MCI_WAVE_STATUS_BLOCKALIGN      equ    00004005h
MCI_WAVE_STATUS_BITSPERSAMPLE   equ    00004006h
MCI_WAVE_STATUS_LEVEL           equ    00004007h

; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_ANYINPUT           equ    04000000h
MCI_WAVE_SET_ANYOUTPUT          equ    08000000h

; flags for the dwFlags parameter of MCI_GETDEVCAPS command message
MCI_WAVE_GETDEVCAPS_INPUTS      equ    00004001h
MCI_WAVE_GETDEVCAPS_OUTPUTS     equ    00004002h

; parameter block for MCI_OPEN command message
MCI_WAVE_OPEN_PARMS struc
    mciwopen_dwCallback       dd    ?
    mciwopen_wDeviceID        dw    ?
    mciwopen_wReserved0       dw    ?
    mciwopen_lpstrDeviceType  dd    ?
    mciwopen_lpstrElementName dd    ?
    mciwopen_lpstrAlias       dd    ?
    mciwopen_dwBufferSeconds  dd    ?
MCI_WAVE_OPEN_PARMS ends

; parameter block for MCI_DELETE command message
MCI_WAVE_DELETE_PARMS struc
    mciwdel_dwCallback        dd    ?
    mciwdel_dwFrom            dd    ?
    mciwdel_dwTo              dd    ?
MCI_WAVE_DELETE_PARMS ends

; parameter block for MCI_SET command message
MCI_WAVE_SET_PARMS struc
    mciwset_dwCallback        dd    ?
    mciwset_dwTimeFormat      dd    ?
    mciwset_dwAudio           dd    ?
    mciwset_wInput            dw    ?
    mciwset_wReserved0        dw    ?
    mciwset_wOutput           dw    ?
    mciwset_wReserved1        dw    ?
    mciwset_wFormatTag        dw    ?
    mciwset_wReserved2        dw    ?
    mciwset_nChannels         dw    ?
    mciwset_wReserved3        dw    ?
    mciwset_nSamplesPerSec    dw    ?
    mciwset_nAvgBytesPerSec   dw    ?
    mciwset_nBlockAlign       dw    ?
    mciwset_wReserved4        dw    ?
    mciwset_wBitsPerSample    dw    ?
    mciwset_wReserved5        dw    ?
MCI_WAVE_SET_PARMS ends


;
; MCI extensions for MIDI sequencer devices
;

; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE)
MCI_SEQ_DIV_PPQN            equ    (0 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_24        equ    (1 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_25        equ    (2 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30DROP    equ    (3 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30        equ    (4 + MCI_SEQ_OFFSET)

; flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block
; MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER)
MCI_SEQ_FORMAT_SONGPTR      equ    4001h
MCI_SEQ_FILE                equ    4002h
MCI_SEQ_MIDI                equ    4003h
MCI_SEQ_SMPTE               equ    4004h
MCI_SEQ_NONE                equ    65533

; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_SEQ_STATUS_TEMPO            equ    00004002h
MCI_SEQ_STATUS_PORT             equ    00004003h
MCI_SEQ_STATUS_SLAVE            equ    00004007h
MCI_SEQ_STATUS_MASTER           equ    00004008h
MCI_SEQ_STATUS_OFFSET           equ    00004009h
MCI_SEQ_STATUS_DIVTYPE          equ    0000400Ah

; flags for the dwFlags parameter of MCI_SET command message
MCI_SEQ_SET_TEMPO               equ    00010000h
MCI_SEQ_SET_PORT                equ    00020000h
MCI_SEQ_SET_SLAVE               equ    00040000h
MCI_SEQ_SET_MASTER              equ    00080000h
MCI_SEQ_SET_OFFSET              equ    01000000h

; parameter block for MCI_SET command message
MCI_SEQ_SET_PARMS struc
    mcisset_dwCallback        dd    ?
    mcisset_dwTimeFormat      dd    ?
    mcisset_dwAudio           dd    ?
    mcisset_dwTempo           dd    ?
    mcisset_dwPort            dd    ?
    mcisset_dwSlave           dd    ?
    mcisset_dwMaster          dd    ?
    mcisset_dwOffset          dd    ?
MCI_SEQ_SET_PARMS ends


;
; MCI extensions for animation devices
;

; flags for dwFlags parameter of MCI_OPEN command message
MCI_ANIM_OPEN_WS                equ    00010000h
MCI_ANIM_OPEN_PARENT            equ    00020000h
MCI_ANIM_OPEN_NOSTATIC          equ    00040000h

; flags for dwFlags parameter of MCI_PLAY command message
MCI_ANIM_PLAY_SPEED             equ    00010000h
MCI_ANIM_PLAY_REVERSE           equ    00020000h
MCI_ANIM_PLAY_FAST              equ    00040000h
MCI_ANIM_PLAY_SLOW              equ    00080000h
MCI_ANIM_PLAY_SCAN              equ    00100000h

; flags for dwFlags parameter of MCI_STEP command message
MCI_ANIM_STEP_REVERSE           equ    00010000h
MCI_ANIM_STEP_FRAMES            equ    00020000h

; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_ANIM_STATUS_SPEED           equ    00004001h
MCI_ANIM_STATUS_FORWARD         equ    00004002h
MCI_ANIM_STATUS_HWND            equ    00004003h
MCI_ANIM_STATUS_HPAL            equ    00004004h
MCI_ANIM_STATUS_STRETCH         equ    00004005h

; flags for the dwFlags parameter of MCI_INFO command message
MCI_ANIM_INFO_TEXT              equ    00010000h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_ANIM_GETDEVCAPS_CAN_REVERSE equ    00004001h
MCI_ANIM_GETDEVCAPS_FAST_RATE   equ    00004002h
MCI_ANIM_GETDEVCAPS_SLOW_RATE   equ    00004003h
MCI_ANIM_GETDEVCAPS_NORMAL_RATE equ    00004004h
MCI_ANIM_GETDEVCAPS_PALETTES    equ    00004006h
MCI_ANIM_GETDEVCAPS_CAN_STRETCH equ    00004007h
MCI_ANIM_GETDEVCAPS_MAX_WINDOWS equ    00004008h

; flags for the MCI_REALIZE command message
MCI_ANIM_REALIZE_NORM           equ    00010000h
MCI_ANIM_REALIZE_BKGD           equ    00020000h

; flags for dwFlags parameter of MCI_WINDOW command message
MCI_ANIM_WINDOW_HWND            equ    00010000h
MCI_ANIM_WINDOW_STATE           equ    00040000h
MCI_ANIM_WINDOW_TEXT            equ    00080000h
MCI_ANIM_WINDOW_ENABLE_STRETCH  equ    00100000h
MCI_ANIM_WINDOW_DISABLE_STRETCH equ    00200000h

; flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block
; MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND)
MCI_ANIM_WINDOW_DEFAULT         equ    00000000h

; flags for dwFlags parameter of MCI_PUT command message
MCI_ANIM_RECT                   equ    00010000h
MCI_ANIM_PUT_SOURCE             equ    00020000h
MCI_ANIM_PUT_DESTINATION        equ    00040000h

; flags for dwFlags parameter of MCI_WHERE command message
MCI_ANIM_WHERE_SOURCE           equ    00020000h
MCI_ANIM_WHERE_DESTINATION      equ    00040000h

; flags for dwFlags parameter of MCI_UPDATE command message
MCI_ANIM_UPDATE_HDC             equ    00020000h

; parameter block for MCI_OPEN command message
MCI_ANIM_OPEN_PARMS struc
    mciaopen_dwCallback       dd    ?
    mciaopen_wDeviceID        dw    ?
    mciaopen_wReserved0       dw    ?
    mciaopen_lpstrDeviceType  dd    ?
    mciaopen_lpstrElementName dd    ?
    mciaopen_lpstrAlias       dd    ?
    mciaopen_dwStyle          dd    ?
    mciaopen_hWndParent       dw    ?
    mciaopen_wReserved1       dw    ?
MCI_ANIM_OPEN_PARMS ends

; parameter block for MCI_PLAY command message
MCI_ANIM_PLAY_PARMS struc
    mciaplay_dwCallback       dd    ?
    mciaplay_dwFrom           dd    ?
    mciaplay_dwTo             dd    ?
    mciaplay_dwSpeed          dd    ?
MCI_ANIM_PLAY_PARMS ends

; parameter block for MCI_STEP command message
MCI_ANIM_STEP_PARMS struc
    mciastep_dwCallback       dd    ?
    mciastep_dwFrames         dd    ?
MCI_ANIM_STEP_PARMS ends

; parameter block for MCI_WINDOW command message
MCI_ANIM_WINDOW_PARMS struc
    mciawin_dwCallback        dd    ?
    mciawin_hWnd              dw    ?
    mciawin_wReserved1        dw    ?
    mciawin_nCmdShow          dw    ?
    mciawin_wReserved2        dw    ?
    mciawin_lpstrText         dd    ?
MCI_ANIM_WINDOW_PARMS ends

; parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages
MCI_ANIM_RECT_PARMS struc
    mciarect_dwCallback       dd    ?
ifdef MCI_USE_OFFEXT
    mciarect_ptOffset         db (SIZE POINT) dup (?)
    mciarect_ptExtent         db (SIZE POINT) dup (?)
else    ;ifdef MCI_USE_OFFEXT
    mciarect_rc               db (SIZE RECT) dup (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_ANIM_RECT_PARMS ends

; parameter block for MCI_UPDATE PARMS
MCI_ANIM_UPDATE_PARMS struc
    mciaupd_dwCallback        dd    ?
    mciaupd_rc                db (SIZE RECT) dup (?)
    mciaupd_hDC               dw    ?
MCI_ANIM_UPDATE_PARMS ends


;
; MCI extensions for video overlay devices
;

; flags for dwFlags parameter of MCI_OPEN command message
MCI_OVLY_OPEN_WS                equ    00010000h
MCI_OVLY_OPEN_PARENT            equ    00020000h

; flags for dwFlags parameter of MCI_STATUS command message
MCI_OVLY_STATUS_HWND            equ    00004001h
MCI_OVLY_STATUS_STRETCH         equ    00004002h

; flags for dwFlags parameter of MCI_INFO command message
MCI_OVLY_INFO_TEXT              equ    00010000h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_OVLY_GETDEVCAPS_CAN_STRETCH equ    00004001h
MCI_OVLY_GETDEVCAPS_CAN_FREEZE  equ    00004002h
MCI_OVLY_GETDEVCAPS_MAX_WINDOWS equ    00004003h

; flags for dwFlags parameter of MCI_WINDOW command message
MCI_OVLY_WINDOW_HWND            equ    00010000h
MCI_OVLY_WINDOW_STATE           equ    00040000h
MCI_OVLY_WINDOW_TEXT            equ    00080000h
MCI_OVLY_WINDOW_ENABLE_STRETCH  equ    00100000h
MCI_OVLY_WINDOW_DISABLE_STRETCH equ    00200000h

; flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block
MCI_OVLY_WINDOW_DEFAULT         equ    00000000h

; flags for dwFlags parameter of MCI_PUT command message
MCI_OVLY_RECT                   equ    00010000h
MCI_OVLY_PUT_SOURCE             equ    00020000h
MCI_OVLY_PUT_DESTINATION        equ    00040000h
MCI_OVLY_PUT_FRAME              equ    00080000h
MCI_OVLY_PUT_VIDEO              equ    00100000h

; flags for dwFlags parameter of MCI_WHERE command message
MCI_OVLY_WHERE_SOURCE           equ    00020000h
MCI_OVLY_WHERE_DESTINATION      equ    00040000h
MCI_OVLY_WHERE_FRAME            equ    00080000h
MCI_OVLY_WHERE_VIDEO            equ    00100000h

; parameter block for MCI_OPEN command message
MCI_OVLY_OPEN_PARMS struc
    mcioopen_dwCallback       dd    ?
    mcioopen_wDeviceID        dw    ?
    mcioopen_wReserved0       dw    ?
    mcioopen_lpstrDeviceType  dd    ?
    mcioopen_lpstrElementName dd    ?
    mcioopen_lpstrAlias       dd    ?
    mcioopen_dwStyle          dd    ?
    mcioopen_hWndParent       dw    ?
    mcioopen_wReserved1       dw    ?
MCI_OVLY_OPEN_PARMS ends

; parameter block for MCI_WINDOW command message
MCI_OVLY_WINDOW_PARMS struc
    mciowin_dwCallback        dd    ?
    mciowin_hWnd              dw    ?
    mciowin_wReserved1        dw    ?
    mciowin_nCmdShow          dw    ?
    mciowin_wReserved2        dw    ?
    mciowin_lpstrText         dd    ?
MCI_OVLY_WINDOW_PARMS ends

; parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages
MCI_OVLY_RECT_PARMS struc
    mciorect_dwCallback       dd    ?
ifdef MCI_USE_OFFEXT
    mciorect_ptOffset         db (SIZE POINT) dup (?)
    mciorect_ptExtent         db (SIZE POINT) dup (?)
else    ;ifdef MCI_USE_OFFEXT
    mciorect_rc               db (SIZE RECT) dup (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_OVLY_RECT_PARMS ends

; parameter block for MCI_SAVE command message
MCI_OVLY_SAVE_PARMS struc
    mciosave_dwCallback       dd    ?
    mciosave_lpfilename       dd    ?
    mciosave_rc               db (SIZE RECT) dup (?)
MCI_OVLY_SAVE_PARMS ends

; parameter block for MCI_LOAD command message
MCI_OVLY_LOAD_PARMS struc
    mcioload_dwCallback       dd    ?
    mcioload_lpfilename       dd    ?
    mcioload_rc               db (SIZE RECT) dup (?)
MCI_OVLY_LOAD_PARMS ends

endif  ;ifndef MMNOMCI

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       DISPLAY Driver extensions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef C1_TRANSPARENT
    CAPS1           equ    94          ; other caps
    C1_TRANSPARENT  equ    0001h       ; new raster cap
    NEWTRANSPARENT  equ    3           ; use with SetBkMode()

    QUERYROPSUPPORT equ    40          ; use to determine ROP support
endif  ;ifndef C1_TRANSPARENT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       DIB Driver extensions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SELECTDIB       equ    41                      ; DIB.DRV select dib escape
DIBINDEX MACRO a
        mov     ax,a
        mov     dx,10ffh
        ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       ScreenSaver support
;
;   The current application will receive a syscommand of SC_SCREENSAVE just
;   before the screen saver is invoked.  If the app wishes to prevent a
;   screen save, return non-zero value, otherwise call DefWindowProc().
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SC_SCREENSAVE

    SC_SCREENSAVE   equ    0F140h

endif  ;ifndef SC_SCREENSAVE
/*****************************************************************************\
*                                                                             *
* colordlg.h -  Common dialog color dialog's control id numbers               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef __COLORDLG_H    /* prevent multiple includes */
#define __COLORDLG_H

#define DLG_COLOR          10

#define COLOR_HUESCROLL   700          /* color dialog */
#define COLOR_SATSCROLL   701
#define COLOR_LUMSCROLL   702
#define COLOR_HUE         703
#define COLOR_SAT         704
#define COLOR_LUM         705
#define COLOR_RED         706
#define COLOR_GREEN       707
#define COLOR_BLUE        708
#define COLOR_CURRENT     709
#define COLOR_RAINBOW     710
#define COLOR_SAVE        711
#define COLOR_ADD         712
#define COLOR_SOLID       713
#define COLOR_TUNE        714
#define COLOR_SCHEMES     715
#define COLOR_ELEMENT     716
#define COLOR_SAMPLES     717
#define COLOR_PALETTE     718
#define COLOR_MIX         719
#define COLOR_BOX1        720
#define COLOR_CUSTOM1     721

#define COLOR_HUEACCEL    723
#define COLOR_SATACCEL    724
#define COLOR_LUMACCEL    725
#define COLOR_REDACCEL    726
#define COLOR_GREENACCEL  727
#define COLOR_BLUEACCEL   728

#define NUM_BASIC_COLORS   48
#define NUM_CUSTOM_COLORS  16

#endif  /* __COLORDLG_H */
/*  _nfile.h

    Maximum number of open files

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef ___NFILE_H
#define ___NFILE_H

#define _NFILE_ 20

#endif
/*  fstream.h -- class filebuf and fstream declarations

    Copyright (c) 1990, 1992 by Borland International
    All rights reserved
*/

#ifndef __cplusplus
#error Must use C++ for the type fstream.
#endif

#ifndef __FSTREAM_H
#define __FSTREAM_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(__IOSTREAM_H)
#include <iostream.h>
#endif

#pragma option -Vo-
#if defined(__BCOPT__) && !defined(_RTL_ALLOW_po)
#pragma option -po-
#endif

_CLASSDEF(filebuf)
_CLASSDEF(fstreambase)
_CLASSDEF(ifstream)
_CLASSDEF(ofstream)
_CLASSDEF(fstream)

class  _CLASSTYPE filebuf : public streambuf {
public:
static const int openprot;  // default file protection

    // constructors, destructor
    _Cdecl filebuf();   // make a closed filebuf
    _Cdecl filebuf(int);    // make a filebuf attached to fd
    _Cdecl filebuf(int __f, signed char _FAR *, int); // same, with specified buffer
    _Cdecl filebuf(int __f, unsigned char _FAR *, int); // same, with specified buffer
    _Cdecl ~filebuf();

    int _Cdecl is_open();   // is the file open
    int _Cdecl fd();        // what is the file descriptor

    // open named file with mode and protection, attach to this filebuf
    filebuf _FAR * _Cdecl open( const signed char _FAR *, int,
                                int = filebuf::openprot );
    filebuf _FAR * _Cdecl open( const unsigned char _FAR *, int,
                                int = filebuf::openprot );

    filebuf _FAR * _Cdecl close();      // flush and close file
    filebuf _FAR * _Cdecl attach(int);  // attach this filebuf to opened
                                        // file descriptor

/*
 * These perform the streambuf functions on a filebuf
 * Get and Put pointers are kept together
 */
virtual int _Cdecl overflow(int = EOF);
virtual int _Cdecl underflow();
virtual int _Cdecl sync();
virtual streampos  _Cdecl seekoff(streamoff, ios::seek_dir, int);
virtual streambuf _FAR * _Cdecl setbuf(char _FAR *, int);

protected:
    int xfd;        // the file descriptor, EOF if closed
    int mode;       // the opened mode
    short   opened; // non-zero if file is open

    streampos last_seek;    // unused           ***
    char _FAR *   in_start; // unused           ***

    int _Cdecl last_op();   // unused           ***
    char    lahead[2];      // current input char if unbuffered ***
};
/*
 * The data members marked with *** above are not documented in the AT&T
 * release of streams, so we cannot guarantee compatibility with any
 * other streams release in the use or values of these data members.
 * If you can document any expected behavior of these data members, we
 * will try to adjust our implementation accordingly.
 */
inline int  _Cdecl filebuf::is_open()   { return opened; }
inline int  _Cdecl filebuf::fd()        { return xfd; }
inline filebuf _FAR * _Cdecl filebuf::open(const unsigned char _FAR * __name, int __m, int __prot) {
    return filebuf::open((const signed char _FAR *) __name, __m, __prot);
    }

class _CLASSTYPE fstreambase : virtual public ios {
public:
    _Cdecl fstreambase();
    _Cdecl fstreambase(const signed char _FAR *, int, int = filebuf::openprot);
    _Cdecl fstreambase(int);
    _Cdecl fstreambase(int __f, signed char _FAR *, int);
    _Cdecl ~fstreambase();

    void    _Cdecl open(const signed char _FAR *, int, int = filebuf::openprot);
    void    _Cdecl attach(int);
    void    _Cdecl close();
    void    _Cdecl setbuf(char _FAR *, int);
    filebuf _FAR * _Cdecl rdbuf();

protected:
    void    _Cdecl verify(int); // unimplemented    ***

private:
    filebuf buf;
};
/*
 * The function member marked with *** above is not documented in the AT&T
 * release of streams, so we cannot guarantee compatibility with any
 * other streams release in its use.
 * If you can document any expected behavior of this function member, we
 * will try to adjust our implementation accordingly.
 */
inline filebuf _FAR * _Cdecl fstreambase::rdbuf() { return &buf; }

class _CLASSTYPE ifstream : public fstreambase, public istream {
public:
    _Cdecl ifstream();
    _Cdecl ifstream(const signed char _FAR *,int = ios::in,int = filebuf::openprot);
    _Cdecl ifstream(const unsigned char _FAR *,int = ios::in,int = filebuf::openprot);
    _Cdecl ifstream(int);
    _Cdecl ifstream(int __f, signed char _FAR *, int);
    _Cdecl ifstream(int __f, unsigned char _FAR *, int);
    _Cdecl ~ifstream();

    filebuf _FAR * _Cdecl rdbuf();
    void    _Cdecl open(const signed char _FAR *, int = ios::in,
                        int = filebuf::openprot);
    void    _Cdecl open(const unsigned char _FAR *, int = ios::in,
                        int = filebuf::openprot);
};
inline filebuf _FAR * _Cdecl ifstream::rdbuf() { return fstreambase::rdbuf(); }
inline void _Cdecl ifstream::open(const signed char _FAR * __name, int __m, int __prot) {
    fstreambase::open(__name, __m | ios::in, __prot);
    }
inline void _Cdecl ifstream::open(const unsigned char _FAR * __name, int __m, int __prot) {
    fstreambase::open((const signed char _FAR *)__name, __m | ios::in, __prot);
    }


class _CLASSTYPE ofstream : public fstreambase, public ostream {
public:
    _Cdecl ofstream();
    _Cdecl ofstream(const signed char _FAR *, int = ios::out,
                    int = filebuf::openprot);
    _Cdecl ofstream(const unsigned char _FAR *, int = ios::out,
                    int = filebuf::openprot);
    _Cdecl ofstream(int);
    _Cdecl ofstream(int __f, signed char _FAR *, int);
    _Cdecl ofstream(int __f, unsigned char _FAR *, int);
    _Cdecl ~ofstream();

    filebuf _FAR * _Cdecl rdbuf();
    void    _Cdecl open(const signed char _FAR *, int = ios::out,
                        int = filebuf::openprot);
    void    _Cdecl open(const unsigned char _FAR *, int = ios::out,
                        int = filebuf::openprot);
};
inline filebuf _FAR * _Cdecl ofstream::rdbuf() { return fstreambase::rdbuf(); }
inline void _Cdecl ofstream::open(const signed char _FAR * __name, int __m, int __prot) {
    fstreambase::open(__name, __m | ios::out, __prot);
    }
inline void _Cdecl ofstream::open(const unsigned char _FAR * __name, int __m, int __prot) {
    fstreambase::open((const signed char _FAR *)__name, __m | ios::out, __prot);
    }


class _CLASSTYPE fstream : public fstreambase, public iostream {
public:
    _Cdecl fstream();
    _Cdecl fstream(const signed char _FAR *, int, int = filebuf::openprot);
    _Cdecl fstream(const unsigned char _FAR *, int, int = filebuf::openprot);
    _Cdecl fstream(int);
    _Cdecl fstream(int __f, signed char _FAR *, int);
    _Cdecl fstream(int __f, unsigned char _FAR *, int);
    _Cdecl ~fstream();

    filebuf _FAR * _Cdecl rdbuf();
    void    _Cdecl open(const signed char _FAR *, int, int = filebuf::openprot);
    void    _Cdecl open(const unsigned char _FAR *, int, int = filebuf::openprot);
};
inline filebuf _FAR * _Cdecl fstream::rdbuf() {return fstreambase::rdbuf();}
inline void _Cdecl fstream::open(const signed char _FAR * __name, int __m, int __prot) {
    fstreambase::open(__name, __m, __prot);
    }
inline void _Cdecl fstream::open(const unsigned char _FAR * __name, int __m, int __prot) {
    fstreambase::open((const signed char _FAR *)__name, __m, __prot);
    }


#pragma option -Vo.
#if defined(__BCOPT__)
#pragma option -po.
#endif

#endif
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
\*****************************************************************************/

#ifndef __DDE_H         /* prevent multiple includes */
#define __DDE_H

#ifndef __WINDOWS_H
#include <windows.h>    /* <windows.h> must be included */
#endif  /* __WINDOWS_H */

#ifndef RC_INVOKED
#pragma option -a-      /* Assume byte packing throughout */
#pragma warn -bbf       /* Turn off warning about bitfields */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* DDE window messages */

#define WM_DDE_FIRST        0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE       (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK          (WM_DDE_FIRST+4)
#define WM_DDE_DATA         (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST      (WM_DDE_FIRST+6)
#define WM_DDE_POKE         (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE      (WM_DDE_FIRST+8)
#define WM_DDE_LAST         (WM_DDE_FIRST+8)

/****************************************************************************\
*       DDEACK structure
*
*       Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
*       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
*       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
*
\****************************************************************************/

typedef struct tagDDEACK
{
    WORD    bAppReturnCode:8,
            reserved:6,
            fBusy:1,
            fAck:1;
} DDEACK;

/****************************************************************************\
*       DDEADVISE structure
*
*       WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
*
\****************************************************************************/

typedef struct tagDDEADVISE
{
    WORD    reserved:14,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDEADVISE;

/****************************************************************************\
*       DDEDATA structure
*
*       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEDATA
{
    WORD    unused:12,
            fResponse:1,
            fRelease:1,
            reserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE     Value[1];
} DDEDATA;


/****************************************************************************\
*       DDEPOKE structure
*
*       WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEPOKE
{
    WORD    unused:13,  /* Earlier versions of DDE.H incorrectly */
                        /* 12 unused bits.                       */
            fRelease:1,
            fReserved:2;
    short   cfFormat;
    BYTE    Value[1];   /* This member was named rgb[1] in previous */
                        /* versions of DDE.H                        */

} DDEPOKE;

/****************************************************************************\
* The following typedef's were used in previous versions of the Windows SDK.
* They are still valid.  The above typedef's define exactly the same structures
* as those below.  The above typedef names are recommended, however, as they
* are more meaningful.
*
* Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
* not correctly define the bit positions.
\****************************************************************************/

typedef struct tagDDELN
{
    WORD    unused:13,
            fRelease:1,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDELN;

typedef struct tagDDEUP
{
    WORD    unused:12,
            fAck:1,
            fRelease:1,
            fReserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE    rgb[1];
} DDEUP;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma option -a.      /* Revert to default packing */
#pragma warn .bbf       /* Revert to default warning about bitfields */
#endif  /* RC_INVOKED */

#endif  /* __DDE_H */
/*  time.h

    Struct and function declarations for dealing with time.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __TIME_H
#define __TIME_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifndef  _TIME_T
#define  _TIME_T
typedef long time_t;
#endif

#ifndef  _CLOCK_T
#define  _CLOCK_T
typedef long clock_t;

#define CLOCKS_PER_SEC 18.2
#define CLK_TCK        18.2

#endif  /* _TIME_T */

struct tm
{
  int   tm_sec;
  int   tm_min;
  int   tm_hour;
  int   tm_mday;
  int   tm_mon;
  int   tm_year;
  int   tm_wday;
  int   tm_yday;
  int   tm_isdst;
};

#ifdef __cplusplus
extern "C" {
#endif
char _FAR *     _Cdecl _FARFUNC asctime(const struct tm _FAR *__tblock);
char _FAR *     _Cdecl _FARFUNC ctime(const time_t _FAR *__time);
double      _Cdecl difftime(time_t __time2, time_t __time1);
struct tm _FAR * _Cdecl _FARFUNC gmtime(const time_t _FAR *__timer);
struct tm _FAR * _Cdecl _FARFUNC localtime(const time_t _FAR *__timer);
time_t      _Cdecl time(time_t _FAR *__timer);
time_t      _Cdecl _FARFUNC mktime(struct tm _FAR *__timeptr);
clock_t     _Cdecl clock(void);
size_t      _Cdecl _FARFUNC strftime(char _FAR *__s, size_t __maxsize,
                        const char _FAR *__fmt, const struct tm _FAR *__t);

#if !__STDC__

#if !defined(_RTLDLL)

extern int  _Cdecl  daylight;
extern long _Cdecl  timezone;
extern char _FAR * const _Cdecl tzname[2];

#else

int  far * far _Cdecl       __getDaylight(void);
long far * far _Cdecl       __getTimezone(void);
char far * far * far _Cdecl __getTzname(void);

#define daylight (*__getDaylight())
#define timezone (*__getTimezone())
#define tzname   (__getTzname())

#endif  /* _RTLDLL */

int         _Cdecl  stime(time_t _FAR *__tp);
void        _Cdecl  _FARFUNC tzset(void);
char _FAR * _Cdecl  _FARFUNC _strdate(char _FAR *datestr);
char _FAR * _Cdecl  _FARFUNC _strtime(char _FAR *timestr);
#endif

#ifdef __cplusplus
}
#endif

#endif
PKBGI Stroked Font V1.1 - Jun 5, 1989
Copyright (c) 1987,1988 Borland International
 TRIP@                             +             < ` t  8xZ~V\fV	P		$


`DnD^,@H\jr:| bfBph |6|0pPhzfBdH". ~  2!!x" #^##`$$%%*&&
'''p((l))2**+R++,n,,,-P----.0222233 343@3P3`3n3|333333333334 444H4T4p444444444455 5n5556V6667F7X77
8L88999~:::<;^;;;;;<b<<<<=<===
	


 
	

   
      
                         

   }    

                     	              	   
                                  	                                                                     
                                                 y      	      
      	        y   
                     

      
         yz{{z   yz{{z       	                                               y      	   	   	   	   	   }
   	   	   	                                	   	     
                                                      z   	              
             	                 	   
 	               		  		}}}}     		  		  		  		}}}}}}}}   						}}}}}}}}}}						}}      y   
   yy      
   y
   yy   
   
   

   
      
   

      y      y   
   yy   
   
   
   
y   y
   
   
y   

   
   
   yy   

   
   
      yy   
   
                         
         
                   {   |	   ~        
	    
 
	   
 
                        	            y   z      	             
   		


	          /*  search.h

    Definitions for search functions.

    Copyright (c) 1991, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __SEARCH_H
#define __SEARCH_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifdef __cplusplus
extern "C" {
#endif
void   _FAR *_CType _FARFUNC bsearch(const void _FAR *__key, const void _FAR *__base,
                size_t __nelem, size_t __width,
                int _Cdecl(* _FARFUNC __fcmp)(const void _FAR *, const void _FAR *));
void   _FAR *_Cdecl _FARFUNC lfind(const void _FAR *__key, const void _FAR *__base,
                 size_t _FAR *__num, size_t __width,
                 int _Cdecl(* _FARFUNC __fcmp)(const void _FAR *, const void _FAR *));
void   _FAR *_Cdecl _FARFUNC lsearch(const void _FAR *__key, void _FAR *__base,
                 size_t _FAR *__num, size_t __width,
                 int _Cdecl(* _FARFUNC __fcmp)(const void _FAR *, const void _FAR *));
void    _CType _FARFUNC qsort(void _FAR *__base, size_t __nelem, size_t __width,
                int _CType (* _FARFUNC __fcmp)(const void _FAR *, const void _FAR *));
#ifdef __cplusplus
}
#endif

#endif  /* __SEARCH_H */
/*
   GRAPHICS DEMO FOR Borland C++ 

   Copyright (c) 1987,88,91 Borland International. All rights reserved.

   From the command line, use:

		bcc bgidemo graphics.lib

*/

#ifdef __TINY__
#error BGIDEMO will not run in the tiny model.
#endif

#include <dos.h>
#include <math.h>
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include <graphics.h>

#define ESC	0x1b			/* Define the escape key	*/
#define TRUE	1			/* Define some handy constants	*/
#define FALSE	0			/* Define some handy constants	*/
#define PI	3.14159 		/* Define a value for PI	*/
#define ON	1			/* Define some handy constants	*/
#define OFF	0			/* Define some handy constants	*/

#define NFONTS 11

char *Fonts[NFONTS] = {
  "DefaultFont",   "TriplexFont",   "SmallFont",
  "SansSerifFont", "GothicFont", "ScriptFont", "SimplexFont", "TriplexScriptFont",
  "ComplexFont", "EuropeanFont", "BoldFont"
};

char *LineStyles[] = {
  "SolidLn",  "DottedLn",  "CenterLn",  "DashedLn",  "UserBitLn"
};

char *FillStyles[] = {
  "EmptyFill",  "SolidFill",      "LineFill",      "LtSlashFill",
  "SlashFill",  "BkSlashFill",    "LtBkSlashFill", "HatchFill",
  "XHatchFill", "InterleaveFill", "WideDotFill",   "CloseDotFill"
};

char *TextDirect[] = {
  "HorizDir",  "VertDir"
};

char *HorizJust[] = {
  "LeftText",   "CenterText",   "RightText"
};

char *VertJust[] = {
  "BottomText",  "CenterText",  "TopText"
};

struct PTS {
  int x, y;
};	/* Structure to hold vertex points	*/

int    GraphDriver;		/* The Graphics device driver		*/
int    GraphMode;		/* The Graphics mode value		*/
double AspectRatio;		/* Aspect ratio of a pixel on the screen*/
int    MaxX, MaxY;		/* The maximum resolution of the screen */
int    MaxColors;		/* The maximum # of colors available	*/
int    ErrorCode;		/* Reports any graphics errors		*/
struct palettetype palette;		/* Used to read palette info	*/

/*									*/
/*	Function prototypes						*/
/*									*/

void Initialize(void);
void ReportStatus(void);
void TextDump(void);
void Bar3DDemo(void);
void RandomBars(void);
void TextDemo(void);
void ColorDemo(void);
void ArcDemo(void);
void CircleDemo(void);
void PieDemo(void);
void BarDemo(void);
void LineRelDemo(void);
void PutPixelDemo(void);
void PutImageDemo(void);
void LineToDemo(void);
void LineStyleDemo(void);
void CRTModeDemo(void);
void UserLineStyleDemo(void);
void FillStyleDemo(void);
void FillPatternDemo(void);
void PaletteDemo(void);
void PolyDemo(void);
void SayGoodbye(void);
void Pause(void);
void MainWindow(char *header);
void StatusLine(char *msg);
void DrawBorder(void);
void changetextstyle(int font, int direction, int charsize);
int  gprintf(int *xloc, int *yloc, char *fmt, ... );

/*									*/
/*	Begin main function						*/
/*									*/

int main()
{

  Initialize(); 		/* Set system into Graphics mode	*/
  ReportStatus();		/* Report results of the initialization */

  ColorDemo();			/* Begin actual demonstration		*/
  if( GraphDriver==EGA || GraphDriver==EGALO || GraphDriver==VGA )
    PaletteDemo();
  PutPixelDemo();
  PutImageDemo();
  Bar3DDemo();
  BarDemo();
  RandomBars();
  ArcDemo();
  CircleDemo();
  PieDemo();
  LineRelDemo();
  LineToDemo();
  LineStyleDemo();
  UserLineStyleDemo();
  TextDump();
  TextDemo();
  CRTModeDemo();
  FillStyleDemo();
  FillPatternDemo();
  PolyDemo();
  SayGoodbye(); 		/* Give user the closing screen 	*/

  closegraph(); 		/* Return the system to text mode	*/
  return(0);
}

/*									*/
/*	INITIALIZE: Initializes the graphics system and reports 	*/
/*	any errors which occured.					*/
/*									*/

void Initialize(void)
{
  int xasp, yasp;			/* Used to read the aspect ratio*/

  GraphDriver = DETECT; 		/* Request auto-detection	*/
  initgraph( &GraphDriver, &GraphMode, "" );
  ErrorCode = graphresult();		/* Read result of initialization*/
  if( ErrorCode != grOk ){		/* Error occured during init	*/
    printf(" Graphics System Error: %s\n", grapherrormsg( ErrorCode ) );
    exit( 1 );
  }

  getpalette( &palette );		/* Read the palette from board	*/
  MaxColors = getmaxcolor() + 1;	/* Read maximum number of colors*/

  MaxX = getmaxx();
  MaxY = getmaxy();			/* Read size of screen		*/

  getaspectratio( &xasp, &yasp );	/* read the hardware aspect	*/
  AspectRatio = (double)xasp / (double)yasp; /* Get correction factor	*/

}

/*									*/
/*	REPORTSTATUS: Report the current configuration of the system	*/
/*	after the auto-detect initialization.				*/
/*									*/

void ReportStatus(void)
{
  struct viewporttype	  viewinfo;	/* Params for inquiry procedures*/
  struct linesettingstype lineinfo;
  struct fillsettingstype fillinfo;
  struct textsettingstype textinfo;
  struct palettetype	  palette;

  char *driver, *mode;			/* Strings for driver and mode	*/
  int x, y;

  getviewsettings( &viewinfo );
  getlinesettings( &lineinfo );
  getfillsettings( &fillinfo );
  gettextsettings( &textinfo );
  getpalette( &palette );

  x = 10;
  y = 4;

  MainWindow( "Status report after InitGraph" );
  settextjustify( LEFT_TEXT, TOP_TEXT );

  driver = getdrivername();
  mode = getmodename(GraphMode);	/* get current setting		*/

  gprintf( &x, &y, "Graphics device    : %-20s (%d)", driver, GraphDriver );
  gprintf( &x, &y, "Graphics mode      : %-20s (%d)", mode, GraphMode );
  gprintf( &x, &y, "Screen resolution  : ( 0, 0, %d, %d )", getmaxx(), getmaxy() );

  gprintf( &x, &y, "Current view port  : ( %d, %d, %d, %d )",
  viewinfo.left, viewinfo.top, viewinfo.right, viewinfo.bottom );
  gprintf( &x, &y, "Clipping           : %s", viewinfo.clip ? "ON" : "OFF" );

  gprintf( &x, &y, "Current position   : ( %d, %d )", getx(), gety() );
  gprintf( &x, &y, "Colors available   : %d", MaxColors );
  gprintf( &x, &y, "Current color      : %d", getcolor() );

  gprintf( &x, &y, "Line style         : %s", LineStyles[ lineinfo.linestyle ] );
  gprintf( &x, &y, "Line thickness     : %d", lineinfo.thickness );

  gprintf( &x, &y, "Current fill style : %s", FillStyles[ fillinfo.pattern ] );
  gprintf( &x, &y, "Current fill color : %d", fillinfo.color );

  gprintf( &x, &y, "Current font       : %s", Fonts[ textinfo.font ] );
  gprintf( &x, &y, "Text direction     : %s", TextDirect[ textinfo.direction ] );
  gprintf( &x, &y, "Character size     : %d", textinfo.charsize );
  gprintf( &x, &y, "Horizontal justify : %s", HorizJust[ textinfo.horiz ] );
  gprintf( &x, &y, "Vertical justify   : %s", VertJust[ textinfo.vert ] );

  Pause();				/* Pause for user to read screen*/

}

/*									*/
/*	TEXTDUMP: Display the all the characters in each of the 	*/
/*	available fonts.						*/
/*									*/

void TextDump()
{
  static int CGASizes[]  = {
    1, 3, 7, 3, 3, 2, 2, 2, 2, 2, 2  };
  static int NormSizes[] = {
    1, 4, 7, 4, 4, 2, 2, 2, 2, 2, 2  };

  char buffer[80];
  int font, ch, wwidth, lwidth, size;
  struct viewporttype vp;

  for( font=0 ; font<NFONTS ; ++font ){	/* For each available font	*/
    sprintf( buffer, "%s Character Set", Fonts[font] );
    MainWindow( buffer );		/* Display fontname as banner	*/
    getviewsettings( &vp );		/* read current viewport	*/

    settextjustify( LEFT_TEXT, TOP_TEXT );
    moveto( 2, 3 );

    buffer[1] = '\0';                   /* Terminate string             */
    wwidth = vp.right - vp.left;	/* Determine the window width	*/
    lwidth = textwidth( "H" );          /* Get average letter width     */

    if( font == DEFAULT_FONT ){
      changetextstyle( font, HORIZ_DIR, 1 );
      ch = 0;
      while( ch < 256 ){		/* For each possible character	*/
	buffer[0] = ch; 		/* Put character into a string	*/
	outtext( buffer );		/* send string to screen	*/
	if( (getx() + lwidth) > wwidth )
	  moveto( 2, gety() + textheight("H") + 3 );
	++ch;				/* Goto the next character	*/
      }
    }
    else{

      size = (MaxY < 200) ? CGASizes[font] : NormSizes[font];
      changetextstyle( font, HORIZ_DIR, size );

      ch = '!';                         /* Begin at 1st printable       */
      while( ch < 256 ){		/* For each printable character */
	buffer[0] = ch; 		/* Put character into a string	*/
	outtext( buffer );		/* send string to screen	*/
	if( (lwidth+getx()) > wwidth )	/* Are we still in window?	*/
	  moveto( 2, gety()+textheight("H")+3 );
	++ch;				/* Goto the next character	*/
      }

    }

    Pause();				/* Pause until user acks	*/

  }					/* End of FONT loop		*/

}

/*									*/
/*	BAR3DDEMO: Display a 3-D bar chart on the screen.		*/
/*									*/

void Bar3DDemo(void)
{
  static int barheight[] = {
    1, 3, 5, 4, 3, 2, 1, 5, 4, 2, 3   };
  struct viewporttype vp;
  int xstep, ystep;
  int i, j, h, color, bheight;
  char buffer[10];

  MainWindow( "Bar 3-D / Rectangle Demonstration" );

  h = 3 * textheight( "H" );
  getviewsettings( &vp );
  settextjustify( CENTER_TEXT, TOP_TEXT );
  changetextstyle( TRIPLEX_FONT, HORIZ_DIR, 4 );
  outtextxy( MaxX/2, 6, "These are 3-D Bars" );
  changetextstyle( DEFAULT_FONT, HORIZ_DIR, 1 );
  setviewport( vp.left+50, vp.top+40, vp.right-50, vp.bottom-10, 1 );
  getviewsettings( &vp );

  line( h, h, h, vp.bottom-vp.top-h );
  line( h, (vp.bottom-vp.top)-h, (vp.right-vp.left)-h, (vp.bottom-vp.top)-h );
  xstep = ((vp.right-vp.left) - (2*h)) / 10;
  ystep = ((vp.bottom-vp.top) - (2*h)) / 5;
  j = (vp.bottom-vp.top) - h;
  settextjustify( CENTER_TEXT, CENTER_TEXT );

  for( i=0 ; i<6 ; ++i ){
    line( h/2, j, h, j );
    itoa( i, buffer, 10 );
    outtextxy( 0, j, buffer );
    j -= ystep;
  }

  j = h;
  settextjustify( CENTER_TEXT, TOP_TEXT );

  for( i=0 ; i<11 ; ++i ){
    color = random( MaxColors );
    setfillstyle( i+1, color );
    line( j, (vp.bottom-vp.top)-h, j, (vp.bottom-vp.top-3)-(h/2) );
    itoa( i, buffer, 10 );
    outtextxy( j, (vp.bottom-vp.top)-(h/2), buffer );
    if( i != 10 ){
      bheight = (vp.bottom-vp.top) - h - 1;
      bar3d( j, (vp.bottom-vp.top-h)-(barheight[i]*ystep), j+xstep, bheight, 15, 1 );
    }
    j += xstep;
  }

  Pause();				/* Pause for user's response    */

}

/*									*/
/*	RANDOMBARS: Display random bars 				*/
/*									*/

void RandomBars(void)
{
  int color;

  MainWindow( "Random Bars" );
  StatusLine( "Esc aborts or press a key..." ); /* Put msg at bottom of screen   */
  while( !kbhit() ){			/* Until user enters a key...	*/
    color = random( MaxColors-1 )+1;
    setcolor( color );
    setfillstyle( random(11)+1, color );
    bar3d( random( getmaxx() ), random( getmaxy() ),
	   random( getmaxx() ), random( getmaxy() ), 0, OFF);
  }

  Pause();				/* Pause for user's response    */

}


/*									*/
/*	TEXTDEMO: Show each font in several sizes to the user.		*/
/*									*/

void TextDemo(void)
{
  int charsize[] = {
    1, 3, 7, 3, 4, 2, 2, 2, 2, 2, 2   };
  int font, size;
  int h, x, y, i;
  struct viewporttype vp;
  char buffer[80];

  for( font=0 ; font<NFONTS ; ++font ){	/* For each of the avail. fonts	*/

    sprintf( buffer, "%s Demonstration", Fonts[font] );
    MainWindow( buffer );
    getviewsettings( &vp );

    changetextstyle( font, VERT_DIR, charsize[font] );
    settextjustify( CENTER_TEXT, BOTTOM_TEXT );
    outtextxy( 2*textwidth("M"), vp.bottom - 2*textheight("M"), "Vertical" );

    changetextstyle( font, HORIZ_DIR, charsize[font] );
    settextjustify( LEFT_TEXT, TOP_TEXT );
    outtextxy( 2*textwidth("M"), 2, "Horizontal" );

    settextjustify( CENTER_TEXT, CENTER_TEXT );
    x = (vp.right - vp.left) / 2;
    y = textheight( "H" );

    for( i=1 ; i<5 ; ++i ){		/* For each of the sizes */
      size = (font == SMALL_FONT) ? i+3 : i;
      changetextstyle( font, HORIZ_DIR, size );
      h = textheight( "H" );
      y += h;
      sprintf( buffer, "Size %d", size );
      outtextxy( x, y, buffer );

    }

    if( font != DEFAULT_FONT ){ 	/* Show user declared font size */
      y += h / 2;			/* Move down the screen 	*/
      settextjustify( CENTER_TEXT, TOP_TEXT );
      setusercharsize( 5, 6, 3, 2 );
      changetextstyle( font, HORIZ_DIR, USER_CHAR_SIZE );
      outtextxy( (vp.right-vp.left)/2, y, "User Defined Size" );
    }

    Pause();				/* Pause to let user look	*/

  }					/* End of FONT loop		*/

}

/*									*/
/*	COLORDEMO: Display the current color palette on the screen.	*/
/*									*/

void ColorDemo(void)
{
  struct viewporttype vp;
  int color, height, width;
  int x, y, i, j;
  char cnum[5];

  MainWindow( "Color Demonstration" );  /* Show demonstration name      */

  color = 1;
  getviewsettings( &vp );		/* Get the current window size	*/
  width  = 2 * ( (vp.right+1) / 16 );	   /* Get box dimensions	   */
  height = 2 * ( (vp.bottom-10) / 10 );

  x = width / 2;
  y = height / 2;	/* Leave 1/2 box border 	*/

  for( j=0 ; j<3 ; ++j ){		/* Row loop			*/

    for( i=0 ; i<5 ; ++i ){		/* Column loop			*/

      setfillstyle(SOLID_FILL, color);	/* Set to solid fill in color	*/
      setcolor( color );		/* Set the same border color	*/

      bar( x, y, x+width, y+height );	/* Draw the rectangle		*/
      rectangle( x, y, x+width, y+height );  /* outline the rectangle	*/

      if( color == BLACK ){		/* If box was black...		*/
	setcolor( WHITE );		/* Set drawing color to white	*/
	rectangle( x, y, x+width, y+height );  /* Outline black in white*/
      }

      itoa( color, cnum, 10 );		/* Convert # to ASCII		*/
      outtextxy( x+(width/2), y+height+4, cnum );  /* Show color #	*/

      color = ++color % MaxColors;	/* Advance to the next color	*/
      x += (width / 2) * 3;		/* move the column base 	*/
    }				/* End of Column loop		*/

    y += (height / 2) * 3;		/* move the row base		*/
    x = width / 2;			/* reset column base		*/
  }					/* End of Row loop		*/

  Pause();				/* Pause for user's response    */

}

/*									*/
/*	ARCDEMO: Display a random pattern of arcs on the screen */
/*	until the user says enough.					*/
/*									*/

void ArcDemo(void)
{
  int mradius;				/* Maximum radius allowed	*/
  int eangle;				/* Random end angle of Arc	*/
  struct arccoordstype ai;		/* Used to read Arc Cord info	*/

  MainWindow( "Arc Demonstration" );
  StatusLine( "ESC Aborts - Press a Key to stop" );

  mradius = MaxY / 10;			/* Determine the maximum radius */

  while( !kbhit() ){			/* Repeat until a key is hit	*/
    setcolor( random( MaxColors - 1 ) + 1 );	/* Randomly select a color	*/
    eangle = random( 358 ) + 1; 	/* Select an end angle		*/
    arc( random(MaxX), random(MaxY), random(eangle), eangle, mradius );
    getarccoords( &ai );		/* Read Cord data		*/
    line( ai.x, ai.y, ai.xstart, ai.ystart ); /* line from start to center */
    line( ai.x, ai.y,	ai.xend,   ai.yend ); /* line from end to center   */
  }					/* End of WHILE not KBHIT	*/

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	CIRCLEDEMO: Display a random pattern of circles on the screen	*/
/*	until the user says enough.					*/
/*									*/

void CircleDemo(void)
{
  int mradius;				/* Maximum radius allowed	*/

  MainWindow( "Circle Demonstration" );
  StatusLine( "ESC Aborts - Press a Key to stop" );

  mradius = MaxY / 10;			/* Determine the maximum radius */

  while( !kbhit() ){			/* Repeat until a key is hit	*/
    setcolor( random( MaxColors - 1 ) + 1 );	/* Randomly select a color	*/
    circle( random(MaxX), random(MaxY), random(mradius) );
  }					/* End of WHILE not KBHIT	*/

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	PIEDEMO: Display a pie chart on the screen.			*/
/*									*/

#define adjasp( y )	((int)(AspectRatio * (double)(y)))
#define torad( d )	(( (double)(d) * PI ) / 180.0 )

void PieDemo(void)
{
  struct viewporttype vp;
  int xcenter, ycenter, radius, lradius;
  int x, y;
  double radians, piesize;

  MainWindow( "Pie Chart Demonstration" );

  getviewsettings( &vp );		/* Get the current viewport	*/
  xcenter = (vp.right - vp.left) / 2;	/* Center the Pie horizontally	*/
  ycenter = (vp.bottom - vp.top) / 2+20;/* Center the Pie vertically	*/
  radius  = (vp.bottom - vp.top) / 3;	/* It will cover 2/3rds screen	*/
  piesize = (vp.bottom - vp.top) / 4.0; /* Optimum height ratio of pie	*/

  while( (AspectRatio*radius) < piesize ) ++radius;

  lradius = radius + ( radius / 5 );	/* Labels placed 20% farther	*/

  changetextstyle( TRIPLEX_FONT, HORIZ_DIR, 4 );
  settextjustify( CENTER_TEXT, TOP_TEXT );
  outtextxy( MaxX/2, 6, "This is a Pie Chart" );
  changetextstyle( TRIPLEX_FONT, HORIZ_DIR, 1 );
  settextjustify( CENTER_TEXT, TOP_TEXT );

  setfillstyle( SOLID_FILL, RED );
  pieslice( xcenter+10, ycenter-adjasp(10), 0, 90, radius );
  radians = torad( 45 );
  x = xcenter + (int)( cos( radians ) * (double)lradius );
  y = ycenter - (int)( sin( radians ) * (double)lradius * AspectRatio );
  settextjustify( LEFT_TEXT, BOTTOM_TEXT );
  outtextxy( x, y, "25 %" );

  setfillstyle( WIDE_DOT_FILL, GREEN );
  pieslice( xcenter, ycenter, 90, 135, radius );
  radians = torad( 113 );
  x = xcenter + (int)( cos( radians ) * (double)lradius );
  y = ycenter - (int)( sin( radians ) * (double)lradius * AspectRatio );
  settextjustify( RIGHT_TEXT, BOTTOM_TEXT );
  outtextxy( x, y, "12.5 %" );

  setfillstyle( INTERLEAVE_FILL, YELLOW );
  settextjustify( RIGHT_TEXT, CENTER_TEXT );
  pieslice( xcenter-10, ycenter, 135, 225, radius );
  radians = torad( 180 );
  x = xcenter + (int)( cos( radians ) * (double)lradius );
  y = ycenter - (int)( sin( radians ) * (double)lradius * AspectRatio );
  settextjustify( RIGHT_TEXT, CENTER_TEXT );
  outtextxy( x, y, "25 %" );

  setfillstyle( HATCH_FILL, BLUE );
  pieslice( xcenter, ycenter, 225, 360, radius );
  radians = torad( 293 );
  x = xcenter + (int)( cos( radians ) * (double)lradius );
  y = ycenter - (int)( sin( radians ) * (double)lradius * AspectRatio );
  settextjustify( LEFT_TEXT, TOP_TEXT );
  outtextxy( x, y, "37.5 %" );

  Pause();				/* Pause for user's response    */

}

/*									*/
/*	BARDEMO: Draw a 2-D bar chart using Bar and Rectangle.		*/
/*									*/

void BarDemo(void)
{
  int barheight[] = {
    1, 3, 5, 2, 4   };
  int styles[]	  = {
    1, 3, 10, 5, 9, 1	};
  int xstep, ystep;
  int sheight, swidth;
  int i, j, h;
  struct viewporttype vp;
  char buffer[40];

  MainWindow( "Bar / Rectangle demonstration" );
  h = 3 * textheight( "H" );
  getviewsettings( &vp );
  settextjustify( CENTER_TEXT, TOP_TEXT );
  changetextstyle( TRIPLEX_FONT, HORIZ_DIR, 4 );
  outtextxy( MaxX /2, 6, "These are 2-D Bars" );
  changetextstyle( DEFAULT_FONT, HORIZ_DIR, 1 );
  setviewport( vp.left+50, vp.top+30, vp.right-50, vp.bottom-10, 1 );

  getviewsettings( &vp );
  sheight = vp.bottom - vp.top;
  swidth  = vp.right  - vp.left;

  line( h, h, h, sheight-h );
  line( h, sheight-h, sheight-h, sheight-h );
  ystep = (sheight - (2*h) ) / 5;
  xstep = (swidth  - (2*h) ) / 5;
  j = sheight - h;
  settextjustify( CENTER_TEXT, CENTER_TEXT );

  for( i=0 ; i<6 ; ++i ){
    line( h/2, j, h, j );
    itoa( i, buffer, 10 );
    outtextxy( 0, j, buffer );
    j -= ystep;
  }

  j = h;
  settextjustify( CENTER_TEXT, TOP_TEXT );
  for( i=0 ; i<6 ; ++i ){
    setfillstyle( styles[i], random(MaxColors) );
    line( j, sheight - h, j, sheight- 3 - (h/2) );
    itoa( i, buffer, 10 );
    outtextxy( j, sheight - (h/2), buffer );
    if( i != 5 ){
      bar( j, (sheight-h)-(barheight[i] * ystep), j+xstep, sheight-h-1 );
      rectangle( j, (sheight-h)-(barheight[i] * ystep), j+xstep, sheight-h);
    }
    j += xstep;
  }

  Pause();

}

/*									*/
/*	LINERELDEMO: Display pattern using moverel and linerel cmds.	*/
/*									*/

void LineRelDemo(void)
{
  struct viewporttype vp;
  int h, w, dx, dy, cx, cy;
  struct PTS outs[7];


  MainWindow( "MoveRel / LineRel Demonstration" );
  StatusLine( "Press any key to continue, ESC to Abort" );

  getviewsettings( &vp );
  cx = (vp.right  - vp.left) / 2;	/* Center of the screen coords	*/
  cy = (vp.bottom - vp.top ) / 2;

  h  = (vp.bottom - vp.top ) / 8;
  w  = (vp.right  - vp.left) / 9;

  dx = 2 * w;
  dy = 2 * h;

  setcolor( BLACK );

  setfillstyle( SOLID_FILL, BLUE );
  bar( 0, 0, vp.right-vp.left, vp.bottom-vp.top );	/* Draw backgnd */

  outs[0].x = cx -  dx;
  outs[0].y = cy -  dy;
  outs[1].x = cx - (dx-w);
  outs[1].y = cy - (dy+h);
  outs[2].x = cx +  dx;
  outs[2].y = cy - (dy+h);
  outs[3].x = cx +  dx;
  outs[3].y = cy +  dy;
  outs[4].x = cx + (dx-w);
  outs[4].y = cy + (dy+h);
  outs[5].x = cx -  dx;
  outs[5].y = cy + (dy+h);
  outs[6].x = cx -  dx;
  outs[6].y = cy -  dy;

  setfillstyle( SOLID_FILL, WHITE );
  fillpoly( 7, (int far *)outs );

  outs[0].x = cx - (w/2);
  outs[0].y = cy + h;
  outs[1].x = cx + (w/2);
  outs[1].y = cy + h;
  outs[2].x = cx + (w/2);
  outs[2].y = cy - h;
  outs[3].x = cx - (w/2);
  outs[3].y = cy - h;
  outs[4].x = cx - (w/2);
  outs[4].y = cy + h;

  setfillstyle( SOLID_FILL, BLUE );
  fillpoly( 5, (int far *)outs );

  /*	Draw a Tesseract object on the screen using the LineRel and	*/
  /*	MoveRel drawing commands.					*/

  moveto( cx-dx, cy-dy );
  linerel(  w, -h );
  linerel(  3*w,	0 );
  linerel(   0,  5*h );
  linerel( -w,	h );
  linerel( -3*w,	0 );
  linerel(   0, -5*h );

  moverel( w, -h );
  linerel(   0,  5*h );
  linerel( w+(w/2), 0 );
  linerel(   0, -3*h );
  linerel( w/2,   -h );
  linerel( 0, 5*h );

  moverel(  0, -5*h );
  linerel( -(w+(w/2)), 0 );
  linerel( 0, 3*h );
  linerel( -w/2, h );

  moverel( w/2, -h );
  linerel( w, 0 );

  moverel( 0, -2*h );
  linerel( -w, 0 );

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	PUTPIXELDEMO: Display a pattern of random dots on the screen	*/
/*	and pick them back up again.					*/
/*									*/

void PutPixelDemo(void)
{
  int seed = 1958;
  int i, x, y, h, w, color;
  struct viewporttype vp;

  MainWindow( "PutPixel / GetPixel Demonstration" );

  getviewsettings( &vp );
  h = vp.bottom - vp.top;
  w = vp.right	- vp.left;

  srand( seed );			/* Restart random # function	*/

  for( i=0 ; i<5000 ; ++i ){		/* Put 5000 pixels on screen	*/
    x = 1 + random( w - 1 );		/* Generate a random location	*/
    y = 1 + random( h - 1 );
    color = random( MaxColors );
    putpixel( x, y, color );
  }

  srand( seed );			/* Restart Random # at same #	*/

  for( i=0 ; i<5000 ; ++i ){		/* Take the 5000 pixels off	*/
    x = 1 + random( w - 1 );		/* Generate a random location	*/
    y = 1 + random( h - 1 );
    color = getpixel( x, y );		/* Read the color pixel 	*/
    if( color == random( MaxColors ) )	/* Used to keep RANDOM in sync	*/
      putpixel( x, y, 0 );		/* Write pixel to BLACK 	*/
  }

  Pause();				/* Wait for user's response     */

}

/*									*/
/*   PUTIMAGEDEMO							*/
/*									*/
void PutImageDemo(void)
{
  static int r	    = 20;
  static int StartX = 100;
  static int StartY = 50;

  struct viewporttype vp;
  int PauseTime, x, y, ulx, uly, lrx, lry, size, i, width, height, step;
  void *Saucer;

  MainWindow("GetImage / PutImage Demonstration");
  getviewsettings( &vp );

  /* Draw Saucer */
  setfillstyle( SOLID_FILL, getmaxcolor() );
  fillellipse(StartX, StartY, r, (r/3)+2);
  ellipse(StartX, StartY-4, 190, 357, r, r/3);

  line(StartX+7, StartY-6, StartX+10, StartY-12);
  circle(StartX+10, StartY-12, 2);
  line(StartX-7, StartY-6, StartX-10, StartY-12);
  circle(StartX-10, StartY-12, 2);


  /* Read saucer image */
  ulx = StartX-(r+1);
  uly = StartY-14;
  lrx = StartX+(r+1);
  lry = StartY+(r/3)+3;
  width = lrx - ulx + 1;
  height = lry - uly + 1;
  size = imagesize(ulx, uly, lrx, lry);

  Saucer = malloc( size );
  getimage(ulx, uly, lrx, lry, Saucer);
  putimage(ulx, uly, Saucer, XOR_PUT);

/* Plot some "stars"  */
  for ( i=0 ; i<1000; ++i )
    putpixel(random(MaxX), random(MaxY), random( MaxColors-1 )+1);
  x = MaxX / 2;
  y = MaxY / 2;
  PauseTime = 70;

  /* until a key is hit */
  while ( !kbhit() ) {

    /* Draw the Saucer */
    putimage(x, y, Saucer, XOR_PUT);		     /*  draw image  */
    delay(PauseTime);
    putimage(x, y, Saucer, XOR_PUT);		     /* erase image  */

    /* Move Saucer */

    step = random( 2*r );
    if ((step/2) % 2 != 0 )
      step = -1 * step;
    x = x + step;
    step = random( r );
    if ((step/2) % 2 != 0 )
      step = -1 * step;
    y = y + step;

    if (vp.left + x + width - 1 > vp.right)
      x = vp.right-vp.left-width + 1;
    else
      if (x < 0)
	x = 0;
    if (vp.top + y + height - 1 > vp.bottom)
      y = vp.bottom-vp.top-height + 1;
    else
      if (y < 0)
	y = 0;
  }
  free( Saucer );
  Pause();
}


/*									*/
/*	LINETODEMO: Display a pattern using moveto and lineto commands. */
/*									*/

#define MAXPTS	15

void LineToDemo(void)
{
  struct viewporttype vp;
  struct PTS points[MAXPTS];
  int i, j, h, w, xcenter, ycenter;
  int radius, angle, step;
  double  rads;

  MainWindow( "MoveTo / LineTo Demonstration" );

  getviewsettings( &vp );
  h = vp.bottom - vp.top;
  w = vp.right	- vp.left;

  xcenter = w / 2;			/* Determine the center of circle */
  ycenter = h / 2;
  radius  = (h - 30) / (AspectRatio * 2);
  step	  = 360 / MAXPTS;		/* Determine # of increments	*/

  angle = 0;				/* Begin at zero degrees	*/
  for( i=0 ; i<MAXPTS ; ++i ){		/* Determine circle intercepts	*/
    rads = (double)angle * PI / 180.0;	/* Convert angle to radians	*/
    points[i].x = xcenter + (int)( cos(rads) * radius );
    points[i].y = ycenter - (int)( sin(rads) * radius * AspectRatio );
    angle += step;			/* Move to next increment	*/
  }

  circle( xcenter, ycenter, radius );	/* Draw bounding circle 	*/

  for( i=0 ; i<MAXPTS ; ++i ){		/* Draw the cords to the circle */
    for( j=i ; j<MAXPTS ; ++j ){	/* For each remaining intersect */
      moveto(points[i].x, points[i].y); /* Move to beginning of cord	*/
      lineto(points[j].x, points[j].y); /* Draw the cord		*/
    }
  }

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	LINESTYLEDEMO: Display a pattern using all of the standard	*/
/*	line styles that are available. 				*/
/*									*/

void LineStyleDemo(void)
{
  int style, step;
  int x, y, w;
  struct viewporttype vp;
  char buffer[40];

  MainWindow( "Pre-defined line styles" );

  getviewsettings( &vp );
  w = vp.right	- vp.left;

  x = 35;
  y = 10;
  step = w / 11;

  settextjustify( LEFT_TEXT, TOP_TEXT );
  outtextxy( x, y, "Normal Width" );

  settextjustify( CENTER_TEXT, TOP_TEXT );

  for( style=0 ; style<4 ; ++style ){
    setlinestyle( style, 0, NORM_WIDTH );
    line( x, y+20, x, vp.bottom-40 );
    itoa( style, buffer, 10 );
    outtextxy( x, vp.bottom-30, buffer );
    x += step;
  }

  x += 2 * step;

  settextjustify( LEFT_TEXT, TOP_TEXT );
  outtextxy( x, y, "Thick Width" );
  settextjustify( CENTER_TEXT, TOP_TEXT );

  for( style=0 ; style<4 ; ++style ){
    setlinestyle( style, 0, THICK_WIDTH );
    line( x, y+20, x, vp.bottom-40 );
    itoa( style, buffer, 10 );
    outtextxy( x, vp.bottom-30, buffer );
    x += step;
  }

  settextjustify( LEFT_TEXT, TOP_TEXT );

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	CRTMODEDEMO: Demonstrate the effects of the change mode 	*/
/*	commands on the current screen. 				*/
/*									*/

void CRTModeDemo(void)
{
  struct viewporttype vp;
  int mode;

  MainWindow( "SetGraphMode / RestoreCRTMode demo" );
  getviewsettings( &vp );
  mode = getgraphmode();
  settextjustify( CENTER_TEXT, CENTER_TEXT );

  outtextxy( (vp.right-vp.left)/2, (vp.bottom-vp.top)/2,
  "Now you are in graphics mode..." );
  StatusLine( "Press any key for text mode..." );
  getch();

  restorecrtmode();
  printf( "Now you are in text mode.\n\n" );
  printf( "Press any key to go back to graphics..." );
  getch();

  setgraphmode( mode );
  MainWindow( "SetGraphMode / RestoreCRTMode demo" );
  settextjustify( CENTER_TEXT, CENTER_TEXT );
  outtextxy( (vp.right-vp.left)/2, (vp.bottom-vp.top)/2,
  "Back in Graphics Mode..." );

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	USERLINESTYLEDEMO: Display line styles showing the user 	*/
/*	defined line style functions.					*/
/*									*/

void UserLineStyleDemo(void)
{
  int x, y, i, h, flag;
  unsigned int style;
  struct viewporttype vp;

  MainWindow( "User defined line styles" );

  getviewsettings( &vp );
  h = vp.bottom - vp.top;

  x = 4;
  y = 10;
  style = 0;
  i = 0;

  settextjustify( CENTER_TEXT, TOP_TEXT );
  flag = TRUE;				/* Set the bits in this pass	*/

  while( x < vp.right-2 ){		/* Draw lines across the screen */

    if( flag )				/* If flag, set bits... 	*/
      style = style | (1 << i); 	/*    Set the Ith bit in word	*/
    else				/* If no flag, clear bits	*/
    style = style & !(0x8000 >> i);	/*    Clear the Ith bit in word */

    setlinestyle( USERBIT_LINE, style, NORM_WIDTH );
    line( x, y, x, h-y );		/* Draw the new line pattern	*/

    x += 5;				/* Move the X location of line	*/
    i = ++i % 16;			/* Advance to next bit pattern	*/

    if( style == 0xffff ){		/* Are all bits set?		*/
      flag = FALSE;			/*   begin removing bits	*/
      i = 0;				/* Start with whole pattern	*/
    }
    else{				/* Bits not all set...		*/
      if( style == 0 )			/* Are all bits clear?		*/
	flag = TRUE;			/*   begin setting bits 	*/
    }
  }

  settextjustify( LEFT_TEXT, TOP_TEXT );

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	FILLSTYLEDEMO: Display the standard fill patterns available.	*/
/*									*/

void FillStyleDemo(void)
{
  int h, w, style;
  int i, j, x, y;
  struct viewporttype vp;
  char buffer[40];

  MainWindow( "Pre-defined Fill Styles" );

  getviewsettings( &vp );
  w = 2 * ((vp.right  +  1) / 13);
  h = 2 * ((vp.bottom - 10) / 10);

  x = w / 2;
  y = h / 2;		/* Leave 1/2 blk margin 	*/
  style = 0;

  for( j=0 ; j<3 ; ++j ){		/* Three rows of boxes		*/
    for( i=0 ; i<4 ; ++i ){		/* Four column of boxes 	*/
      setfillstyle(style, MaxColors-1); /* Set the fill style and WHITE */
      bar( x, y, x+w, y+h );		/* Draw the actual box		*/
      rectangle( x, y, x+w, y+h );	/* Outline the box		*/
      itoa( style, buffer, 10 );	/* Convert style 3 to ASCII	*/
      outtextxy( x+(w / 2), y+h+4, buffer );
      ++style;				/* Go on to next style #	*/
      x += (w / 2) * 3; 		/* Go to next column		*/
    }				/* End of coulmn loop		*/
    x = w / 2;				/* Put base back to 1st column	*/
    y += (h / 2) * 3;			/* Advance to next row		*/
  }					/* End of Row loop		*/

  settextjustify( LEFT_TEXT, TOP_TEXT );

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	FILLPATTERNDEMO: Demonstrate how to use the user definable	*/
/*	fill patterns.							*/
/*									*/

void FillPatternDemo(void)
{
  int style;
  int h, w;
  int x, y, i, j;
  char buffer[40];
  struct viewporttype vp;
  static char patterns[][8] = {
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC },
    { 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F },
    { 0x00, 0x10, 0x28, 0x44, 0x28, 0x10, 0x00, 0x00 },
    { 0x00, 0x70, 0x20, 0x27, 0x24, 0x24, 0x07, 0x00 },
    { 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00 },
    { 0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00 },
    { 0x00, 0x00, 0x22, 0x08, 0x00, 0x22, 0x1C, 0x00 },
    { 0xFF, 0x7E, 0x3C, 0x18, 0x18, 0x3C, 0x7E, 0xFF },
    { 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00 },
    { 0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00 }
  };

  MainWindow( "User Defined Fill Styles" );

  getviewsettings( &vp );
  w = 2 * ((vp.right  +  1) / 13);
  h = 2 * ((vp.bottom - 10) / 10);

  x = w / 2;
  y = h / 2;		/* Leave 1/2 blk margin 	*/
  style = 0;

  for( j=0 ; j<3 ; ++j ){		/* Three rows of boxes		*/
    for( i=0 ; i<4 ; ++i ){		/* Four column of boxes 	*/
      setfillpattern( &patterns[style][0], MaxColors-1 );
      bar( x, y, x+w, y+h );		/* Draw the actual box		*/
      rectangle( x, y, x+w, y+h );	/* Outline the box		*/
      itoa( style, buffer, 10 );	/* Convert style 3 to ASCII	*/
      outtextxy( x+(w / 2), y+h+4, buffer );
      ++style;				/* Go on to next style #	*/
      x += (w / 2) * 3; 		/* Go to next column		*/
    }				/* End of coulmn loop		*/
    x = w / 2;				/* Put base back to 1st column	*/
    y += (h / 2) * 3;			/* Advance to next row		*/
  }					/* End of Row loop		*/

  settextjustify( LEFT_TEXT, TOP_TEXT );

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	POLYDEMO: Display a random pattern of polygons on the screen	*/
/*	until the user says enough.					*/
/*									*/

void PaletteDemo(void)
{
  int i, j, x, y, color;
  struct viewporttype vp;
  int height, width;

  MainWindow( "Palette Demonstration" );
  StatusLine( "Press any key to continue, ESC to Abort" );

  getviewsettings( &vp );
  width  = (vp.right - vp.left) / 15;	/* get width of the box 	*/
  height = (vp.bottom - vp.top) / 10;	/* Get the height of the box	*/

  x = y = 0;				/* Start in upper corner	*/
  color = 1;				/* Begin at 1st color		*/

  for( j=0 ; j<10 ; ++j ){		/* For 10 rows of boxes 	*/
    for( i=0 ; i<15 ; ++i ){		/* For 15 columns of boxes	*/
      setfillstyle( SOLID_FILL, color++ );	/* Set the color of box */
      bar( x, y, x+width, y+height );		/* Draw the box 	*/
      x += width + 1;				/* Advance to next col	*/
      color = 1 + (color % (MaxColors - 2));	/* Set new color	*/
    }				/* End of COLUMN loop		*/
    x = 0;				/* Goto 1st column		*/
    y += height + 1;			/* Goto next row		*/
  }					/* End of ROW loop		*/

  while( !kbhit() ){			/* Until user enters a key...	*/
    setpalette( 1+random(MaxColors - 2), random( 65 ) );
  }

  setallpalette( &palette );

  Pause();				/* Wait for user's response     */

}

/*									*/
/*	POLYDEMO: Display a random pattern of polygons on the screen	*/
/*	until the user says enough.					*/
/*									*/

#define MaxPts		6		/* Maximum # of pts in polygon	*/

void PolyDemo(void)
{
  struct PTS poly[ MaxPts ];		/* Space to hold datapoints	*/
  int color;				/* Current drawing color	*/
  int i;

  MainWindow( "DrawPoly / FillPoly Demonstration" );
  StatusLine( "ESC Aborts - Press a Key to stop" );

  while( !kbhit() ){			/* Repeat until a key is hit	*/

    color = 1 + random( MaxColors-1 );	/* Get a random color # (no blk)*/
    setfillstyle( random(10), color );	/* Set a random line style	*/
    setcolor( color );			/* Set the desired color	*/

    for( i=0 ; i<(MaxPts-1) ; i++ ){	/* Determine a random polygon	*/
      poly[i].x = random( MaxX );	/* Set the x coord of point	*/
      poly[i].y = random( MaxY );	/* Set the y coord of point	*/
    }

    poly[i].x = poly[0].x;		/* last point = first point	*/
    poly[i].y = poly[1].y;

    fillpoly( MaxPts, (int far *)poly );    /* Draw the actual polygon	    */
  }					/* End of WHILE not KBHIT	*/

  Pause();				/* Wait for user's response     */

}


/*									*/
/*	SAYGOODBYE: Give a closing screen to the user before leaving.	*/
/*									*/

void SayGoodbye(void)
{
  struct viewporttype viewinfo; 	/* Structure to read viewport	*/
  int h, w;

  MainWindow( "== Finale ==" );

  getviewsettings( &viewinfo ); 	/* Read viewport settings	*/
  changetextstyle( TRIPLEX_FONT, HORIZ_DIR, 4 );
  settextjustify( CENTER_TEXT, CENTER_TEXT );

  h = viewinfo.bottom - viewinfo.top;
  w = viewinfo.right  - viewinfo.left;
  outtextxy( w/2, h/2, "That's all, folks!" );

  StatusLine( "Press any key to EXIT" );
  getch();

  cleardevice();			/* Clear the graphics screen	*/

}

/*									*/
/*	PAUSE: Pause until the user enters a keystroke. If the		*/
/*	key is an ESC, then exit program, else simply return.		*/
/*									*/

void Pause(void)
{
  static char msg[] = "Esc aborts or press a key...";
  int c;

  StatusLine( msg );			/* Put msg at bottom of screen	*/

  c = getch();				/* Read a character from kbd	*/

  if( ESC == c ){			/* Does user wish to leave?	*/
    closegraph();			/* Change to text mode		*/
    exit( 1 );				/* Return to OS 		*/
  }

  if( 0 == c ){ 			/* Did use hit a non-ASCII key? */
    c = getch();			/* Read scan code for keyboard	*/
  }

  cleardevice();			/* Clear the screen		*/

}

/*									*/
/*	MAINWINDOW: Establish the main window for the demo and set	*/
/*	a viewport for the demo code.					*/
/*									*/

void MainWindow( char *header )
{
  int height;

  cleardevice();			/* Clear graphics screen	*/
  setcolor( MaxColors - 1 );		/* Set current color to white	*/
  setviewport( 0, 0, MaxX, MaxY, 1 );	/* Open port to full screen	*/

  height = textheight( "H" );           /* Get basic text height        */

  changetextstyle( DEFAULT_FONT, HORIZ_DIR, 1 );
  settextjustify( CENTER_TEXT, TOP_TEXT );
  outtextxy( MaxX/2, 2, header );
  setviewport( 0, height+4, MaxX, MaxY-(height+4), 1 );
  DrawBorder();
  setviewport( 1, height+5, MaxX-1, MaxY-(height+5), 1 );

}

/*									*/
/*	STATUSLINE: Display a status line at the bottom of the screen.	*/
/*									*/

void StatusLine( char *msg )
{
  int height;

  setviewport( 0, 0, MaxX, MaxY, 1 );	/* Open port to full screen	*/
  setcolor( MaxColors - 1 );		/* Set current color to white	*/

  changetextstyle( DEFAULT_FONT, HORIZ_DIR, 1 );
  settextjustify( CENTER_TEXT, TOP_TEXT );
  setlinestyle( SOLID_LINE, 0, NORM_WIDTH );
  setfillstyle( EMPTY_FILL, 0 );

  height = textheight( "H" );           /* Detemine current height      */
  bar( 0, MaxY-(height+4), MaxX, MaxY );
  rectangle( 0, MaxY-(height+4), MaxX, MaxY );
  outtextxy( MaxX/2, MaxY-(height+2), msg );
  setviewport( 1, height+5, MaxX-1, MaxY-(height+5), 1 );

}

/*									*/
/*	DRAWBORDER: Draw a solid single line around the current 	*/
/*	viewport.							*/
/*									*/

void DrawBorder(void)
{
  struct viewporttype vp;

  setcolor( MaxColors - 1 );		/* Set current color to white	*/

  setlinestyle( SOLID_LINE, 0, NORM_WIDTH );

  getviewsettings( &vp );
  rectangle( 0, 0, vp.right-vp.left, vp.bottom-vp.top );

}

/*									*/
/*	CHANGETEXTSTYLE: similar to settextstyle, but checks for	*/
/*	errors that might occur whil loading the font file.		*/
/*									*/

void changetextstyle(int font, int direction, int charsize)
{
  int ErrorCode;

  graphresult();			/* clear error code		*/
  settextstyle(font, direction, charsize);
  ErrorCode = graphresult();		/* check result 		*/
  if( ErrorCode != grOk ){		/* if error occured		*/
    closegraph();
    printf(" Graphics System Error: %s\n", grapherrormsg( ErrorCode ) );
    exit( 1 );
  }
}

/*									*/
/*	GPRINTF: Used like PRINTF except the output is sent to the	*/
/*	screen in graphics mode at the specified co-ordinate.		*/
/*									*/

int gprintf( int *xloc, int *yloc, char *fmt, ... )
{
  va_list  argptr;			/* Argument list pointer	*/
  char str[140];			/* Buffer to build sting into	*/
  int cnt;				/* Result of SPRINTF for return */

  va_start( argptr, fmt );		/* Initialize va_ functions	*/

  cnt = vsprintf( str, fmt, argptr );	/* prints string to buffer	*/
  outtextxy( *xloc, *yloc, str );	/* Send string in graphics mode */
  *yloc += textheight( "H" ) + 2;       /* Advance to next line         */

  va_end( argptr );			/* Close va_ functions		*/

  return( cnt );			/* Return the conversion count	*/

}
/*  setjmp.h

    Defines typedef and functions for setjmp/longjmp.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#ifndef __SETJMP_H
#define __SETJMP_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

typedef struct __jmp_buf {
    unsigned    j_sp;
    unsigned    j_ss;
    unsigned    j_flag;
    unsigned    j_cs;
    unsigned    j_ip;
    unsigned    j_bp;
    unsigned    j_di;
    unsigned    j_es;
    unsigned    j_si;
    unsigned    j_ds;
}   jmp_buf[1];

#ifdef __cplusplus
extern "C" {
#endif

#if !defined( _Windows )
void    _CType longjmp(jmp_buf __jmpb, int __retval);
int     _CType setjmp(jmp_buf __jmpb);
#else
void far pascal longjmp( struct __jmp_buf far *__jmpb, int __retval );
int far pascal setjmp( struct __jmp_buf far *__jmpb);
#endif

#ifdef __cplusplus
}
#endif

#endif

/*  iomanip.h -- streams I/O manipulator declarations

    Copyright (c) 1990, 1992 by Borland International
    All rights reserved
*/

#ifndef __cplusplus
#error Must use C++ for the io stream manipulators.
#endif

#ifndef __IOMANIP_H
#define __IOMANIP_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#if !defined(__IOSTREAM_H)
#include <iostream.h>
#endif

#if !defined(__GENERIC_H)
#include <generic.h>
#endif

#pragma option -Vo-
#if defined(__BCOPT__) && !defined(_RTL_ALLOW_po)
#pragma option -po-
#endif

#define SMANIP(typ)     _Paste2(smanip_, typ)
#define SAPP(typ)       _Paste2(sapply_, typ)
#define IMANIP(typ)     _Paste2(imanip_, typ)
#define OMANIP(typ)     _Paste2(omanip_, typ)
#define IOMANIP(typ)    _Paste2(iomanip_, typ)
#define IAPP(typ)       _Paste2(iapply_, typ)
#define OAPP(typ)       _Paste2(oapply_, typ)
#define IOAPP(typ)      _Paste2(ioapply_, typ)

#define IOMANIPdeclare(typ)                                             \
class _CLASSTYPE SMANIP(typ) {                                                     \
        ios _FAR & (_Cdecl *_fn)(ios _FAR &, typ);                                          \
        typ _ag;                                                        \
public:                                                                 \
        _Cdecl SMANIP(typ)(ios _FAR & (_Cdecl *_f)(ios _FAR &, typ), typ _a) : _fn(_f), _ag(_a) { }\
        friend istream _FAR & _Cdecl operator>>(istream _FAR & _s, const SMANIP(typ) _FAR & _f) {       \
                        (*_f._fn)(_s, _f._ag); return _s; }             \
        friend ostream _FAR & _Cdecl operator<<(ostream _FAR & _s, const SMANIP(typ) _FAR & _f) {       \
                        (*_f._fn)(_s, _f._ag); return _s; }             \
        };                                                              \
class _CLASSTYPE SAPP(typ) {                                                       \
        ios _FAR & (_Cdecl *_fn)(ios _FAR &, typ);                                          \
public:                                                                 \
        SAPP(typ)(ios _FAR & (_Cdecl *_f)(ios _FAR &, typ)) : _fn(_f) { }                   \
        SMANIP(typ) _Cdecl operator()(typ _z) { return SMANIP(typ)(_fn, _z); }  \
        };                                                              \
class _CLASSTYPE IMANIP(typ) {                                                     \
        istream _FAR & (_Cdecl *_fn)(istream _FAR &, typ);                                  \
        typ _ag;                                                        \
public:                                                                 \
        _Cdecl IMANIP(typ)(istream _FAR & (_Cdecl *_f)(istream _FAR &, typ), typ _z ) :            \
                _fn(_f), _ag(_z) { }                                    \
        friend istream _FAR & _Cdecl operator>>(istream _FAR & _s, const IMANIP(typ) _FAR & _f) {       \
                return(*_f._fn)(_s, _f._ag); }                          \
        };                                                              \
class _CLASSTYPE IAPP(typ) {                                                       \
        istream _FAR & (_Cdecl *_fn)(istream _FAR &, typ);                                  \
public:                                                                 \
        _Cdecl IAPP(typ)(istream _FAR & (_Cdecl *_f)(istream _FAR &, typ)) : _fn(_f) { }           \
        IMANIP(typ) _Cdecl operator()(typ _z) {                         \
                return IMANIP(typ)(_fn, _z); }                          \
        };                                                              \
class _CLASSTYPE OMANIP(typ) {                                                     \
        ostream _FAR & (_Cdecl *_fn)(ostream _FAR &, typ);                                  \
        typ _ag;                                                        \
public:                                                                 \
        _Cdecl OMANIP(typ)(ostream _FAR & (_Cdecl *_f)(ostream _FAR &, typ), typ _z ) :            \
                _fn(_f), _ag(_z) { }                                    \
        friend ostream _FAR & _Cdecl operator<<(ostream _FAR & _s, const OMANIP(typ) _FAR & _f) {       \
                return(*_f._fn)(_s, _f._ag); }                          \
        };                                                              \
class _CLASSTYPE OAPP(typ) {                                                       \
        ostream _FAR & (_Cdecl *_fn)(ostream _FAR &, typ);                                  \
public:                                                                 \
        _Cdecl OAPP(typ)(ostream _FAR & (_Cdecl *_f)(ostream _FAR &, typ)) : _fn(_f) { }           \
        OMANIP(typ) _Cdecl operator()(typ _z) {                         \
                return OMANIP(typ)(_fn, _z); }                          \
        };                                                              \
class _CLASSTYPE IOMANIP(typ) {                                                    \
        iostream _FAR & (_Cdecl *_fn)(iostream _FAR &, typ);                                \
        typ _ag;                                                        \
public:                                                                 \
        _Cdecl IOMANIP(typ)(iostream _FAR & (_Cdecl *_f)(iostream _FAR &, typ), typ _z ) : \
                _fn(_f), _ag(_z) { }                                    \
        friend istream _FAR & _Cdecl operator>>(iostream _FAR & _s, const IOMANIP(typ) _FAR & _f) {     \
                return(*_f._fn)(_s, _f._ag); }                          \
        friend ostream _FAR & _Cdecl operator<<(iostream _FAR & _s, const IOMANIP(typ) _FAR & _f) {     \
                return(*_f._fn)(_s, _f._ag); }                          \
        };                                                              \
class _CLASSTYPE IOAPP(typ) {                                                      \
        iostream _FAR & (_Cdecl *_fn)(iostream _FAR &, typ);                                \
public:                                                                 \
        _Cdecl IOAPP(typ)(iostream _FAR & (_Cdecl *_f)(iostream _FAR &, typ)) : _fn(_f) { }        \
        IOMANIP(typ) _Cdecl operator()(typ _z) { return IOMANIP(typ)(_fn, _z); }\
        }



IOMANIPdeclare(int);
IOMANIPdeclare(long);

// set the conversion base to 0, 8, 10, or 16
smanip_int      _Cdecl _FARFUNC setbase(int _b);

// clear the flags bitvector according to the bits set in b
smanip_long     _Cdecl _FARFUNC resetiosflags(long _b);

// set the flags bitvector according to the bits set in b
smanip_long     _Cdecl _FARFUNC setiosflags(long _b);

// set fill character for padding a field
smanip_int      _Cdecl _FARFUNC setfill(int _f);

// set the floating-point precision to n digits
smanip_int      _Cdecl _FARFUNC setprecision(int _n);

// set the field width to n
smanip_int      _Cdecl _FARFUNC setw(int _n);

#pragma option -Vo.
#if defined(__BCOPT__)
#pragma option -po.
#endif

#endif
/*  graphics.h

    Definitions for Graphics Package.

    Copyright (c) 1987, 1992 by Borland International
    All Rights Reserved.
*/

#if defined( _Windows )
#error BGI graphics not supported under Windows
#endif

#if !defined(__GRAPHICS_H)
#define __GRAPHICS_H

#if !defined(___DEFS_H)
#include <_defs.h>
#endif

#define _Cdecl  cdecl

enum graphics_errors {      /* graphresult error return codes */
    grOk           =   0,
    grNoInitGraph      =  -1,
    grNotDetected      =  -2,
    grFileNotFound     =  -3,
    grInvalidDriver    =  -4,
    grNoLoadMem    =  -5,
    grNoScanMem    =  -6,
    grNoFloodMem       =  -7,
    grFontNotFound     =  -8,
    grNoFontMem    =  -9,
    grInvalidMode      = -10,
    grError        = -11,   /* generic error */
    grIOerror      = -12,
    grInvalidFont      = -13,
    grInvalidFontNum   = -14,
    grInvalidVersion   = -18
};

enum graphics_drivers {     /* define graphics drivers */
    DETECT,         /* requests autodetection */
    CGA, MCGA, EGA, EGA64, EGAMONO, IBM8514,    /* 1 - 6 */
    HERCMONO, ATT400, VGA, PC3270,          /* 7 - 10 */
    CURRENT_DRIVER = -1
};

enum graphics_modes {       /* graphics modes for each driver */
    CGAC0      = 0,  /* 320x200 palette 0; 1 page   */
    CGAC1      = 1,  /* 320x200 palette 1; 1 page   */
    CGAC2      = 2,  /* 320x200 palette 2: 1 page   */
    CGAC3      = 3,  /* 320x200 palette 3; 1 page   */
    CGAHI      = 4,  /* 640x200 1 page          */
    MCGAC0     = 0,  /* 320x200 palette 0; 1 page   */
    MCGAC1     = 1,  /* 320x200 palette 1; 1 page   */
    MCGAC2     = 2,  /* 320x200 palette 2; 1 page   */
    MCGAC3     = 3,  /* 320x200 palette 3; 1 page   */
    MCGAMED    = 4,  /* 640x200 1 page          */
    MCGAHI     = 5,  /* 640x480 1 page          */
    EGALO      = 0,  /* 640x200 16 color 4 pages    */
    EGAHI      = 1,  /* 640x350 16 color 2 pages    */
    EGA64LO    = 0,  /* 640x200 16 color 1 page     */
    EGA64HI    = 1,  /* 640x350 4 color  1 page     */
    EGAMONOHI  = 0,  /* 640x350 64K on card, 1 page - 256K on card, 4 pages */
    HERCMONOHI = 0,  /* 720x348 2 pages         */
    ATT400C0   = 0,  /* 320x200 palette 0; 1 page   */
    ATT400C1   = 1,  /* 320x200 palette 1; 1 page   */
    ATT400C2   = 2,  /* 320x200 palette 2; 1 page   */
    ATT400C3   = 3,  /* 320x200 palette 3; 1 page   */
    ATT400MED  = 4,  /* 640x200 1 page          */
    ATT400HI   = 5,  /* 640x400 1 page          */
    VGALO      = 0,  /* 640x200 16 color 4 pages    */
    VGAMED     = 1,  /* 640x350 16 color 2 pages    */
    VGAHI      = 2,  /* 640x480 16 color 1 page     */
    PC3270HI   = 0,  /* 720x350 1 page          */
    IBM8514LO  = 0,  /* 640x480 256 colors      */
    IBM8514HI  = 1   /*1024x768 256 colors      */
};

/* Colors for setpalette and setallpalette */

#if !defined(__COLORS)
#define __COLORS

enum COLORS {
    BLACK,          /* dark colors */
    BLUE,
    GREEN,
    CYAN,
    RED,
    MAGENTA,
    BROWN,
    LIGHTGRAY,
    DARKGRAY,           /* light colors */
    LIGHTBLUE,
    LIGHTGREEN,
    LIGHTCYAN,
    LIGHTRED,
    LIGHTMAGENTA,
    YELLOW,
    WHITE
};
#endif

enum CGA_COLORS {
    CGA_LIGHTGREEN     = 1,     /* Palette C0 Color Names   */
    CGA_LIGHTRED       = 2,
    CGA_YELLOW         = 3,

    CGA_LIGHTCYAN      = 1,     /* Palette C1 Color Names   */
    CGA_LIGHTMAGENTA   = 2,
    CGA_WHITE          = 3,

    CGA_GREEN          = 1,     /* Palette C2 Color Names   */
    CGA_RED        = 2,
    CGA_BROWN          = 3,

    CGA_CYAN           = 1,     /* Palette C3 Color Names   */
    CGA_MAGENTA        = 2,
    CGA_LIGHTGRAY      = 3
};


enum EGA_COLORS {
    EGA_BLACK        =  0,      /* dark colors */
    EGA_BLUE         =  1,
    EGA_GREEN        =  2,
    EGA_CYAN         =  3,
    EGA_RED      =  4,
    EGA_MAGENTA      =  5,
    EGA_BROWN        =  20,
    EGA_LIGHTGRAY    =  7,
    EGA_DARKGRAY     =  56,     /* light colors */
    EGA_LIGHTBLUE    =  57,
    EGA_LIGHTGREEN   =  58,
    EGA_LIGHTCYAN    =  59,
    EGA_LIGHTRED     =  60,
    EGA_LIGHTMAGENTA     =  61,
    EGA_YELLOW       =  62,
    EGA_WHITE        =  63
};

enum line_styles {      /* Line styles for get/setlinestyle */
    SOLID_LINE   = 0,
    DOTTED_LINE  = 1,
    CENTER_LINE  = 2,
    DASHED_LINE  = 3,
    USERBIT_LINE = 4,   /* User defined line style */
};

enum line_widths {      /* Line widths for get/setlinestyle */
    NORM_WIDTH  = 1,
    THICK_WIDTH = 3,
};

enum font_names {
    DEFAULT_FONT    = 0,    /* 8x8 bit mapped font */
    TRIPLEX_FONT    = 1,    /* "Stroked" fonts */
    SMALL_FONT  = 2,
    SANS_SERIF_FONT = 3,
    GOTHIC_FONT = 4,
    SCRIPT_FONT = 5,
    SIMPLEX_FONT = 6,
    TRIPLEX_SCR_FONT = 7,
    COMPLEX_FONT = 8,
    EUROPEAN_FONT = 9,
    BOLD_FONT = 10
};

#define HORIZ_DIR   0   /* left to right */
#define VERT_DIR    1   /* bottom to top */

#define USER_CHAR_SIZE  0   /* user-defined char size */

enum fill_patterns {        /* Fill patterns for get/setfillstyle */
    EMPTY_FILL,     /* fills area in background color */
    SOLID_FILL,     /* fills area in solid fill color */
    LINE_FILL,      /* --- fill */
    LTSLASH_FILL,       /* /// fill */
    SLASH_FILL,     /* /// fill with thick lines */
    BKSLASH_FILL,       /* \\\ fill with thick lines */
    LTBKSLASH_FILL,     /* \\\ fill */
    HATCH_FILL,     /* light hatch fill */
    XHATCH_FILL,        /* heavy cross hatch fill */
    INTERLEAVE_FILL,    /* interleaving line fill */
    WIDE_DOT_FILL,      /* Widely spaced dot fill */
    CLOSE_DOT_FILL,     /* Closely spaced dot fill */
    USER_FILL       /* user defined fill */
};

enum putimage_ops {     /* BitBlt operators for putimage */
    COPY_PUT,       /* MOV */
    XOR_PUT,        /* XOR */
    OR_PUT,         /* OR  */
    AND_PUT,        /* AND */
    NOT_PUT         /* NOT */
};

enum text_just {        /* Horizontal and vertical justification
                   for settextjustify */
    LEFT_TEXT   = 0,
    CENTER_TEXT = 1,
    RIGHT_TEXT  = 2,

    BOTTOM_TEXT = 0,
     /* CENTER_TEXT = 1,  already defined above */
    TOP_TEXT    = 2
};


#define MAXCOLORS 15

struct palettetype {
    unsigned char size;
    signed char colors[MAXCOLORS+1];
};

struct linesettingstype {
    int linestyle;
    unsigned upattern;
    int thickness;
};

struct textsettingstype {
    int font;
    int direction;
    int charsize;
    int horiz;
    int vert;
};

struct fillsettingstype {
    int pattern;
    int color;
};

struct pointtype {
    int x, y;
};

struct viewporttype {
    int left, top, right, bottom;
    int clip;
};

struct arccoordstype {
    int x, y;
    int xstart, ystart, xend, yend;
};

#ifdef __cplusplus
extern "C" {
#endif
void       far _Cdecl arc(int __x, int __y, int __stangle, int __endangle,
              int __radius);
void       far _Cdecl bar(int __left, int __top, int __right, int __bottom);
void       far _Cdecl bar3d(int __left, int __top, int __right, int __bottom,
                int __depth, int __topflag);
void       far _Cdecl circle(int __x, int __y, int __radius);
void       far _Cdecl cleardevice(void);
void       far _Cdecl clearviewport(void);
void       far _Cdecl closegraph(void);
void       far _Cdecl detectgraph(int far *__graphdriver,int far *__graphmode);
void       far _Cdecl drawpoly(int __numpoints, const int far *__polypoints);
void       far _Cdecl ellipse(int __x, int __y, int __stangle, int __endangle,
                  int __xradius, int __yradius);
void       far _Cdecl fillellipse( int __x, int __y, int __xradius, int __yradius );
void       far _Cdecl fillpoly(int __numpoints, const int far *__polypoints);
void       far _Cdecl floodfill(int __x, int __y, int __border);
void       far _Cdecl getarccoords(struct arccoordstype far *__arccoords);
void       far _Cdecl getaspectratio(int far *__xasp, int far *__yasp);
int    far _Cdecl getbkcolor(void);
int    far _Cdecl getcolor(void);
struct palettetype far * far _Cdecl getdefaultpalette( void );
char *     far _Cdecl getdrivername( void );
void       far _Cdecl getfillpattern(char far *__pattern);
void       far _Cdecl getfillsettings(struct fillsettingstype far *__fillinfo);
int    far _Cdecl getgraphmode(void);
void       far _Cdecl getimage(int __left, int __top, int __right, int __bottom,
                   void far *__bitmap);
void       far _Cdecl getlinesettings(struct linesettingstype far *__lineinfo);
int    far _Cdecl getmaxcolor(void);
int    far _Cdecl getmaxmode(void);
int    far _Cdecl getmaxx(void);
int    far _Cdecl getmaxy(void);
char *     far _Cdecl getmodename( int __mode_number );
void       far _Cdecl getmoderange(int __graphdriver, int far *__lomode,
                   int far *__himode);
unsigned   far _Cdecl getpixel(int __x, int __y);
void       far _Cdecl getpalette(struct palettetype far *__palette);
int    far _Cdecl getpalettesize( void );
void       far _Cdecl gettextsettings(struct textsettingstype far *__texttypeinfo);
void       far _Cdecl getviewsettings(struct viewporttype far *__viewport);
int    far _Cdecl getx(void);
int    far _Cdecl gety(void);
void       far _Cdecl graphdefaults(void);
char *     far _Cdecl grapherrormsg(int __errorcode);
void       far _Cdecl _graphfreemem(void far *__ptr, unsigned __size);
void far * far _Cdecl _graphgetmem(unsigned __size);
int    far _Cdecl graphresult(void);
unsigned   far _Cdecl imagesize(int __left, int __top, int __right, int __bottom);
void       far _Cdecl initgraph(int  far *__graphdriver,
                int  far *__graphmode,
                const char far *__pathtodriver);
int    far _Cdecl installuserdriver( const char far *__name,
                int huge (*detect)(void) );
int    far _Cdecl installuserfont( const char far *__name );
void       far _Cdecl line(int __x1, int __y1, int __x2, int __y2);
void       far _Cdecl linerel(int __dx, int __dy);
void       far _Cdecl lineto(int __x, int __y);
void       far _Cdecl moverel(int __dx, int __dy);
void       far _Cdecl moveto(int __x, int __y);
void       far _Cdecl outtext(const char far *__textstring);
void       far _Cdecl outtextxy(int __x, int __y, const char far *__textstring);
void       far _Cdecl pieslice(int __x, int __y, int __stangle, int __endangle,
                   int __radius);
void       far _Cdecl putimage(int __left, int __top, const void far *__bitmap,
                int __op);
void       far _Cdecl putpixel(int __x, int __y, int __color);
void       far _Cdecl rectangle(int __left, int __top, int __right, int __bottom);
void       far _Cdecl restorecrtmode(void);
void       far _Cdecl sector( int __X, int __Y, int __StAngle, int __EndAngle,
                  int __XRadius, int __YRadius );
void       far _Cdecl setactivepage(int __page);
void       far _Cdecl setallpalette(const struct palettetype far *__palette);
void       far _Cdecl setaspectratio( int __xasp, int __yasp );
void       far _Cdecl setbkcolor(int __color);
void       far _Cdecl setcolor(int __color);
void       far _Cdecl setfillpattern(const char far *__upattern, int __color);
void       far _Cdecl setfillstyle(int __pattern, int __color);
unsigned   far _Cdecl setgraphbufsize(unsigned __bufsize);
void       far _Cdecl setgraphmode(int __mode);
void       far _Cdecl setlinestyle(int __linestyle, unsigned __upattern,
                   int __thickness);
void       far _Cdecl setpalette(int __colornum, int __color);
void       far _Cdecl setrgbpalette(int __colornum,
                    int __red, int __green, int __blue);
void       far _Cdecl settextjustify(int __horiz, int __vert);
void       far _Cdecl settextstyle(int __font, int __direction, int __charsize);
void       far _Cdecl setusercharsize(int __multx, int __divx,
                      int __multy, int __divy);
void       far _Cdecl setviewport(int __left, int __top, int __right, int __bottom,
                  int __clip);
void       far _Cdecl setvisualpage(int __page);
void       far _Cdecl setwritemode( int __mode );
int    far _Cdecl textheight(const char far *__textstring);
int    far _Cdecl textwidth(const char far *__textstring);

/***** graphics drivers *****/

int        _Cdecl registerbgidriver(void (*driver)(void));
int    far _Cdecl registerfarbgidriver(void far *__driver);

/* !!        These "functions" are NOT user-callable          !! */
/* !! They are there just so you can link in graphics drivers !! */

void           _Cdecl CGA_driver(void);
void           _Cdecl EGAVGA_driver(void);
void           _Cdecl IBM8514_driver(void);
void           _Cdecl Herc_driver(void);
void           _Cdecl ATT_driver(void);
void           _Cdecl PC3270_driver(void);

extern int far _Cdecl CGA_driver_far[];
extern int far _Cdecl EGAVGA_driver_far[];
extern int far _Cdecl IBM8514_driver_far[];
extern int far _Cdecl Herc_driver_far[];
extern int far _Cdecl ATT_driver_far[];
extern int far _Cdecl PC3270_driver_far[];


/***** graphics fonts *****/

int        _Cdecl registerbgifont(void (*font)(void));
int    far _Cdecl registerfarbgifont(void far *__font);

/* !!   These "functions" are NOT user-callable,   !! */
/* !! they are there just so you can link in fonts !! */

void           _Cdecl   triplex_font(void);
void           _Cdecl     small_font(void);
void           _Cdecl sansserif_font(void);
void           _Cdecl    gothic_font(void);

extern int far _Cdecl   triplex_font_far[];
extern int far _Cdecl     small_font_far[];
extern int far _Cdecl sansserif_font_far[];
extern int far _Cdecl    gothic_font_far[];

#ifdef __cplusplus
}
#endif

#endif
pkBGI Device Driver (PC3270) 2.00 - Mar 21 1988
Copyright (c) 1987,1988 Borland International
                         PC3270               U ]CB      ,   2    "q'aA     r _                Ø         .>z u ˸ ˴$.~ R&CC&CC<s
2"t}2K"y@uÀu>z tÀ> u>&?<u `
&GCË&؋ 	
<t  >z u N                               ]](#XQ  720 x 350 3270 PC <u<u2óÊ2@{z<sz 2~ &$> u{-<u<r<t#663ɶO22ø  K3À>z t3"t"tÉ|ó:v:vã|ãQRȋӇ ZYË6|>.    }<rU,2
Q>z t O O >}  Ъ ª2ҳs
uÀ>z t"t <t3ۃ	Q                  >uK&"t*SQ2Y[>uKC"x-&  SQ|Y[ x<t
2؋                             ? (  ? (   (  P  [Z  P  ]Z  <r
؁G	GG W2P Xش>t2$ø ø ø@ 0  33 @5-.[WW  3۹ PSQ؎ 2BJY 3X󫺸X
@ ûe &RRbRbRbrx4t  Á4tðÁ  ..+    QuZS$
2.~[YQɀuZ    QuPS$
2.[YQɀuP;w;w;	w;	vËv>;rډF^F ;rF쀑+F+ډ^/F^;rF^+؉^+؉^  ^F+ÉF+ÉF  ^V~vF$>{s$
F>z t@>~ t fnnEs t&0'
&"
&S{2:"yCC8[Muƀu8֨@uŀuCs t&0'
&"
&Muƀu֨@uŀuC8s t&0'
&"
&뽋NV{<s <rр>z t"Ŋfz"uu{fv<sF t  ^ <r^㎇~<u   %  %!&&0
&  "&"
&;r;rڋ>z uQ+B S2ދ+â>z t@[PVQS ^[ .>z u.{	[ .s	].PSUW.>z t.uV/ ^ .>z t Q;rQ_][X8. uSM#t.GMu.>z t."*.>z u:Z}
.Gĳ".Ã.>z u? U2BW{<s <r؋ֹ?&z"t""uȆ [&{s
t  Àr㎇~u                  @8px<iZ-KB$$B3333     "  "                 &u
䀈&p
$"uÈq
"ur
- v
- x
#x>+>v
;s#x>+>x
;sSQ _^.t
..r
PS&V  .q
 Ou[6 XuE.t
ut7"
7.>z u"xCu.s
.>{s
.8.s
.8.s
        <0uO2<Ar<{r<r n 
>u
 tA&F &^&N&V` ֖Muڽ`s
|>z t"t	"8l  ||    |~  x00000x |     ||  || x`0x 000000 | l8  l8l f< 0` <00000< `0 <<  8l           00       |~~    |~ ~v   |~ 0|0000   ~v|  8<  8 8<         ||     ~v  np```   || 00|000   ~   l8   l   l8l   v|  0`                                                       ++BQSc_[u.>z t.{	.PRV+ ^ZX.>{r.8.8.uԋìଊ#t	&%GJ"&%G   &0&
& "&"
&+BS2âދ+â>z t@[PVQS^[ .>z u.{	[ .s	Z.PSRW _Z[X.8.uSJ2#t.G嬊J.>z t."*.>z u:Z}.G2".Ã.>z uN8' 22Ã>z t 2拄&"
&Ëڋǃ玅P ڋǃ玅~Z 拄&"
&øZ P RZ 拄&"
&p ΃A&$Ëǃ玅P ǃ玅~Z ΀&$øZ P RZ R蜿P s  Ztr>z tr&
  ރ	>z t"tRMMF 	+MMF   MMv  MM~ Zk&"":t2%[N EEu
&
Ë~ EEv EE^ EE"SP$x Xtu> u s5 % r+ ; 떡@;uH9~@9áH;t2;sF4;t02&-;6tN>z utO&-"":t8""
;6t&N>z ut&-O&-t& &-Fɀ>z utG&-6à&-:u&;6|+6Oa&-"":t8""
;6}&Fɀ>z ut&-G&-t &-N6&-:u&;6s6GÀFɀ>z utG &"":u^>u
&t> t:u
t
? u)":t!urMM^ MMv MM~ MMN ;6sn
&:u&+&:u;6G&"":t!+Q.&:-u;s6GYÉ6>
 &ËÊt	؀>z t"tPR	% >z uZQЀ>z t u&[Ë6>&&>z u2ƴts "t"uÀuSQPQO2
C"u2XY[P >z t +@	+	+X%*Pev/4PS2G[XKu  ÁCuǰÁ  KPCPKZCZà<r$<s SӃ<t4KSӃuZ.~[CSӃuZKSӃuP.[CSӃuP? ?@??  0    @       